<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:webfeeds="http://webfeeds.org/rss/1.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>古时的风筝</title><link>https://moonkite.cn/</link><description>Recent content on 古时的风筝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 02 Jun 2023 08:56:23 +0800</lastBuildDate><atom:link href="https://moonkite.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>Java 上进了，JDK21马上就要来了，感受一下它的魅力</title><link>https://moonkite.cn/category/java/JDK21%E9%A9%AC%E4%B8%8A%E5%B0%B1%E8%A6%81%E6%9D%A5%E4%BA%86%E6%84%9F%E5%8F%97%E4%B8%80%E4%B8%8B%E5%AE%83%E7%9A%84%E9%AD%85%E5%8A%9B/</link><pubDate>Fri, 02 Jun 2023 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/java/JDK21%E9%A9%AC%E4%B8%8A%E5%B0%B1%E8%A6%81%E6%9D%A5%E4%BA%86%E6%84%9F%E5%8F%97%E4%B8%80%E4%B8%8B%E5%AE%83%E7%9A%84%E9%AD%85%E5%8A%9B/</guid><description>目前 Java 的最新稳定版是 JDK 20，但这是个过渡版，JDK21就是 LTS 版的了，也快要发布了，在今年9月份（也就是2023年9月）就要正式发布了。 但是，</description><content:encoded><![CDATA[<p>目前 Java 的最新稳定版是 JDK 20，但这是个过渡版，JDK21就是 LTS 版的了，也快要发布了，在今年9月份（也就是2023年9月）就要正式发布了。</p>
<p>但是，猜都不用猜，你肯定还在用 Java 8 吧！</p>
<h2 id="更丝滑的并发编程模式">更丝滑的并发编程模式</h2>
<p>如果说之前的 JDK17你还觉得没必要折腾，那 JDK21确实有必要关注一下了。因为 JDK21 引入了一种新型的并发编程模式。</p>
<p>当前 Java 中的多线程并发编程绝对是另我们都非常头疼的一部分，感觉就是学起来难啃，用起来难用。但是转头看看使用其他语言的朋友们，根本就没有这个烦恼嘛，比如 GoLang，感觉人家用起来就很丝滑呢。</p>
<p>JDK21 中就在这方面做了很大的改进，让Java并发编程变得更简单一点，更丝滑一点。确切的说，在 JDK19或JDK20中就有这些改进了。</p>
<p>那具体是什么呢？让我们来具体来看一下。下面是JDK21的 Feature。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20230531172947636.png" alt=""></p>
<p>其中<code>Virtual Threads</code>、<code>Scoped Values</code>、<code>Structured Concurrency</code>就是针对多线程并发编程的几个功能。我们今天也主要来说一下他们。</p>
<h3 id="虚拟线程virtual-threads">虚拟线程（Virtual Threads）</h3>
<p>虚拟线程是基于协程的线程，它们与其他语言中的协程具有相似之处，但也存在一些不同之处。</p>
<p>虚拟线程是依附于主线程的，如果主线程销毁了，那虚拟线程也不复存在。</p>
<p>相同之处：</p>
<ol>
<li>虚拟线程和协程都是轻量级的线程，它们的创建和销毁的开销都比传统的操作系统线程要小。</li>
<li>虚拟线程和协程都可以通过暂停和恢复来实现线程之间的切换，从而避免了线程上下文切换的开销。</li>
<li>虚拟线程和协程都可以使用异步和非阻塞的方式来处理任务，提高应用程序的性能和响应速度。</li>
</ol>
<p>不同之处：</p>
<ol>
<li>虚拟线程是在 JVM 层面实现的，而协程则是在语言层面实现的。因此，虚拟线程的实现可以与任何支持 JVM 的语言一起使用，而协程的实现则需要特定的编程语言支持。</li>
<li>虚拟线程是一种基于线程的协程实现，因此它们可以使用线程相关的 API，如 <code>ThreadLocal</code>、<code>Lock</code> 和 <code>Semaphore</code>。而协程则不依赖于线程，通常需要使用特定的异步编程框架和 API。</li>
<li>虚拟线程的调度是由 JVM 管理的，而协程的调度是由编程语言或异步编程框架管理的。因此，虚拟线程可以更好地与其他线程进行协作，而协程则更适合处理异步任务。</li>
</ol>
<p>总的来说，虚拟线程是一种新的线程类型，它可以提高应用程序的性能和资源利用率，同时也可以使用传统线程相关的 API。虚拟线程与协程有很多相似之处，但也存在一些不同之处。</p>
<p>虚拟线程确实可以让多线程编程变得更简单和更高效。相比于传统的操作系统线程，虚拟线程的创建和销毁的开销更小，线程上下文切换的开销也更小，因此可以大大减少多线程编程中的资源消耗和性能瓶颈。</p>
<p>使用虚拟线程，开发者可以像编写传统的线程代码一样编写代码，而无需担心线程的数量和调度，因为 JVM 会自动管理虚拟线程的数量和调度。此外，虚拟线程还支持传统线程相关的 API，如 <code>ThreadLocal</code>、<code>Lock</code> 和 <code>Semaphore</code>，这使得开发者可以更轻松地迁移传统线程代码到虚拟线程。</p>
<p>虚拟线程的引入，使得多线程编程变得更加高效、简单和安全，使得开发者能够更加专注于业务逻辑，而不必过多地关注底层的线程管理。</p>
<h3 id="结构化并发structured-concurrency">结构化并发（Structured Concurrency）</h3>
<p>结构化并发是一种编程范式，旨在通过提供结构化和易于遵循的方法来简化并发编程。使用结构化并发，开发人员可以创建更容易理解和调试的并发代码，并且不容易出现竞争条件和其他与并发有关的错误。在结构化并发中，所有并发代码都被结构化为称为任务的定义良好的工作单元。任务以结构化方式创建、执行和完成，任务的执行总是保证在其父任务完成之前完成。</p>
<p>Structured Concurrency（结构化并发）可以让多线程编程更加简单和可靠。在传统的多线程编程中，线程的启动、执行和结束是由开发者手动管理的，因此容易出现线程泄露、死锁和异常处理不当等问题。</p>
<p>使用结构化并发，开发者可以更加自然地组织并发任务，使得任务之间的依赖关系更加清晰，代码逻辑更加简洁。结构化并发还提供了一些异常处理机制，可以更好地管理并发任务中的异常，避免因为异常而导致程序崩溃或数据不一致的情况。</p>
<p>除此之外，结构化并发还可以通过限制并发任务的数量和优先级，防止资源竞争和饥饿等问题的发生。这些特性使得开发者能够更加方便地实现高效、可靠的并发程序，而无需过多关注底层的线程管理。</p>
<h3 id="作用域值scoped-values">作用域值（Scoped Values）</h3>
<p>作用域值是JDK 20中的一项功能，允许开发人员创建作用域限定的值，这些值限定于特定的线程或任务。作用域值类似于线程本地变量，但是设计为与虚拟线程和结构化并发配合使用。它们允许开发人员以结构化的方式在任务和虚拟线程之间传递值，无需复杂的同步或锁定机制。作用域值可用于在应用程序的不同部分之间传递上下文信息，例如用户身份验证或请求特定数据。</p>
<h2 id="试验一下">试验一下</h2>
<p>进行下面的探索之前，你要下载至少 JDK19或者直接下载 JDK20，JDK 20 目前（截止到2023年9月份）是正式发布的最高版本，如果你用 JDK 19的话，没办法体验到Scoped Values的功能。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20230428164027447.png" alt=""></p>
<p>或者是直接下载 JDK 21 的 Early-Access Builds（早期访问版本）。在这个地址下载 「https://jdk.java.net/21/」，下载对应的版本。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20230428165054158.png" alt=""></p>
<p>如果你用的是 IDEA ，那你的IDEA 版本最起码是2022.3 这个版本或者之后的，否则不支持这么新的 JDK 版本。</p>
<p>如果你用的是 JDK19或者 JDK20的话，要在你的项目设置中将 <code>language level</code>设置为19或20的 Preview 级别，否则编译的时候会提示你无法使用预览版的功能，虚拟线程就是预览版的功能。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20230428165350127.png" alt=""></p>
<p>如果你用的是 JDK21的话，将 <code>language level</code> 设置为 <code>X -Experimental Features</code>，另外，因为 JDK21不属于正式版本，所以需要到 IDEA 的设置中（注意是 IDEA 的设置，不是项目的设置了），将这个项目的 <code>Target bytecode version</code>手动修改为21，目前可选的最高就是20，也就是JDK20。设置为21之后，就可以使用 JDK21中的这些功能了。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20230531214527330.png" alt=""></p>
<h2 id="虚拟线程的例子">虚拟线程的例子</h2>
<p>我们现在启动线程是怎么做的呢？</p>
<p>先声明一个线程类，<code>implements</code> 自 <code>Runnable</code>，并实现 <code>run</code>方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleThread</span> <span class="kd">implements</span> <span class="n">Runnable</span><span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;当前线程名称：&#34;</span> <span class="o">+</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">        <span class="k">try</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>然后就可以使用这个线程类，然后启动线程了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="k">new</span> <span class="n">SimpleThread</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</span></span></code></pre></div><p>中规中矩，没毛病。</p>
<p>有了虚拟线程之后呢，怎么实现呢？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Thread</span><span class="o">.</span><span class="na">ofPlatform</span><span class="o">().</span><span class="na">name</span><span class="o">(</span><span class="s">&#34;thread-test&#34;</span><span class="o">).</span><span class="na">start</span><span class="o">(</span><span class="k">new</span> <span class="n">SimpleThread</span><span class="o">());</span>
</span></span></code></pre></div><p>下面是几种使用虚拟线程的方式。</p>
<p>1、直接启动一个虚拟线程</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">startVirtualThread</span><span class="o">(</span><span class="k">new</span> <span class="n">SimpleThread</span><span class="o">());</span>
</span></span></code></pre></div><p>2、使用 ofVirtual()，builder 方式启动虚拟线程，可以设置线程名称、优先级、异常处理等配置</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Thread</span><span class="o">.</span><span class="na">ofVirtual</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">name</span><span class="o">(</span><span class="s">&#34;thread-test&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">start</span><span class="o">(</span><span class="k">new</span> <span class="n">SimpleThread</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">//或者
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">ofVirtual</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">name</span><span class="o">(</span><span class="s">&#34;thread-test&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">uncaughtExceptionHandler</span><span class="o">((</span><span class="n">t</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">  <span class="o">})</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">unstarted</span><span class="o">(</span><span class="k">new</span> <span class="n">SimpleThread</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</span></span></code></pre></div><p>3、使用 Factory 创建线程</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">ThreadFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">ofVirtual</span><span class="o">().</span><span class="na">factory</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">newThread</span><span class="o">(</span><span class="k">new</span> <span class="n">SimpleThread</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="n">thread</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&#34;thread-test&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</span></span></code></pre></div><p>4、使用 Executors 方式</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">ExecutorService</span> <span class="n">executorService</span> <span class="o">=</span> <span class="n">Executors</span><span class="o">.</span><span class="na">newVirtualThreadPerTaskExecutor</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">Future</span><span class="o">&lt;?&gt;</span> <span class="n">submit</span> <span class="o">=</span> <span class="n">executorService</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="k">new</span> <span class="n">SimpleThread</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="n">Object</span> <span class="n">o</span> <span class="o">=</span> <span class="n">submit</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
</span></span></code></pre></div><h2 id="结构化编程的例子">结构化编程的例子</h2>
<p>想一下下面这个场景，假设你有三个任务要同时进行，只要任意一个任务执行完成并返回结果了，那就可以直接用这个结果了，其他的两个任务就可以停止了。比如说一个天气服务，通过三个渠道获取天气情况，只要有一个渠道返回就可以了。</p>
<p>这种场景下， 在 Java 8 下应该怎么做呢，当然也可以了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 执行任务并返回 Future 对象列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">List</span><span class="o">&lt;</span><span class="n">Future</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">futures</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="na">invokeAll</span><span class="o">(</span><span class="n">tasks</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 等待任一任务完成并获取结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="na">invokeAny</span><span class="o">(</span><span class="n">tasks</span><span class="o">);</span>
</span></span></code></pre></div><p>使用 <code>ExecutorService</code>的<code>invokeAll</code>和<code>invokeAny</code>实现，但是会有一些额外的工作，在拿到第一个结果后，要手动关闭另外的线程。</p>
<p>而 JDK21中呢，可以用结构化编程实现。</p>
<p><code>ShutdownOnSuccess</code>捕获第一个结果并关闭任务范围以中断未完成的线程并唤醒调用线程。
适用于任意子任务的结果都可以直接使用，并且无需等待其他未完成任务的结果的情况。
它定义了获取第一个结果或在所有子任务失败时抛出异常的方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="o">(</span><span class="n">var</span> <span class="n">scope</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StructuredTaskScope</span><span class="o">.</span><span class="na">ShutdownOnSuccess</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Future</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">res1</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">runTask</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">Future</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">res2</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">runTask</span><span class="o">(</span><span class="mi">2</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">Future</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">res3</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">runTask</span><span class="o">(</span><span class="mi">3</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">scope</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;scope:&#34;</span> <span class="o">+</span> <span class="n">scope</span><span class="o">.</span><span class="na">result</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ExecutionException</span> <span class="o">|</span> <span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">runTask</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">long</span> <span class="n">l</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Random</span><span class="o">().</span><span class="na">nextLong</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">l</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;第&#34;</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">&#34;个任务：&#34;</span> <span class="o">+</span> <span class="n">s</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><strong>ShutdownOnFailure</strong></p>
<p>执行多个任务，只要有一个失败（出现异常或其他主动抛出异常情况），就停止其他未执行完的任务，使用scope.throwIfFailed捕捉并抛出异常。
如果所有任务均正常，则使用 Feture.get() 或*Feture.resultNow() 获取结果</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="o">(</span><span class="n">var</span> <span class="n">scope</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StructuredTaskScope</span><span class="o">.</span><span class="na">ShutdownOnFailure</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Future</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">res1</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">runTaskWithException</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">Future</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">res2</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">runTaskWithException</span><span class="o">(</span><span class="mi">2</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">Future</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">res3</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">runTaskWithException</span><span class="o">(</span><span class="mi">3</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">scope</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">scope</span><span class="o">.</span><span class="na">throwIfFailed</span><span class="o">(</span><span class="n">Exception</span><span class="o">::</span><span class="k">new</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">res1</span><span class="o">.</span><span class="na">resultNow</span><span class="o">();</span> <span class="c1">//或 res1.get()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">res1</span><span class="o">,</span> <span class="n">res2</span><span class="o">,</span><span class="n">res3</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">Future</span><span class="o">::</span><span class="n">resultNow</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">joining</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;直接结果:&#34;</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//throw new RuntimeException(e);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 有一定几率发生异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">runTaskWithException</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">long</span> <span class="n">l</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Random</span><span class="o">().</span><span class="na">nextLong</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="o">(</span><span class="n">l</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">throw</span> <span class="k">new</span> <span class="n">InterruptedException</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">l</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;第&#34;</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">&#34;个任务：&#34;</span> <span class="o">+</span> <span class="n">s</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="scoped-values-的例子">Scoped Values 的例子</h2>
<p>我们肯定都用过 <code>ThreadLocal</code>，它是线程本地变量，只要这个线程没销毁，可以随时获取 ThredLocal 中的变量值。Scoped Values 也可以在线程内部随时获取变量，只不过它有个作用域的概念，超出作用域就会销毁。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ScopedValueExample</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">final</span> <span class="kd">static</span> <span class="n">ScopedValue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">LoginUser</span> <span class="o">=</span> <span class="n">ScopedValue</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ScopedValue</span><span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">LoginUser</span><span class="o">,</span> <span class="s">&#34;张三&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">run</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">new</span> <span class="n">Service</span><span class="o">().</span><span class="na">login</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">                <span class="o">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2000</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Service</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="nf">login</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;当前登录用户是：&#34;</span> <span class="o">+</span> <span class="n">LoginUser</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>上面的例子模拟一个用户登录的过程，使用 <code>ScopedValue.newInstance()</code>声明了一个 <code>ScopedValue</code>，用 <code>ScopedValue.where</code>给 <code>ScopedValue</code>设置值，并且使用 run 方法执行接下来要做的事儿，这样一来，<code>ScopedValue</code>就在 run() 的内部随时可获取了，在run方法中，模拟调用了一个service 的login方法，不用传递LoginUser这个参数，就可以直接通过<code>LoginUser.get</code>方法获取当前登录用户的值了。</p>
]]></content:encoded></item><item><title>VsCode ChatGPT 插件，一个代码助手</title><link>https://moonkite.cn/category/product/1-VsCode-ChatGPT-%E6%8F%92%E4%BB%B6%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81%E5%8A%A9%E6%89%8B/</link><pubDate>Fri, 02 Jun 2023 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/product/1-VsCode-ChatGPT-%E6%8F%92%E4%BB%B6%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81%E5%8A%A9%E6%89%8B/</guid><description>一个 VsCode 插件版的代码助手，通过接入 ChatGPT，直接在 VsCode 中向 ChatGPT 提问</description><content:encoded><![CDATA[<p><strong>安装地址</strong>：<a href="https://marketplace.visualstudio.com/items?itemName=fengzheng.code-chatgpt-assistant"><strong>mini ChatGPT</strong></a></p>
<p>其实很早之前就想学学 VSCode 插件开发了，但是又不知道做什么，加上我这半吊子前端水平，迟迟没有动手。</p>
<p>最近 ChatGPT 火的一塌糊涂，我也一直在用，真的非常好用，有些问题之前需要 Google 搜索，现在用 ChatGPT 基本上都能直接解决，效率提升了不少。</p>
<p>但是吧，浏览器和 IDE 来回切换又很麻烦，所以我灵机一动，那就开发个 ChatGPT 插件吧，即可以学习学习 VSCode 插件开发，又可以做一个方便的效率工具，岂不是一举两得，美哉美哉。</p>
<p>于是我就动手写了下面这个插件，叫做 <code>mini ChatGPT</code>，现在已经发布到 VSCode 插件市场了。</p>
<p>有条件的同学可以安装一下，试试效果如何。</p>
<p><strong>插件功能特点</strong></p>
<ul>
<li>界面简洁，没有多余的干扰；</li>
<li>像 ChatGPT 官网输出效果一致，打字效果实时输出；</li>
<li>支持两轮上下文（太多了浪费 tokens），大致等于支持上下文；</li>
<li>代码美化+格式化，并且可以一键复制，直接粘贴到 vscode 中；</li>
</ul>
<p><img src="https://hexo.moonkite.cn/blog/image-20230509181750193.png" alt=""></p>
<h2 id="插件安装">插件安装</h2>
<p><strong>当然了，这是需要科学上网的。</strong></p>
<p>你可以直接在 VSCode 的商店直接搜索 <code>mini ChatGPT</code>安装。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20230509183628014.png" alt=""></p>
<p>也可以到应用市场上安装。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20230509183750997.png" alt=""></p>
<p>插件地址：https://marketplace.visualstudio.com/items?itemName=fengzheng.code-chatgpt-assistant</p>
<h2 id="插件使用">插件使用</h2>
<ol>
<li>点击查看-&gt;命令面板，或者使用快捷键（MacOS: Shift + Command + P，Windows:Shift + Control + P</li>
<li>输入 <code>Chat</code> 并回车。
<img src="https://hexo.moonkite.cn/blog/20230509111926.png" alt=""></li>
<li>如果是首次使用，会弹出提示输入框，在此输入 ChatGPT 的 API。使用的就是原滋原味的 ChatGPT API 接口，官网上都写的很清楚，所以需要使用插件的小伙伴提供自己账号的 API key。下面有介绍如何获取ChatGPT API key。
<img src="https://hexo.moonkite.cn/blog/20230509112123.png" alt=""></li>
<li>之后就可以使用啦
<img src="https://hexo.moonkite.cn/blog/20230509112311.png" alt=""></li>
<li>如果之后想更换 ChatGPT 的 API key，在命令面板中输入 <code>ChatGPT API</code> 即可。</li>
</ol>
<p><strong>使用建议</strong></p>
<p>此插件只有一个 webview 实现，打开之后独占一个 tab，可以设置向左或向右拆分，然后在左侧使用此插件向 ChatGPT 提问，右侧是代码文件，这样就不用来回切换了，而且可以将代码片段一键复制，然后直接运行。</p>
<p><img src="https://hexo.moonkite.cn/blog/chatgpt.gif" alt=""></p>
<p><strong>获取 ChatGPT API key</strong></p>
<ol>
<li>
<p>先准备好科学上网，不要用亚洲节点。</p>
</li>
<li>
<p>之后到 <a href="https://platform.openai.com/">OpenAI 官网</a>注册账号。</p>
</li>
<li>
<p>到<a href="https://platform.openai.com/account/api-keys">个人中心</a> 创建一个 API key。</p>
</li>
</ol>
<p><img src="https://hexo.moonkite.cn/blog/20230509133206.png" alt=""></p>
<h2 id="开发历程">开发历程</h2>
<p>作为一个后端开发，我的前端水平是非常一般的，所以代码中有瑕疵的地方还请见谅。对了，代码已经放到 GitHub  上了。</p>
<p>仓库地址：https://github.com/huzhicheng/vscode-ChatGPT</p>
<p>VSCode 插件开发，官方建议是用 TypeScript 开发，所以项目完全采用了 TS 开发。由于功能比较简单，没有那么多复杂的设置，由于边学边做，太复杂的也没考虑。整个插件的核心其实就是一个 <code>webview</code>，在webview中实现界面布局和样式，难点就在于webview与插件本身来回的数据传递，但也都是常规用法。</p>
<p>整个写代码的过程其实也就几个小时，当然过程中的遇到的一些问题我都是跟 ChatGPT 提问的，包括样式都是直接描述需求，ChatGPT 给我一个大致的框架，我再微调一下就可以了。</p>
<p>所以这样看下来，其实是我和 ChatGPT 合作开发的。</p>
<p>后来发布到应用商店，写 readme 介绍和使用说明花了一些时间。</p>
<h2 id="问题和建议">问题和建议</h2>
<p>目前的版本功能比较简单，没有 ChatGPT 官方的聊天记录列表功能，如果真的有人用的话，后期考虑加上。</p>
<p>由于ChatGPT 官方并未提供上下文的 API 支持，所以只能采用其他方式模仿上下文能力，目前的做法是记录前两轮提问和回答，然后在下次提问的时候，将前两轮的提问和回答告诉 ChatGPT ，并且明确告诉 ChatGPT，例如下面这样。</p>
<p>第一轮问题：你好。</p>
<p>第一轮回答：你好，请问有什么要帮忙的吗？</p>
<p>第二论问题：请帮我写一段 Python 爬虫抓取知乎回答的 demo。</p>
<p>第二轮回答：好的，下面是一段抓取知乎回答的 Python 示例。&hellip;.省略多行代码。</p>
<p>第三轮问题：帮我改成 Java 的。</p>
<p>这时候，我会将实际的 prompt 改成下面这样的。</p>
<blockquote>
<p>下面中括号部分是前两轮的问题和回答，只用作参考。[my question is:&ldquo;你好&rdquo;,your anwser is:&ldquo;你好，请问有什么要帮忙的吗？&quot;.my question is:&ldquo;请帮我写一段 Python 爬虫抓取知乎回答的 demo。&quot;,your anwser is:&ldquo;好的，下面是一段抓取知乎回答的 Python 示例。&hellip;.省略多行代码。&rdquo;.]</p>
<p>下面引号包含的这部分是真正的问题：&ldquo;帮我改成 Java 的。&rdquo;</p>
</blockquote>
<p>采用这种方式，几乎可以模拟上下文的操作，但是偶尔会出现错乱，这块儿还有优化空间，还会继续优化。</p>
<p>如果各位小伙伴使用过程中发现什么问题，或者有什么更好的建议，都可以加我好友直接跟我说。</p>
<p>欢迎捧场，赶紧用一用吧，觉得好用的话，可以推荐给身边的小伙伴也用一下。</p>
<p><img src="https://hexo.moonkite.cn/blog/877shots_so%20(1).png" alt=""></p>
]]></content:encoded></item><item><title>一个简单的 web 版 JVM 监控器</title><link>https://moonkite.cn/category/product/2-JVM-%E7%9B%91%E6%8E%A7/</link><pubDate>Fri, 02 Jun 2023 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/product/2-JVM-%E7%9B%91%E6%8E%A7/</guid><description>以 JMX 技术为基础，差不多实现了一个 web 版的 visualVM</description><content:encoded>&lt;p>以 JMX 技术为基础，差不多实现了一个 web 版的 visualVM，具备以下功能：&lt;/p>
&lt;p>支持连接本地 JVM 和 远程 JVM
展示所有 MBeans，并可查看属性及调用操作
仪表盘功能：
实时系统信息，系统 CPU 使用率、内存占用等
JVM 参数信息
实时 CPU 使用率曲线图、实时 Heap 、MetaSpace 使用量曲线图、实时类加载量曲线图、实时线程数曲线图
垃圾收集器及垃圾收集次数&lt;/p></content:encoded></item><item><title>这次没躲过去，阳了</title><link>https://moonkite.cn/category/notes/%E9%A6%96%E9%98%B3%E5%BF%AB%E5%A5%BD%E4%BA%86/</link><pubDate>Fri, 02 Jun 2023 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/notes/%E9%A6%96%E9%98%B3%E5%BF%AB%E5%A5%BD%E4%BA%86/</guid><description>2023 年 5 月 25 日，阳了</description><content:encoded><![CDATA[<p>上周四（2023 年 5 月 25 日）阳了，是首阳，去年幸运的躲过去了。今年就没这么幸运了，新冠只会迟到，但它不会不来。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20230603205055429.png" alt=""></p>
<p>最近这次疫情主要是查漏补缺，把去年漏掉的那波补上，顺带着让一些人二阳，甚至三阳。</p>
<p>之前公司里，算上我有3个去年没阳的，我是上周四阳的，另外一个是这周一阳的。</p>
<p>还剩最后一个一直没阳，这多少有点儿厉害了，据我们分析可能的原因有这么几个：</p>
<ol>
<li>和我们打的疫苗不一样，只有他打的是北京生物，我们打的都是科兴，而且他打的比较晚，可能是疫苗确实起作用了。</li>
<li>真正的无症状感染者，感染了但是没有感觉。</li>
<li>超级免疫体质，上天眷顾。（基本排除了）</li>
</ol>
<p>除了这个我愿称之为奇迹的存在，其他我听说的去年没阳过的，目前基本已经全军覆没了。终南山说预测 5月底4000万/周，6月底6500万/周，不是盖的。</p>
<p><img src="https://hexo.moonkite.cn/blog/12222.png" alt=""></p>
<h2 id="首阳历程">首阳历程</h2>
<p>有人说这病毒距离去年的又过去半年了，按照病毒传播的理论，这一次是不是比去年的毒株杀伤里要小一点了。</p>
<p>我感觉，并没有，至少在我这儿的痛苦程度，和去年听别人说的感受是一样的。</p>
<p><strong>上周四，第一天</strong></p>
<p>（周三）半夜感觉嗓子有点异物感，以为是白天喝水少了，早晨起来有点冷，以为发烧了，一量体温并没有，36度。路上肩膀有点疼，之前拉伤过，以为晚上压到了。其实病毒已经开始攻击我了，这病毒就像个放大器，你身体哪里有问题，它就给你把问题放大。</p>
<p>中午就开始没食欲了，吃了几口，然后开始腿有点酸疼，肩膀更疼了，还有屁股疼，这你受的了。</p>
<p>能感觉到有点烧了，立马回家了。</p>
<p>到家之后提问马上上来了，头开始疼，随着提问的升高，头疼的越来越厉害，就是那种头痛欲裂的感觉，毫不夸张，就是疼到没心疼刷手机。头疼的感觉盖过了身上的酸疼，其实身上也很疼。</p>
<p>一量体温，38.3，来了一颗布洛芬。接下来就是睡觉，睡眠质量很好。</p>
<p>不得不说，布洛芬真是神药，又止疼又退烧。</p>
<p><strong>上周五，第二天</strong></p>
<p>早晨精神状态良好，甚至还写了不少代码。轻微咳嗽，有点儿流鼻涕。</p>
<p>到了下午，体温又上来了，头不疼了，但是全身酸疼，尤其是后背和腿，疼的厉害。只能躺着。</p>
<p>一直忍到下午5点，一量体温，又是38.3，你说巧不巧。</p>
<p>冷的不行，直起鸡皮疙瘩。又来了一粒布洛芬，但是今天好像效果不明显，感觉体温一直没降下来，至少到夜里一两点都没降下来，一会儿热的出汗，一会儿冷的要命。</p>
<p>这是最难受的一天，睡不好觉，早晨起来一看，手上脚上都是小红点，就是毛细血管爆了的那种小红点。这就是妥妥的烧爆了。</p>
<p><strong>上周六，第三天</strong></p>
<p>第三天开始就不发烧了，咳嗽严重了一点，嗓子难受，后背还是有点疼。</p>
<p>就是那种连续加班好几天的感觉。</p>
<p><strong>上周日，第四天</strong></p>
<p>咳嗽严重，有鼻涕，嗓子疼，重感冒的那种状态。</p>
<p>还有就是胃有点难受，哪里薄弱它就攻击你哪里，我之前有过慢性胃炎，不过已经好长时间没发作了。这不，被这病毒精准的逮到了。</p>
<p><strong>周一，第五天</strong></p>
<p>仍然没去公司，主要是怕传染给同事。</p>
<p>还是重感冒的症状，不过身上几乎没有疼痛的感觉了。感觉马上就好了。</p>
<p><strong>周二到周五</strong></p>
<p>第6- 9天，现在嗓子虽然不疼了，但是总是干，半个小时不喝水就感觉干、痒，然后就咳嗽。</p>
<p>6、7天的时候，爬楼梯还有点累，头时不时懵懵的，不会影响智商吧。</p>
<p>这两天基本上体力恢复了，头也不懵了，就剩下咳嗽了。</p>
<p>我以为5、6天就能好呢，结果现在还是有点咳嗽，尤其到了下午。</p>
<p><strong>昨天</strong></p>
<p>昨天基本痊愈了，几乎不咳嗽了，嗓子也不疼了。</p>
<p>这周，公司里还有2个同事二阳了，认识的朋友也有几个二阳了。</p>
<p>但是大部分的二阳症状都比较轻，基本上都是轻微咳嗽+流鼻涕，还有一部分有低烧的症状。</p>
<p>这病毒绝对不是大号的感冒，这可比感冒难受多了。而且不是有传言说，世界纪录是8阳吗，因为8阳之后人就没了。</p>
<p>对健康的年轻人还好，但是对老年人，尤其是有基础疾病的老年人，每次疫情都是挑战，家里有老年人一定要做好防护措施，能不感染就不感染，至少在6月底前做好防护，少出门，少聚集，勤消毒。</p>
<p>到了6月底，感染的人数多了，也就能形成一定的免疫屏障了，那时候再出来活动，感染的几率会小一些。</p>
<p>我去年就是在感染高峰期的时候在家里没怎么出门，能网购的都网购，快递放在门口，拿快递先用酒精一通喷。当然，也可能只是幸运而已。</p>
<p>我跟朋友这么说的时候，有的朋友说我站着说话不腰疼。不是想在家里呆着就能在家里呆着的，要上班、要工作呀。</p>
<p>去年的时候还有政策，阳了可以居家办公，但是今年呢，新冠已经当做流感来对待了，好多公司要求能上班就上班，不能上班就请假。所以有很多人，即使阳了，哪怕发着烧，只能要坚持，还是会到公司上班的。</p>
<p>这就是生活呀！</p>
<p>你阳了吗，首阳还是二阳，坚持上班了吗？</p>
]]></content:encoded></item><item><title>做了一个 VSCode ChatGPT 插件</title><link>https://moonkite.cn/2023/05/24/%E5%81%9A%E4%BA%86%E4%B8%80%E4%B8%AA-VSCode-ChatGPT-%E6%8F%92%E4%BB%B6/</link><pubDate>Wed, 24 May 2023 12:56:23 +0800</pubDate><guid>https://moonkite.cn/2023/05/24/%E5%81%9A%E4%BA%86%E4%B8%80%E4%B8%AA-VSCode-ChatGPT-%E6%8F%92%E4%BB%B6/</guid><description>其实很早之前就想学学 VSCode 插件开发了，但是又不知道做什么，加上我这半吊子前端水平，迟迟没有动手。 最近 ChatGPT 火的一塌糊涂，我也一直在用，真的非常好用，</description><content:encoded><![CDATA[<p>其实很早之前就想学学 VSCode 插件开发了，但是又不知道做什么，加上我这半吊子前端水平，迟迟没有动手。</p>
<p>最近 ChatGPT 火的一塌糊涂，我也一直在用，真的非常好用，有些问题之前需要 Google 搜索，现在用 ChatGPT 基本上都能直接解决，效率提升了不少。</p>
<p>但是吧，浏览器和 IDE 来回切换又很麻烦，所以我灵机一动，那就开发个 ChatGPT 插件吧，即可以学习学习 VSCode 插件开发，又可以做一个方便的效率工具，岂不是一举两得，美哉美哉。</p>
<p>于是我就动手写了下面这个插件，叫做 <code>mini ChatGPT</code>，现在已经发布到 VSCode 插件市场了。</p>
<p>有条件的同学可以安装一下，试试效果如何。</p>
<p><strong>插件功能特点</strong></p>
<ul>
<li>界面简洁，没有多余的干扰；</li>
<li>像 ChatGPT 官网输出效果一致，打字效果实时输出；</li>
<li>支持两轮上下文（太多了浪费 tokens），大致等于支持上下文；</li>
<li>代码美化+格式化，并且可以一键复制，直接粘贴到 vscode 中；</li>
</ul>
<p><img src="https://hexo.moonkite.cn/blog/image-20230509181750193.png" alt=""></p>
<h2 id="插件安装">插件安装</h2>
<p><strong>当然了，这是需要科学上网的。</strong></p>
<p>你可以直接在 VSCode 的商店直接搜索 <code>mini ChatGPT</code>安装。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20230509183628014.png" alt=""></p>
<p>也可以到应用市场上安装。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20230509183750997.png" alt=""></p>
<p>插件地址：https://marketplace.visualstudio.com/items?itemName=fengzheng.code-chatgpt-assistant</p>
<h2 id="插件使用">插件使用</h2>
<ol>
<li>点击查看-&gt;命令面板，或者使用快捷键（MacOS: Shift + Command + P，Windows:Shift + Control + P</li>
<li>输入 <code>Chat</code> 并回车。
<img src="https://hexo.moonkite.cn/blog/20230509111926.png" alt=""></li>
<li>如果是首次使用，会弹出提示输入框，在此输入 ChatGPT 的 API。使用的就是原滋原味的 ChatGPT API 接口，官网上都写的很清楚，所以需要使用插件的小伙伴提供自己账号的 API key。下面有介绍如何获取ChatGPT API key。
<img src="https://hexo.moonkite.cn/blog/20230509112123.png" alt=""></li>
<li>之后就可以使用啦
<img src="https://hexo.moonkite.cn/blog/20230509112311.png" alt=""></li>
<li>如果之后想更换 ChatGPT 的 API key，在命令面板中输入 <code>ChatGPT API</code> 即可。</li>
</ol>
<p><strong>使用建议</strong></p>
<p>此插件只有一个 webview 实现，打开之后独占一个 tab，可以设置向左或向右拆分，然后在左侧使用此插件向 ChatGPT 提问，右侧是代码文件，这样就不用来回切换了，而且可以将代码片段一键复制，然后直接运行。</p>
<p><img src="https://hexo.moonkite.cn/blog/chatgpt.gif" alt=""></p>
<p><strong>获取 ChatGPT API key</strong></p>
<ol>
<li>
<p>先准备好科学上网，不要用亚洲节点。</p>
</li>
<li>
<p>之后到 <a href="https://platform.openai.com/">OpenAI 官网</a>注册账号。</p>
</li>
<li>
<p>到<a href="https://platform.openai.com/account/api-keys">个人中心</a> 创建一个 API key。</p>
</li>
</ol>
<p><img src="https://hexo.moonkite.cn/blog/20230509133206.png" alt=""></p>
<h2 id="开发历程">开发历程</h2>
<p>作为一个后端开发，我的前端水平是非常一般的，所以代码中有瑕疵的地方还请见谅。对了，代码已经放到 GitHub  上了。</p>
<p>仓库地址：https://github.com/huzhicheng/vscode-ChatGPT</p>
<p>VSCode 插件开发，官方建议是用 TypeScript 开发，所以项目完全采用了 TS 开发。由于功能比较简单，没有那么多复杂的设置，由于边学边做，太复杂的也没考虑。整个插件的核心其实就是一个 <code>webview</code>，在webview中实现界面布局和样式，难点就在于webview与插件本身来回的数据传递，但也都是常规用法。</p>
<p>整个写代码的过程其实也就几个小时，当然过程中的遇到的一些问题我都是跟 ChatGPT 提问的，包括样式都是直接描述需求，ChatGPT 给我一个大致的框架，我再微调一下就可以了。</p>
<p>所以这样看下来，其实是我和 ChatGPT 合作开发的。</p>
<p>后来发布到应用商店，写 readme 介绍和使用说明花了一些时间。</p>
<h2 id="问题和建议">问题和建议</h2>
<p>目前的版本功能比较简单，没有 ChatGPT 官方的聊天记录列表功能，如果真的有人用的话，后期考虑加上。</p>
<p>由于ChatGPT 官方并未提供上下文的 API 支持，所以只能采用其他方式模仿上下文能力，目前的做法是记录前两轮提问和回答，然后在下次提问的时候，将前两轮的提问和回答告诉 ChatGPT ，并且明确告诉 ChatGPT，例如下面这样。</p>
<p>第一轮问题：你好。</p>
<p>第一轮回答：你好，请问有什么要帮忙的吗？</p>
<p>第二论问题：请帮我写一段 Python 爬虫抓取知乎回答的 demo。</p>
<p>第二轮回答：好的，下面是一段抓取知乎回答的 Python 示例。&hellip;.省略多行代码。</p>
<p>第三轮问题：帮我改成 Java 的。</p>
<p>这时候，我会将实际的 prompt 改成下面这样的。</p>
<blockquote>
<p>下面中括号部分是前两轮的问题和回答，只用作参考。[my question is:&ldquo;你好&rdquo;,your anwser is:&ldquo;你好，请问有什么要帮忙的吗？&quot;.my question is:&ldquo;请帮我写一段 Python 爬虫抓取知乎回答的 demo。&quot;,your anwser is:&ldquo;好的，下面是一段抓取知乎回答的 Python 示例。&hellip;.省略多行代码。&rdquo;.]</p>
<p>下面引号包含的这部分是真正的问题：&ldquo;帮我改成 Java 的。&rdquo;</p>
</blockquote>
<p>采用这种方式，几乎可以模拟上下文的操作，但是偶尔会出现错乱，这块儿还有优化空间，还会继续优化。</p>
<p>如果各位小伙伴使用过程中发现什么问题，或者有什么更好的建议，都可以加我好友直接跟我说。</p>
<p>欢迎捧场，赶紧用一用吧，觉得好用的话，可以推荐给身边的小伙伴也用一下。</p>
<p><img src="https://hexo.moonkite.cn/blog/877shots_so%20(1).png" alt=""></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nn">kite.lab.spring.config</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Hacker
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @author fengzheng
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Hacker</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">age</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">language</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">isHide</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getAge</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">age</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setAge</span><span class="o">(</span><span class="n">String</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getLanguage</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">language</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLanguage</span><span class="o">(</span><span class="n">String</span> <span class="n">language</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">language</span> <span class="o">=</span> <span class="n">language</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isHide</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">isHide</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setHide</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">hide</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">isHide</span> <span class="o">=</span> <span class="n">hide</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">StringBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">builder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">&#34;======================\n&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">builder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&#34;hacker&#39;s name is :%s \n&#34;</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">getName</span><span class="o">()));</span>
</span></span><span class="line"><span class="cl">        <span class="n">builder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&#34;hacker&#39;s age is :%s \n&#34;</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">getAge</span><span class="o">()));</span>
</span></span><span class="line"><span class="cl">        <span class="n">builder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&#34;hacker&#39;s language is :%s \n&#34;</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">getLanguage</span><span class="o">()));</span>
</span></span><span class="line"><span class="cl">        <span class="n">builder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&#34;hacker&#39;s status is :%s \n&#34;</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">isHide</span><span class="o">()));</span>
</span></span><span class="line"><span class="cl">        <span class="n">builder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">&#34;======================\n&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">builder</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div>]]></content:encoded></item><item><title>用了这两款插件，同事再也不说我代码写的烂了</title><link>https://moonkite.cn/category/java/%E7%94%A8%E4%BA%86%E8%BF%99%E4%B8%A4%E6%AC%BE%E6%8F%92%E4%BB%B6%E5%90%8C%E4%BA%8B%E5%86%8D%E4%B9%9F%E4%B8%8D%E8%AF%B4%E6%88%91%E4%BB%A3%E7%A0%81%E5%86%99%E7%9A%84%E7%83%82%E4%BA%86/</link><pubDate>Fri, 17 Mar 2023 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/java/%E7%94%A8%E4%BA%86%E8%BF%99%E4%B8%A4%E6%AC%BE%E6%8F%92%E4%BB%B6%E5%90%8C%E4%BA%8B%E5%86%8D%E4%B9%9F%E4%B8%8D%E8%AF%B4%E6%88%91%E4%BB%A3%E7%A0%81%E5%86%99%E7%9A%84%E7%83%82%E4%BA%86/</guid><description>同事：你的代码写的不行啊，不够规范啊。 我：我写的代码怎么可能不规范，不要胡说。 于是同事打开我的 IDEA ，安装了一个插件，然后执行了一下，规范不规范</description><content:encoded><![CDATA[<p>同事：你的代码写的不行啊，不够规范啊。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ec392c83a4f48209391d2a30483f96c~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>我：我写的代码怎么可能不规范，不要胡说。</p>
<p>于是同事打开我的 IDEA ，安装了一个插件，然后执行了一下，规范不规范，看报告吧。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e44e2b26740c4bc88dc6f09cd49dd239~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>这可怎么是好，这玩意竟然给我挑出来这么多问题，到底靠谱不。</p>
<p>同事潇洒的走掉了，只留下我在座位上盯着屏幕惊慌失措。我仔细的查看了这个报告的每一项，越看越觉得这插件指出的问题有道理，果然是我大意了，竟然还给我挑出一个 bug 来。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ed15609b6094e4f823357bdd5aefa11~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>这是什么插件，review 代码无敌了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2079621178645c2872d1ed96e3bb8a0~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>这个插件就是 SonarLint，官网的 Slogan 是 <code>clean code begins in your IDE with {SonarLint}</code>。</p>
<p>作为一个程序员，我们当然希望自己写的代码无懈可击了，但是由于种种原因，有一些问题甚至bug都无法避免，尤其是刚接触开发不久的同学，也有很多有着多年开发经验的程序员同样会有一些不好的代码习惯。</p>
<p>代码质量和代码规范首先肯定是靠程序员自身的水平和素养决定的，但是提高水平的是需要方法的，方法就有很多了，比如参考大厂的规范和代码、比如有大佬带着，剩下的就靠平时的一点点积累了，而一些好用的插件能够时时刻刻提醒我们什么是好的代码规范，什么是好的代码。</p>
<p>SonarLint 就是这样一款好用的插件，它可以实时帮我们 <code>review</code>代码，甚至可以发现代码中潜在的问题并提供解决方案。</p>
<p>SonarLint 使用静态代码分析技术来检测代码中的常见错误和漏洞。例如，它可以检测空指针引用、类型转换错误、重复代码和逻辑错误等。这些都是常见的问题，但是有时候很难发现。使用 SonarLint 插件，可以在编写代码的同时发现这些问题，并及时纠正它们，这有助于避免这些问题影响应用程序的稳定性。</p>
<p>比如下面这段代码没有结束循环的条件设置，SonarLint 就给出提示了，有强迫症的能受的了这红下划线在这儿？</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/070ac5dbb39c4bea9221a74cc20da2a6~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>SonarLint 插件可以帮助我提高代码的可读性。代码应该易于阅读和理解，这有助于其他开发人员更轻松地维护和修改代码。 SonarLint 插件可以检测代码中的代码坏味道，例如不必要的注释、过长的函数和变量名不具有描述性等等。通过使用 SonarLint 插件，可以更好地了解如何编写清晰、简洁和易于理解的代码。</p>
<p>例如下面这个名称为 <code>hello_world</code>的静态 <code>final</code>变量，SonarLint 给出了两项建议。</p>
<ol>
<li>因为变量没有被使用过，建议移除；</li>
<li>静态不可变变量名称不符合规范；</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a32cebfd401a4e5cb0daf7cf004eb87c~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>SonarLint 插件可以帮助我遵循最佳实践和标准。编写符合标准和最佳实践的代码可以确保应用程序的质量和可靠性。 SonarLint 插件可以检测代码中的违反规则的地方，例如不安全的类型转换、未使用的变量和方法、不正确的异常处理等等。通过使用 SonarLint 插件，可以学习如何编写符合最佳实践和标准的代码，并使代码更加健壮和可靠。</p>
<p>例如下面的异常抛出方式，直接抛出了 <code>Exception</code>，然后 SonarLint 建议不要使用 <code>Exception</code>，而是自定义一个异常，自定义的异常可能让人直观的看出这个异常是干什么的，而不是 <code>Exception</code>基本类型导出传递。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de65676ec99e40c3bcac94c16b0fadb8~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="安装-sonarlint">安装 SonarLint</h2>
<p>可以直接打开 IDEA 设置 -&gt; <code>Plugins</code>，在 <code>MarketPlace</code>中搜索<code>SonarLint</code>，直接安装就可以。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57fe0882143c43d6bd8ed539d9e43f6d~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>还可以直接在官网下载，打开页面<code>https://www.sonarsource.com/products/sonarlint/</code>，在页面中可以看到多种语言、多种开发工具的下载图标，点击下方的 <code>EXPLORE</code>即可到下载页面去下载了。虽然我们只是在 IDEA 中使用，但是它不管支持 Java 、不只支持 IDEA ，还支持 Python、PHP等众多语言，以及 Visual Studio 、VS Code 等众多 IDE。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efe12f47ffbf4a63b5a8975ad1d61baa~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="在-idea-中使用">在 IDEA 中使用</h2>
<p>SonarLint 插件安装好之后，默认就开启了实时分析的功能，就跟智能提示的功能一样，随着你噼里啪啦的敲键盘，<code>SonarLint</code>插件就默默的进行分析，一旦发现问题就会以红框、红波浪线、黄波浪线的方式提示。</p>
<p>当然你也可以在某一文件中点击右键，也可在项目根目录点击右键，在弹出菜单中点击<code>Analyze with SonarLint</code>，对当前文件或整个项目进行分析。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/155fe55f0f2f43928fcd0053fe420a8b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>分析结束后，会生成分析报告。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ef39fa8bab84ad6a82a4d72fac1f78c~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>左侧是对各个文件的分析结果，右侧是对这个问题的建议和修改示例。</p>
<p>SonarLint 对问题分成了三种类型</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bug</td>
<td>代码中的 bug，影响程序运行</td>
</tr>
<tr>
<td>Vulnerability</td>
<td>漏洞，可能被作为攻击入口</td>
</tr>
<tr>
<td>Code smell</td>
<td>代码意味，可能影响代码可维护性</td>
</tr>
</tbody>
</table>
<p>问题按照严重程度分为5类</p>
<table>
<thead>
<tr>
<th>严重性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>BLOCKER</td>
<td>已经影响程序正常运行了，不改不行</td>
</tr>
<tr>
<td>CRITICAL</td>
<td>可能会影响程序运行，可能威胁程序安全，一般也是不改不行</td>
</tr>
<tr>
<td>MAJOR</td>
<td>代码质量问题，但是比较严重</td>
</tr>
<tr>
<td>MINOR</td>
<td>同样是代码质量问题，但是严重程度较低</td>
</tr>
<tr>
<td>INFO</td>
<td>一些友好的建议</td>
</tr>
</tbody>
</table>
<h2 id="sonarqube">SonarQube</h2>
<p>SonarLint 是在 IDE 层面进行分析的插件，另外还可以使用 <code>SonarQube</code>功能，它以一个 web 的形式展现，可以为整个开发团队的项目提供一个web可视化的效果。并且可以和 CI\CD 等部署工具集成，在发版前提供代码分析。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23a71ec0e8034ed5a9b121dc759123ed~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p><code>SonarQube</code>是一个 Java 项目，你可以在官网下载项目本地启动，也可以以 docker 的方式启动。之后可以在 IDEA 中配置全局 <code>SonarQube</code>配置。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfb122628ca0458686865c24b057ddfb~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>也可以在 SonarQube web 中单独配置一个项目，创建好项目后，直接将 mvn 命令在待分析的项目中执行，即可生成对应项目的分析报告，然后在  SonarQube web 中查看。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cf6c2de8d4e4bc1869577c13e6f14a7~tplv-k3u1fbpfcp-zoom-1.image" alt="5"></p>
<p>对于绝大多数开发者和开发团队来说，SonarQube 其实是没有必要的，只要我们每个人都解决了 IDE 中 SonarLint 给出的建议，当然最终的代码质量就是符合标准的。</p>
<h2 id="阿里-java-规约插件">阿里 Java 规约插件</h2>
<p>每一个开发团队都有团队内部的代码规范，比如变量命名、注释格式、以及各种类库的使用方式等等。阿里一直在更新 Java 版的阿里巴巴开发者手册，有什么泰山版、终极版，想必各位都听过吧，里面的规约如果开发者都能遵守，那别人恐怕再没办法 diss 你的代码不规范了。</p>
<p>对应这个开发手册的语言层面的规范，阿里也出了一款 IDEA 插件，叫做 Alibaba Java Coding Guidelines，可以在插件商店直接下载。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79ee2e16a1d04bd4b23f16fdfad9e7a6~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>比如前面说的那个 <code>hello_world</code>变量名，插件直接提示「修正为以下划线分隔的大写模式」。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/485b04e0a5e54ec7b165c0a052e8b305~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>再比如一些注释上的提示，不建议使用行尾注释。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90eddf34e86e44fcae92a1a036e56eee~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20230314165107639"></p>
<p>还有，比如对线程池的使用，有根据规范建议的内容，建议自己定义核心线程数和最大线程数等参数，不建议使用 <code>Excutors</code>工具类。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6953c39ed30c40eab564d3d5d8040ae4~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>有了这俩插件，看谁还能说我代码写的不规范了。</p>
]]></content:encoded></item><item><title>0. 重学了计算机网络，略有小成，经验全部分享出来</title><link>https://moonkite.cn/category/network/%E9%87%8D%E5%AD%A6%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%95%A5%E6%9C%89%E5%B0%8F%E6%88%90%E7%BB%8F%E9%AA%8C%E5%85%A8%E9%83%A8%E5%88%86%E4%BA%AB%E5%87%BA%E6%9D%A5/</link><pubDate>Tue, 28 Feb 2023 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/network/%E9%87%8D%E5%AD%A6%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%95%A5%E6%9C%89%E5%B0%8F%E6%88%90%E7%BB%8F%E9%AA%8C%E5%85%A8%E9%83%A8%E5%88%86%E4%BA%AB%E5%87%BA%E6%9D%A5/</guid><description>大家好，我是风筝。 轻解计算机网络已有高清 PDF 版本可以离线阅读了，全册 65 页，如果有需要离线版的高清 PDF 可以直接下载。 重学计算机网络已经有一段时间了</description><content:encoded><![CDATA[<p><strong>大家好，我是风筝。</strong></p>
<p>轻解计算机网络已有高清 PDF 版本可以离线阅读了，全册 65 页，如果有需要离线版的高清 PDF 可以<a href="https://pan.baidu.com/s/10LH_5afGftayMo8Q1Io_gA?pwd=f8hp">直接下载</a>。</p>
<p>重学计算机网络已经有一段时间了，终于在离开大学多年后又重新拾起了一部分，时至今日已略有小成，并且写了一系列的文章了，会慢慢 发出来。</p>
<p>我反正在学习的过程中是画了好多张图，这些图会放到后续的文章中，有兴趣一起学习的同学记得关注加星标呀，这样就能第一时间接到文章推送了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d1d6175a31b4c6b9fad91edca321d56~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>上大学的时候就想好好学习网络，梦想着以后成为一名网管。后来发现计算机网络还真是不太好学，非常非常抽象，发现有很多概念好像怎么学都学不明白。这才知道，原来更适合我的网吧管理员，而不是网络管理员。而写代码就不一样了，没那么抽象，而且写出来东西马上能看到成果，写一个方法一运行，马上能输出结果；写一个网页、一段样式，马上就能看到界面的变化。人的大脑最喜欢这种快速反馈了，于是觉得写代码比学网络有意思，这才走上了程序员这条路。</p>
<p>后来工作了，相信大家和我有同感，虽然写的是代码，但是处处离不开网络：</p>
<ul>
<li>普通接口用的是 HTTP\HTTPS，HTTP 处于整个网络的最顶层应用层；</li>
<li>有一些 RPC 使用的非 HTTP 协议，例如 Dubbo 的 Hessian 直接包装的 TCP 协议；</li>
<li>还有一些场景要直接使用 TCP，例如支持前端的 websocket；</li>
<li>非常流行的高性能网络框架 Netty ；</li>
<li>使用 Dokcer 容器做开发测试的时候；</li>
<li>甚至于使用VmVare 虚拟机的时候，也要了解桥接模式、NAT、仅主机模式的区别；</li>
</ul>
<p>就算对网络和底层完全不了解，也可以正常写代码，但是，当我们有一天发不满足于只写增删改查，或者在一些外部力量的驱动下，如果不理解网络，那必将寸步难行。</p>
<p>只写增删改查做咸鱼有什么区别，我们是那种甘心做咸鱼的人吗？对于想在技术上更上一层，想要做架构师的同学，网络是我们必须拿下的阵地。</p>
<p>在做了一段时间的咸鱼之后，我还是决定要翻一下身。否则网络这东西总会像一团迷雾一样，时不时飘来挡住视线，一直像一块面纱一样，遮住了系统真正的面容。</p>
<h2 id="为什么要学习网络知识">为什么要学习网络知识</h2>
<h3 id="可以出去吹牛啊">可以出去吹牛啊</h3>
<p>当碰到一个网络问题，别人都解决不了，你解决了，你说骄傲不，你说自豪不。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/040b644cb4af413ebc75e60b14cbec19~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>当然，就是说说而已，做人还是要低调，内心就算翻出了花儿，表面上也要淡定的表示这是基本操作。</p>
<h3 id="加深对应用框架和架构的理解">加深对应用框架和架构的理解</h3>
<p>现在还能找出哪个系统、哪个应用不依赖于网络吗，好像还真的不太好找。</p>
<p>举两个例子：</p>
<h4 id="netty-框架">Netty 框架</h4>
<p>Netty 可以说是当前最火的网络编程框架，如果你们的项目需要高性能、高可靠的服务端和客户端交互，最好的选择就是 Netty。比如即时沟通功能、比如游戏服务器、比如websocket的服务器端实现。</p>
<p>Netty 是基于TCP\UDP 实现的，其中有很大部分都是对这两个协议的封装，在理解网络（尤其是TCP）和不理解网络的情况下学习 Netty 是两种完全不同的体验，前者事半功倍，后者事倍功半。</p>
<p>而且现在很多框架都集成了 Netty，比如 Dubbo RPC、RocketMQ、Hadoop等，连 Spring Boot 也已经内置了 Netty 模式。更好的理解 Netty ，才能更好的理解这些框架，怎么才能更好的理解 Netty 呢，当然是要对网络有很好的理解啦。</p>
<h4 id="微服务框架">微服务框架</h4>
<p>微服务是由多台服务器组成的，这么多的服务器要联动起来，和稳定的网络结构是分不开的。一个复杂的微服务架构，有网关、服务、CDN、还有各种旁路的中间件。网关还分网络网关和应用网关，网关就涉及到负载均衡，负载均衡有4层负载均衡，还有7层负载均衡，各种各样的概念，哪一个都离不开网络。</p>
<p>有可能还用了 docker、k8s，这就更复杂了，容器内部网络、集群网络、外部网络，不了解这些怎么能更好的理解架构。</p>
<h3 id="优化系统">优化系统</h3>
<p>也许某一天你当上了架构师，当系统出现瓶颈的时候，需要做优化了。如果你不懂网络，那只能从数据库、中间件、代码层面优化， 缺失了网络层面的优化，而网络优化应该是成本最低的部分。</p>
<h3 id="也许能解决一些疑难杂症">也许能解决一些疑难杂症</h3>
<p>有时候，很多问题都是由网络问题引起的。</p>
<p>最简单的相信大家都能处理，比如最常说的 <code>ping</code>一下、<code>telnet</code>一下。</p>
<p>就连阿里云这么大的平台也经常发生网络问题。很早之前，项目中有一些集成了微信服务号的功能，服务部署在阿里云，就出现过异常，现象就是无法正常调用产生临时二维码的接口。通过排查判断应该是阿里云服务器的网络出现了问题，于是立刻提交工单，经过核实，确认是某些阿里云服务器的网络出现了问题，据客服回应是网络抖动，但也不保证当时阿里云在进行某些配置更新，谁知道呢。</p>
<p>除了上面说的简单、明显的网络问题外，还有一些问题是隐藏在背后的，比如一些第三方框架或中间件，在某些情况下会出现非常莫名其妙的问题。我承认找到并解决这些问题确实很困难，必须要动用一些服务端工具、网络工具辅助排查，即使这样，也不一定能顺利的发现问题所在。</p>
<p>没关系，至少理解了网络，就多一条路，也许这条路就能帮我们找到问题呢。但如果你不了解网络，不要说解决问题了，连问题产生的原因都不会知道，连如何排查问题都不知道。</p>
<h2 id="为什么看完书转头就忘">为什么看完书转头就忘</h2>
<p>不是我不想学啊，看完了转头就忘了。这不就是说的我吗？不瞒你说，我看了好几遍《TCP-IP协议详解》卷1了，到现在还只是掌握了一个大概，理论性的内容最不容易掌握了，因为很难从中得到乐趣，大脑不容易给出积极的反馈。但是有一个好处不得不说，就是助眠，看着看着就困了。</p>
<h3 id="多看">多看</h3>
<p>上学的时候老师经常说的就是多看多读，不得不说，这个方法确实好用，除非你有过目不忘的天才本领。不要妄想一口吃个胖子，普通的人大脑没办法一下接受那么多陌生的东西。不知道各位有没有过这样的经历，之前学过的一些知识感觉自己没学好、没学懂，学起来很吃力，最终可能糊弄过去或者直接放弃了。而过了一段时间又拿起来学了，发现之前一些没理解的部分突然理解了。</p>
<p>作为一个普通咸鱼，经常有些概念第一次、第二次都不太理解，比如学习 TCP 的时候，前面不理解，导致后面更不容易理解，然后就不想看了，这时候强迫自己继续看下去，当然了，最终的结果可能仍然是不理解，一次、两次都是这样。过些天，重新看的时候经常会有恍然大悟的感觉，奥，原来是这么回事。</p>
<h3 id="画出来写出来">画出来、写出来</h3>
<p><strong>画出来</strong>，可以帮助我们更直观的理解。大脑不容易接收文字，但是容易接收可视化的东西，为什么短视频比公众号更受欢迎，因为视频通过眼睛可以更直观的传递给大脑，而公众号上的文字要经过大脑的转化，转化的过程大脑就要工作，要工作就累啊。</p>
<p>比如我们学习网络模型的时候，有时候说7层，有时候说4层，因为4层是将7层中的某些层合并了，有一些网络协议工作在应用层、有一些工作在传输层。如果纯靠文字，那简直太抽象了，但是要是通过图形的方式展示出来，一目了然，可以通过下面的图感受一下。一下就知道，7层和4层的区别。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa9fb4ae70d745ca8ec5e8f595956cf3~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p><strong>写出来</strong>，可以检验我们自己是否真的理解了，大多数时候我们以为自己理解了，但是一旦要讲给别人的时候，发现支支吾吾，有些地方模棱两可。</p>
<p>相信各位写过博客的同学都特别有这种感觉，真正掌握的知识点可以很快的写成文章出来，而那些其实没掌握清楚的知识点，可能一篇文章写出来要用好几天。为什么呢？写着写着发现一个细节说不清楚，如果不想糊弄，就要找相关的书籍、文章，这个过程仍然是学习的过程。</p>
<p>到最后，能把一个概念通过文字的形式讲清楚了，说明自己至少掌握了大部分，也不敢保证100%掌握。</p>
<h3 id="要实践啊">要实践啊</h3>
<p>纸上谈兵最可怕，尤其是我们程序员这个行业。空谈误自己啊，同志们。写代码就不用说了，不可能只看不实践对吧，那样的话早被公司开除了。</p>
<p>网络这东西都是概念性、抽象的，怎么实践啊。总不能掐个水晶头、扯根网线吧。倒也不是不可以，但是也没必要，毕竟我们不是真的要去网吧当网管的。</p>
<p>可以使用一些网络工具可视化的观察一下网络上的数据包，比如用 WireShark 看一下 ARP协议、IP协议、TCP 协议、HTTP协议的数据格式是怎么样的，客户端和服务端的交互过程是怎样的。</p>
<p>还可以用一些网络命令试验一下，比如 ping 、telnet、route 等等。</p>
<p>最后可以回归老本行，写一写关于 Socket 的服务端和客户端的交互程序，修改一下各个参数看一下有什么变化。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf0a02b6376c4e1aa7bdfec935115867~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="我是怎么学的呢">我是怎么学的呢</h2>
<p>通过一段时间的不懈努力，我终于小有所成，从下面几个方向上梳理出了学习网络的一些脉络。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b24bc201dfd64f4f916a3fba4b996324~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>1、首先要从宏观视角大致了解一下网络到底是怎么样的，重点是网络分层模型、传输过程。抛开网络不说，接触任何一个新的知识都要先从宏观上下手。比如学习一个第三方框架，要先看介绍和架构说明，知道这个框架是干什么用的，工作原理是什么，架构设计是如何的。</p>
<p>2、然后就是理解各个层的主要协议了，主要就是协议的作用和协议格式，以及每种协议格子的功能特性。</p>
<p>3、一个数据包从发送端到目的端要经过纷繁复杂的网络结构，经过各种中间设备。从路由表、转发表和 ARP 表这三张表，可以了解数据包传输的过程。</p>
<p>4、最后是 <code>Ping</code>、<code>Route</code>命令的工作原理。遇到网络问题，我们首先想到的是 <code>ping 一下</code>，ping 的原理是什么呢？其实就是对特定的网络协议特性的巧妙利用，也很好玩。</p>
]]></content:encoded></item><item><title>1. 宏观上理解网络模型-在直升飞机上看网络</title><link>https://moonkite.cn/category/network/%E5%AE%8F%E8%A7%82%E4%B8%8A%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B-%E5%9C%A8%E7%9B%B4%E5%8D%87%E9%A3%9E%E6%9C%BA%E4%B8%8A%E7%9C%8B%E7%BD%91%E7%BB%9C/</link><pubDate>Tue, 28 Feb 2023 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/network/%E5%AE%8F%E8%A7%82%E4%B8%8A%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B-%E5%9C%A8%E7%9B%B4%E5%8D%87%E9%A3%9E%E6%9C%BA%E4%B8%8A%E7%9C%8B%E7%BD%91%E7%BB%9C/</guid><description>轻解计算机网络已有高清 PDF 版本可以离线阅读了，全册 65 页，如果有需要离线版的高清 PDF 可以直接下载。 今天是轻解计算机网络系列第一解，从宏观上了解网络</description><content:encoded><![CDATA[<p>轻解计算机网络已有高清 PDF 版本可以离线阅读了，全册 65 页，如果有需要离线版的高清 PDF 可以<a href="https://pan.baidu.com/s/10LH_5afGftayMo8Q1Io_gA?pwd=f8hp">直接下载</a>。</p>
<p>今天是轻解计算机网络系列第一解，从宏观上了解网络。主要介绍网络分成模型、基本传输过程。</p>
<p>学习任何一种新技术都应该是这样的顺序，先从宏观上了解这门技术的基本原理和作用。这就好像生物学家研究一种生物，不能上来就解刨吧，一定是从整体上观察了这种生物的体貌和形态。这里的宏观就像是一具动物骨骼模型、神经模型、肌肉模型，一直摆在那里，到最后装进科学家的脑袋里。</p>
<p>学技术切忌直接扣到一个细节里，扣细节，既可能是一丝不苟的工匠精神的提现，也可能直接被魔鬼代入深渊。我们是坐在天上的直升飞机找路比较容易，还是一头钻进一个胡同儿里比较容易呢。</p>
<p>今天要讲的网络模型，就像是生物学上的整体动物模型。</p>
<h2 id="分层网络模型">分层网络模型</h2>
<p>为了让全世界的计算机有效的互联起来，就要制定标准，分层模型就是这种标准的定义，有了这种标准，全世界的软硬件开发者才能开发出通用的程序来，要不然就像现在的手机充电口，苹果就是要用它独特的雷电接口，我要是再有一部安卓手机，就要有两条充电线。</p>
<p>有两种网络模型，一种是 OSI 7层模型，还有一种是 TCP/IP 模型，前者是一种概念话的模型，后者是事实上的标准。事实标准也就是当今网络世界里普遍使用的模型。</p>
<h3 id="osi-7层模型">OSI 7层模型</h3>
<p>国际标准化组织提出了一种概念化的网络模型，<strong>开放式系统互联模型</strong>（Open System Interconnection Model），简称 OSI 模型。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3276fdf3ed624a99becf83370866df80~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>自上而下依次为应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。</p>
<p>每一层都有一种或多种协议，这些协议都有标准的 RFC 文档，可以到https://www.rfc-editor.org/retrieve/ 这里查看各个协议的最原始说明。</p>
<h4 id="应用层">应用层</h4>
<p>应用层提供为应用软件而设计的接口，以设置与另一应用软件之间的通信。例如：HTTP、HTTPS、FTP、Telnet、SSH、SMTP、POP3等。</p>
<h4 id="表示层">表示层</h4>
<p>表示层把数据转换为能与接收者的系统格式兼容并适合传输的格式。</p>
<h4 id="会话层">会话层</h4>
<p>会话层负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接。</p>
<h4 id="传输层">传输层</h4>
<p>传输层把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:传输控制协议（TCP）等。</p>
<h4 id="网络层">网络层</h4>
<p>网络层决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组。网络表头包含了网络资料。例如:互联网协议（IP）等。</p>
<h4 id="数据链路层">数据链路层</h4>
<p>数据链路层负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成信息框。数据链表头（DLH）是包含了物理地址和错误侦测及改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串。例如以太网、无线局域网（Wi-Fi）和通用分组无线服务（GPRS）等。</p>
<p>分为两个子层：逻辑链路控制（logical link control，LLC）子层和介质访问控制（Media access control，MAC）子层。</p>
<h4 id="物理层">物理层</h4>
<p>物理层在局部局域网上传送数据帧，它负责管理电脑通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡等。</p>
<p>OSI 模型是国际标准模型，是指导互联网模型的概念标准。而在实际的设计实现过程中，最后形成了 TCP/IP 四层模型结构。我们在平时的一些书籍、文章中最常看到的也是 4 层模型，而非7 层模型。</p>
<h3 id="tcpip-4层模型">TCP/IP 4层模型</h3>
<p>TCP/IP 模型实际上并不单单指 TCP 和 IP，实际上这一个协议簇，还包含了其他的一些协议，比如 UDP、ICMP、IGMP 等。</p>
<p>TCP/IP 模型是事实上的标准模型，在 7 层模型的基础上将最上面三层的应用层、表示层、会话层统一为应用层，将数据链路层和物理层统一为链路层或者叫网络接口层。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b95d2e58374840a496565d6b056ca21f~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>实际应用中还是以 4 层模型为准，毕竟这才是事实上的标准。还有一种 5 层模型的说法，实际上就是把 7 层中的应用层、表示层、会话层合并为应用层，其他层保持不变。</p>
<h4 id="应用层-1">应用层</h4>
<p>将7层模型中最上层的应用层、表示层、会话层合并。</p>
<p>应用层主要运行我们平时经常使用的一些应用，比如 FTP、SSH、SMTP、HTTP、Telnet，也是我们开发过程中经常会打交道的，比如 HTTP，HTTP 在传输层仍然使用的是 TCP 协议，但是将 TCP 的细节做了封装。</p>
<h4 id="传输层-1">传输层</h4>
<p>传输层主要就是 TCP 和 UDP 这两个协议，负责将应用层的用户数据传输到目的端。</p>
<p>TCP 是有状态高可靠的的传输协议，有三次握手和重传机制最大程度上保证数据能够顺利的到达目的端。</p>
<p>UDP 协议是无状态的高性能的协议，因为它不保证数据能够顺利的到达目的端，所以不用三次握手建立连接，传一次，数据到不到就不管了。</p>
<p>其实从传输层开始，往下每一层都要负责将数据传输到目的端的一部分工作，只不过下面两层根据其特性和主要作用又分为了网络层和链路层。</p>
<h4 id="网络层-1">网络层</h4>
<p>网络层最主要的协议就是 IP 协议，负责将上一层「传输层」过来的 TCP 包或 UDP 包封装成 IP 数据报。通过 IP 协议，根据 IP 地址可以定位到一个网络主机。</p>
<p>除了 IP 协议外，ICMP 协议、IGMP 协议也工作在网络层。</p>
<p>ARP 和 RARP 协议也认为工作在网络层。</p>
<h3 id="链路层">链路层</h3>
<p>将 7 层模型中的最底两层数据链路层和物理层合并为链路层。</p>
<p>链路层也叫做网络接口层，它由多种网络接口标准和对应的驱动程序组成。一般我们说的数据链路层都是以太网链路层。</p>
<h2 id="数据发送和接收过程">数据发送和接收过程</h2>
<h3 id="数据包放封装和解封装过程">数据包放封装和解封装过程</h3>
<p>TCP/IP 模型每个层都有各自的功能和分工，当有用户数据想要发送给另一台设备的时候，数据自上而下，从应用层向链路层传递有一个复杂的过程。</p>
<p>以 Telnet 为例，Telnet 在传输层是使用 TCP 协议的。</p>
<p>数据从应用层进入，到达传输层，添加上 TCP首部，将数据加工成 TCP  段，称为 Segment。这是为了保证数据的可靠性。</p>
<p>接着数据到达网络层，在网络层使用 IP 协议，被添加上 IP 首部，将数据加工成 IP数据报，称为 datagram 。经过网络层 IP 协议的加工，指定目标地址和 MAC 地址，保证数据准确的发送到目标机器。</p>
<p>接着数据到达链路层，添加上以太网头部，将数据加工成以太网帧，称为 frame，包含了网卡等硬件相关的数据。</p>
<p>这就好比是一个工厂的流水线作业，每一层就像是一个流水线上的一个工人，零件到了每个工人那里，就在上面加一些东西，直到最后一个环节才变成成品。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85b02a8d8b0843c394f4dbf237413041~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>无论是 Telnet 还是  HTTP，都至少涉及到两台设备才能称之为网络互连，那发送方有一个数据自应用层向底层链路层的加工过程，对应的，在数据接收方，有一个数据从链路层向应用层解析的过程。这中间可能经历了漫长的传输介质，比如光纤，还可能有若干了中间设备，比如路由器、交换机等等。要保证数据在这么复杂的网络环境中可靠、准确的发送到目标机器，就是靠的 TCP、IP、以太网协议精巧的设计。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4dc38327b8d04ecd88d3f8ea48439866~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>通过上面的数据自上而下的加工流程图可以看出，无论网络层是不是用的 IP 协议，无论传输层用的是 TCP 还是 UDP ，最后的成品实际上就是一个以太网帧。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7dcc7c909c2d4e1baff468b5c20412ed~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h3 id="数据在网络上的传输过程">数据在网络上的传输过程</h3>
<p>上面说了数据在发送端上经过层层加头封装，以及到达目的端经过层层去头解封装的过程。但数据包很少有机会是直接从发送端一步到达目的端的，大部分都要在纷繁复杂的网络世界中穿梭游走，最终一步步的到达目的端。</p>
<p>这里先不说域名的事儿。</p>
<p>在发送数据的时候，绝大多数的情况下发送端只知道目的端的 IP 和 接收端口，这也是传输层（TCP或 UDP）必须的，经过层层包装后，拿以太网来说，真正跑到网络上的数据最终必须是一个完整的以太网帧，而以太网帧中必须要用目的端的 MAC 地址。</p>
<p>当发送端开始组装数据的时候，首先会检查目的IP 和自身的IP 是否处在同一个网络中。计算方式就是用 IP 地址和子网掩码进行「与运算」。</p>
<p>如果得到的网络地址是一致的，说明在同一个网络中，这时发送端检查自己的 ARP 表中是否有目的 IP 对应的 MAC 地址。如果有的话，直接将 MAC 地址组装到以太网数据帧中，发送数据帧，数据就能被目的端顺利接收。如果ARP 表中不存在目的IP对应的 MAC 地址，则向本网络广播发送 ARP 请求，ARP 请求会带着目的IP地址，意思就是询问“谁的IP地址是这个，请回复你的MAC地址给我”，网络中的主机看到后，如果IP是自己的，就返回给发送端一个ARP回复，回复中带着自己的MAC地址，发送端拿到MAC地址后，先存入本地的ARP表，然后组装以太网帧，将数据发送。</p>
<p>如果得到的网络地址不一致，说明目的端不在本网络中，那就要通过各种路由器、交换机等中间设备了。要发送到其他网络，就要经过路由器，路由器中维护着一张路由表，主要存放网络、主机与下一跳的对应关系。例如下表这样：</p>
<table>
<thead>
<tr>
<th>目标</th>
<th>子网掩码</th>
<th>下一跳</th>
<th>网络接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>192.168.8.0</td>
<td>255.255.255.0</td>
<td>0.0.0.0</td>
<td>en0</td>
</tr>
<tr>
<td>0.0.0.0</td>
<td>0.0.0.0</td>
<td>192.168.8.1</td>
<td>en1</td>
</tr>
</tbody>
</table>
<p>大致的意思就是如果收到一个数据报，在当前路由器的路由表中寻找，一般目标都是一个网络地址（标明一个子网），把具体数据包的IP地址和当前路由表的子网掩码进行与操作，如果得到的结果和路由表目标栏一直，就转发给这个表目的下一跳地址，从网络接口栏所记录的接口发出（也就是路由器上的网口）。</p>
<p>如果下一跳地址是0.0.0.0 ，表示这个目的IP地址就在当前网络中。那就不用路由器转发了，拿到目的IP的MAC地址，就可以直接发送了（获取MAC地址的方法，前面说过了，先查ARP表，没有的话，再用ARP广播请求获取）。</p>
<p>如果下一跳不是0.0.0.0，表示目的IP不是本网络的地址，就发给下一跳的地址。</p>
<p>如果在路由表中都没有找到匹配的目标网络，那就看有没有配置默认条目了，默认条目也就是目标是0.0.0.0的条目，表示任意的IP都可以通过此条目的下一跳（也就是默认网关）地址转发出去。</p>
<p>如果在路由表中没有找到任何匹配的目标网络，并且没有设置默认条目，那就直接将数据包丢弃，并返回一个 主机不可达的 ICMP 请求。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee31a519eca041179a1e74dbafdb4f6b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="常用的几种协议">常用的几种协议</h2>
<p>有几种协议是我们应该掌握的，这里大概介绍一下，后面会慢慢解刨。</p>
<h3 id="应用层协议">应用层协议</h3>
<p><strong>必须掌握</strong>的是HTTP 协议以及与之对应的 HTTPS 协议。这是每一个开发人员必须掌握的协议，因为我们无时无刻不在用到它。</p>
<p>其他的 FTP、SMTP、SSH等协议，了解一下就好了。</p>
<h3 id="传输层协议">传输层协议</h3>
<p><strong>必须掌握</strong>的是 TCP协议和 UDP 协议，HTTP使用的是 TCP 传输，以及各种RPC框架、中间件大部分都是包装了 TCP 协议的。</p>
<p>TCP 协议是有连接的可靠的传输协议，除非网络出现问题，可保证数据正常到达，因为有重传机制。UDP 是无连接的不可靠的传输协议，不保证数据能顺利达到，只要发出去就行了，没有重传机制等。</p>
<h3 id="网络层协议">网络层协议</h3>
<p><strong>必须掌握</strong>的是 IP 协议，从上层传递下来的包，无论是 TCP 协议还是 UDP 协议，最终都会搭载到 IP 协议之上。</p>
<p>ARP 和 RARP 协议也算是网络层协议，这两个协议负责地址转换。</p>
<p>ARP 协议根据 IP 地址得到 MAC 地址，RARP 协议根据 MAC 地址得到 IP 地址。</p>
<h3 id="链路层协议">链路层协议</h3>
<p>拿以太网位列，链路层协议一般就是指以太网帧协议。</p>
<h2 id="总结">总结</h2>
<p>1、 我们平时说的网络模型一般指的是四层模型，分别是应用层、传输层、网络层、链路层；</p>
<p>2、数据从应用层自顶而下，由应用层-&gt;传输层-&gt;网络层-&gt;链路层，经过每一层会搭载一个对应的协议，封装上对应的协议头信息，等到了目的端，再自底向上经过层层解封装，最终得到原始数据；</p>
<p>3、每一个层都有对应的协议，每一种协议都经过严密的设计，都有其特定的协议头和独特的功能特性；</p>
<p>4、除了这种软件结构上的设计外，数据包在网络世界中穿梭，还要经过各种各样的设备，比如路由器、交换机、集线器等等，一个数据包从发送端到接收端可能要经过多次的封装和解封装。</p>
<p>快把模型装进你的脑袋吧。</p>
]]></content:encoded></item><item><title>2. ARP协议：网络世界的临门一脚</title><link>https://moonkite.cn/category/network/ARP%E5%8D%8F%E8%AE%AE%E7%BD%91%E7%BB%9C%E4%B8%96%E7%95%8C%E7%9A%84%E4%B8%B4%E9%97%A8%E4%B8%80%E8%84%9A/</link><pubDate>Tue, 28 Feb 2023 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/network/ARP%E5%8D%8F%E8%AE%AE%E7%BD%91%E7%BB%9C%E4%B8%96%E7%95%8C%E7%9A%84%E4%B8%B4%E9%97%A8%E4%B8%80%E8%84%9A/</guid><description>轻解计算机网络已有高清 PDF 版本可以离线阅读了，全册 65 页，如果有需要离线版的高清 PDF 可以直接下载。 各位同学肯定见过关于网络的面试题，什么TCP协议</description><content:encoded><![CDATA[<p>轻解计算机网络已有高清 PDF 版本可以离线阅读了，全册 65 页，如果有需要离线版的高清 PDF 可以<a href="https://pan.baidu.com/s/10LH_5afGftayMo8Q1Io_gA?pwd=f8hp">直接下载</a>。</p>
<p>各位同学肯定见过关于网络的面试题，什么TCP协议和UDP的区别啦，IP协议工作在哪层啊等等，这都是网络中定义的各种协议。这些标准化的协议就是网络分层模型标准化的核心部分。要想搞懂网络，必须搞明白其中的几种主要的网络协议。</p>
<p>今天我们就开始介绍网络世界的协议。介绍的顺序大致是从网络模型由底向上来，包括数据链路层的以太网协议，网络层的 ARP协议、RARP协议、IP协议、ICMP协议，传输层的 TCP协议、UDP 协议，以及应用层的 HTTP/HTTPS协议。</p>
<p>我们假设数据包都是在以太网传输，所以以太网协议一直是贯穿始终的，因为最终所有的数据包都会被封装成以太网帧，所以其他几种协议的介绍过程中，会穿插这以太网协议，不用单独介绍，自然而然就理解了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a583629e45e41f09ee76a71ee50d8dd~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>今天我们就彻底讲清楚 ARP 协议（地址解析协议）， 我把 ARP 协议比作数据包在网络世界的临门一脚，当数据包到达了一个局域网中，局域网中有那么多机器，踢开哪台机器的大门，就靠 ARP 协议了。为什么这么说，一会儿你就明白了。</p>
<p><strong>其实 ARP 协议可以简单概括为几句话：</strong></p>
<ol>
<li>ARP 工作在局域网内；</li>
<li>ARP 的作用是根据 IP 地址获取对应的 MAC 地址；</li>
<li>在网络中最终传输的数据叫做数据帧，是数据链路层最后封装的，而数据帧要根据 MAC 地址找到目的主机，一般是目的主机的某个网卡；</li>
<li>而一般我们只知道目的主机的 IP，不知道 MAC 地址，所以需要 ARP 协议。</li>
</ol>
<p>好的，讲完了。开个玩笑，当然没有，最好还是继续看下边的内容。</p>
<p>在 OSI 模型中，通常认为 ARP和RARP属于数据链路层协议，因为它们不使用IP协议。而在TCP/IP 协议栈中，将 ARP归于网络层，和IP协议在同一层。</p>
<p>只要知道对方的 IP 地址或域名，就能将数据发送过去，这是我们常识性的理解。而且在平常的使用过程中也确实是这样的。比如我们开发过程中，建立一个 socket 连接，只要知道目标 IP 和 端口就可以了。</p>
<p>真实的网络世界中是这样的吗，确实 IP 地址是必不可少的，但是还有另外一种地址也是必不可少的，那就是 MAC 地址。</p>
<p>最终，在数据到达以太网链路层，会被包装成以太网数据帧，而数据帧中决定最终去向的是就是目标 MAC 地址，注意喽，是 MAC 地址（硬件地址），而不是 IP 地址。</p>
<p>可以把 IP 比作现实世界中一个房子的标记，比如北京市朝阳区XX路xx小区1号楼1单元801，而 MAC 地址则是这个房子的经纬度（116.354856,39.942009），虽然我们看前面的一串标示更容易理解，但是当我们要导航去那里的时候还是要靠经纬度。</p>
<p>但是如何在一大群机器中确定目标 IP 对应的 MAC 地址呢，数据已经到了局域网，这么多大门该开哪一扇呢，这就是 ARP 该做的事儿了。</p>
<p><strong>什么是 MAC 地址</strong></p>
<p>MAC地址（Media Access Control Address），直译为媒体存取控制位址，也称为局域网地址（LAN Address），以太网地址（Ethernet Address）或物理地址（Physical Address），它是一个用来确认网路设备位置的位址。在OSI模型中，第三层网路层负责IP地址，第二层资料链结层则负责MAC位址。MAC地址用于在网络中唯一标示一个网卡，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的MAC地址。</p>
<p>MAC 地址长度为6字节，48bit，用16进制的6个元组表示，例如 <code>3c:22:fb:64:4f:1d</code>，其中有一个特殊的地址就是所有比特位都是1的地址 <code>ff:ff:ff:ff:ff:ff</code>，表示是一个广播地址，意思就是指消息要发给局域网中的所有网卡。</p>
<h2 id="为什么需要-arp-协议">为什么需要 ARP 协议</h2>
<p>直接的原因就是数据链路层要将数据帧发送到目的端，必须要知道目的端的 MAC 地址，这是由网络模型的架构设计决定的。</p>
<p>下面这张图是网络 4 层模型以及数据从发送端到接收端的首发过程。发送是从上向下经过层层包装，最后形成一个数据帧（最常用的以太网帧），之后这个数据在纷繁复杂的网络世界中勇往直前，到达接收端，接收端从下向上层层拆包，最后供应用层使用。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c813b54c07b84c4d85b1736d82fb3af7~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<blockquote>
<p>上面这张图很有用的，在学习网络知识（不管是基础概念还是各种协议）的时候可以为我们提供一个宏观的视角。</p>
</blockquote>
<p>网络中的设备数以亿计，一个发送终端怎么可能知道每一台接收终端的 MAC 地址呢，显然，这是不可能的。但是 IP 是知道的，比如我们访问 github，github 每一台服务器的 MAC 地址（准确的说是一个网卡的 MAC 地址，因为一台机器上可能有多个网卡）我们是不知道的，但是它的域名我们都知道，通过域名得到 IP 地址，这是 DNS 的功能，大多数同学都很清楚，所以间接的也就相当于我们知道了 github 的IP。</p>
<p>但是，为什么我们在做应用层开发的时候不需要关注 MAC 地址。</p>
<p>根本没有什么岁月静好，只是有人在替我们负重前行罢了。在这里帮我们负重前行的就是 ARP 协议。</p>
<p>这里面有一个关键点，最终在网络上传输的包，必定是一个数据帧，最常用的就是以太网帧。</p>
<p>如果我们完全将这一过程当做一个黑盒，可以对照理解为一个程序中封装好的方法，例如 <code>getMacAddressByIP(Long ip) </code>，当我们需要得到 MAC 地址时，直接调用这个方法就可以了。</p>
<p>ARP 协议全称地址解析协议，用来将 IP 地址解析出 MAC 地址，还有一个与之相对的协议 RARP，全称叫做逆地址解析协议，用来将 MAC 地址解析出 IP 地址。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aba2b76b0ca84a9c8e91aa685af5cee9~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="arp-的工作过程">ARP 的工作过程</h2>
<p>ARP 就是工作在一个局域网中的，</p>
<p>当一台路由器或者一个具有路由转发功能的主机想要通过一个 IP 地址得到对应的 MAC 地址时，就可以使用 ARP 协议了，这个设备向它所在的目标子网中发送一个广播的 ARP  请求，请求中带着这个 IP 地址，意思是说，在这个网络中的各位，谁的 IP 是这个，请回复我一下，并告诉我你的 MAC 地址。收到这个请求的主机对这个 ARP 包进行解析，如果发现携带的 IP 正好是自己的，就返回一个 ARP 回复，回复中带上自己的 MAC 地址。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30eac5cf80314eca89b537cbdc9fe504~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>使用 ARP 协议后，目的主机将自己的 IP 地址和 MAC 地址返回给源主机，源主机将 MAC 地址加到以太网帧中，构造成完整的帧格式，再将数据帧通过链路层发出。</p>
<p>最终数据帧到达目的主机，链路层通过数据帧中的目的 MAC 地址判断数据帧是不是发给自己的，如果是的话，则接收数据帧，并经过层层解析，最终交给应用层对应的程序处理。</p>
<h2 id="先说说以太网数据帧格式">先说说以太网数据帧格式</h2>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/982fd7a2e5184f159876bcc2be97d8cf~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p><strong>以太网目的地址</strong>：目的端 MAC 地址，6字节。</p>
<p><strong>以太网源地址</strong>：发送端的 MAC 地址，6字节。</p>
<p><strong>帧类型</strong>：标记数据部分的类型，如果是 IP  数据报，值为 0x0800，如果是 ARP 数据报，值为 0x0806，2字节。</p>
<p><strong>数据</strong>：以太帧搭载的数据。只要是在以太网上发送数据，最终都会被链路层封装成以太网数据帧，所以数据部分即可以是 IP 数据报、ARP 协议包、ICMP 数据包等，以太网数据帧数据部分最小长度是 46 字节，最大长度由 MTU 决定，是 1500 字节。</p>
<p><strong>CRC</strong>：数据检验码，用来在接收端检验接收的数据是不是无差错的，4字节。</p>
<p>既然大家都是程序员，我们将这个数据帧抽象成一个实体类表示，帮助我们理解。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EthernetFrame</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 目的 MAC 地址，6字节，48bit
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Byte</span><span class="o">[]</span> <span class="n">destinationMacAddress</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Byte</span><span class="o">[</span><span class="mi">6</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 源 MAC 地址，6字节，48bit
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Byte</span><span class="o">[]</span> <span class="n">sourceMacAddress</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Byte</span><span class="o">[</span><span class="mi">6</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 标记搭载的数据类型,
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 如果是 IP  数据报，值为 0x0800
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 如果是 ARP 数据报，值为 0x0806
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Byte</span><span class="o">[]</span> <span class="n">type</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Byte</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 数据
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 以太网的数据长度为 46~1500字节。
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 最短 46   字节，不够的要填充(pad)
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 最长 1500 字节，以太网的 MTU 决定的
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Byte</span><span class="o">[</span><span class="mi">46</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 检验码 4 字节，在帧尾部
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Byte</span><span class="o">[]</span> <span class="n">crc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Byte</span><span class="o">[</span><span class="mi">4</span><span class="o">];</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="arp-协议格式">ARP 协议格式</h2>
<p>以下是 ARP 协议的格式，以及一对完整的 ARP 请求数据帧和应答数据帧。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1b59aafe469487796a9f2301d07c4d6~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p><strong>硬件类型</strong>：2字节，用来表示硬件地址的类型，为 1 表示以太网地址。</p>
<p><strong>协议类型</strong>：2字节，用来表示要映射的协议地址类型。ARP 不仅可以表示要将 IP 转换为 MAC ，还允许其他的转换关系，例如将另外一种非 IP 地址转换为 MAC 地址。当它的值为<code>0x0800</code>表示 IP 地址，与包含IP数据报的以太网数据帧中的类型字段的值相同。</p>
<p><strong>硬件地址长度</strong>：1字节，用来表示硬件地址的长度，单位是字节。在以太网中就是 MAC 地址的长度，值为6，也就表示 MAC 地址长度为 6 字节。</p>
<p><strong>协议地址长度</strong>：1字节，用来表示协议地址的长度，单位是字节。在以太网中，如果协议类型是 IP，也就是要将 IP 转换为 MAC 时，它的值是 4 ，也就是4字节，表示 IP 地址的长度是 4 字节。</p>
<p><strong>操作字段</strong>：2字节，用来表示当前操作的类型。值为1，表示 ARP 请求；值为2，表示 ARP 应答；值为3，表示 RARP 请求；值为4，表示 RARP 应答。此字段是用来区分请求和应答的必需字段。</p>
<p><strong>发送端以太网地址</strong>：6字节，用来表示发送端的以太网 MAC 地址。</p>
<p><strong>发送端 IP 地址</strong>：4字节，用来表示发送端的 IP 地址。</p>
<p><strong>目的以太网地址</strong>：6字节，用来表示目的端的 MAC 地址。</p>
<p><strong>目的 IP 地址</strong>：4字节，用来表示目的端的 IP 地址。</p>
<p>整个 ARP 协议部分共 28字节，但是在以太网中，一个以太网数据帧数据最小长度为 46，所以，后面要有18字节的数据填充。</p>
<p>操作字段为1表示这是一个 ARP 请求，ARP 请求是个广播消息，请求数据中没有目的 MAC 地址，因为还不知道嘛，我们要找的就是它。之后，ARP 应答消息（操作字段是2）将本机的 MAC 地址放到源MAC地址中，并且将 ARP 请求中的MAC地址替换为目的 MAC 地址，用来告知 ARP 发送端。</p>
<p>还是用一个实现类来表示 ARP 协议中的各个字段。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Arp</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 硬件类型，2字节，值为1表示以太网
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Byte</span><span class="o">[]</span> <span class="n">hardwareType</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Byte</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 协议类型，2字节，要映射的协议地址类型
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 0x0800 表示要转换的源协议为 IP 协议
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Byte</span><span class="o">[]</span> <span class="n">protocolType</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Byte</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 硬件地址长度，1字节，表示硬件地址的长度，单位为字节
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 硬件地址长度在以太网表示 MAC 地址的长度，值为6，也就是 6 字节
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Byte</span><span class="o">[]</span> <span class="n">hardwareAddressLength</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Byte</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 协议地址长度，1字节，表示协议地址的长度，单位为字节
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 在以太网转换 IP 为 MAC 地址时，就表示为 IP 地址的长度，也就是4字节
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Byte</span><span class="o">[]</span> <span class="n">protocolAddressLength</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Byte</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 操作字段，2字节，表示操作类型
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 1：ARP 请求
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 2：ARP 应答
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 3：RARP 请求
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 4：RARP 应答
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Byte</span><span class="o">[]</span> <span class="n">op</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Byte</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 发送端 MAC 地址，6字节
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Byte</span><span class="o">[]</span> <span class="n">sourceMacAddress</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Byte</span><span class="o">[</span><span class="mi">6</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 发送端 IP 地址，4字节
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Byte</span><span class="o">[]</span> <span class="n">sourceIpAddress</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Byte</span><span class="o">[</span><span class="mi">4</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 目的端 MAC 地址，6字节
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 在 ARP 请求中，这个地址为空
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Byte</span><span class="o">[]</span> <span class="n">destinationMacAddress</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Byte</span><span class="o">[</span><span class="mi">6</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 目的端 IP 地址，4字节
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 接收 ARP 广播的主机通过 IP 地址判断是否回复 ARP 应答(IP 地址的所有者)
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Byte</span><span class="o">[]</span> <span class="n">destinationIpAddress</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Byte</span><span class="o">[</span><span class="mi">4</span><span class="o">];</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="用-wireshark-抓个包">用 Wireshark 抓个包</h2>
<p>打开 Wireshark ，开始抓包，等待一会儿，然后停止抓包。你电脑中的各个程序会偷偷的发送和应答很多 ARP 包，</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6dfb0ec84b4c487dac7f6d9c44dbe079~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>在 Wireshark 中过滤 <code>arp.opcode == 1</code>的 ARP 请求，然后找到其中一个。用 Wireshark 分析包特别直观，我们用鼠标点击上方的某个字段时，下面会自动将这个字段的值标记出来，这样就可以清楚的看到这个字段在整个数据包中的位置了。例如下图选中了 ARP 包中的 Opcode字段（操作字段），下面的 <code> 00 01</code> 被标记了，这是用 16 进制表示的，<code>00</code>表示一个字节，<code>01</code>表示一个字节，表示这个操作字段是2个字节，值是1，也就是ARP 请求。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a4fcdcb96664a9ca5eb032eb48e65f5~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20220916144713709"></p>
<p><strong>简单分析一下这个包</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55d8e765164644de8faef8165085d8bf~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>图中 1、2、3 三个部分分别是以太网帧概要信息、以太网数据帧首部、以太网数据帧数据内容。在第一部分概要信息可以看到这个帧的总大小是 60 bytes，以太网数据帧头部的14 字节，加上内容部分最少46字节，刚好是 60 字节，其实还有一个 CRC （数据检验码），只不过本地网卡会自动剥离掉，所以在 Wireshark 中是看不到的。</p>
<p><strong>以太网数据帧首部</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/800f221f14944670886d88fbb2438811~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>上图是以太网数据帧首部信息。</p>
<p>1、目的 MAC 地址，都是 <code>ff</code>，表示这是个广播请求，ARP 请求本身就是广播的。</p>
<p>2、源 MAC 地址，本机的 MAC 地址。</p>
<p>3、帧类型，ARP 类型。</p>
<p>4、因为以太网帧数据部分最小是 46 字节，ARP 只有28字节，所以要填充18字节。</p>
<p><strong>ARP 请求信息</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d25913760b4a42f484d320126d46457e~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>从上到下依次是硬件类型、协议类型、硬件地址长度、协议地址长度（一般就是IP地址）、操作字段、发送端 MAC 地址、发送端 IP 地址、目标 MAC 地址、目标 IP 地址。</p>
<p>使用 wireshark 的 filter  <code>arp.opcode == 2</code> 可过滤出 APR 请求。</p>
<p>是不是完全听明白了，回头发现，就是我开头总结的那几点内容。</p>
<p>自己学容易，写出来真难啊，如果对各位有一点点帮助当然最好了。</p>
]]></content:encoded></item><item><title>3. 20张图说清楚 IP 协议</title><link>https://moonkite.cn/category/network/20%E5%BC%A0%E5%9B%BE%E8%AF%B4%E6%B8%85%E6%A5%9A-IP-%E5%8D%8F%E8%AE%AE/</link><pubDate>Tue, 28 Feb 2023 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/network/20%E5%BC%A0%E5%9B%BE%E8%AF%B4%E6%B8%85%E6%A5%9A-IP-%E5%8D%8F%E8%AE%AE/</guid><description>轻解计算机网络已有高清 PDF 版本可以离线阅读了，全册 65 页，如果有需要离线版的高清 PDF 可以直接下载。 今天咱们说说 IP 协议，这可是网络协议中最最核心的一</description><content:encoded><![CDATA[<p>轻解计算机网络已有高清 PDF 版本可以离线阅读了，全册 65 页，如果有需要离线版的高清 PDF 可以<a href="https://pan.baidu.com/s/10LH_5afGftayMo8Q1Io_gA?pwd=f8hp">直接下载</a>。</p>
<p>今天咱们说说 IP 协议，这可是网络协议中最最核心的一个协议了，还记得我们刚刚知道什么是IP地址、怎么给电脑修改 IP 的时候吗？今天我们就来探究一下 IP 协议。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cd7c102cfd94fbbb0b4063f319f1ecd~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>IP协议是TCP\IP协议簇中最核心的协议，大部分的上层（传输层、应用层）应用都直接或间接的使用IP协议传输，TCP协议、UDP协议都会使用 IP 协议。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db7ea1d79a5544e781c3d9fed0794dad~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>这张数据在 TCP\IP 协议模型中的加工流程一定要记到脑子中，这样当我们思考网络的问题时，可以有一个大局观。</p>
<p>IP 协议是无连接的，不可靠的网络层协议，它只负责数据的传输，但是并不能保证数据一定能到达，要想保证数据可靠，需要上层应用处理，例如 TCP协议利用IP协议传输数据，但是丢包、超时等情况还是要靠 TCP 自己解决。</p>
<h2 id="ipv4-分类法">IPv4 分类法</h2>
<p>IP 在直观上是有一个分类的，尤其是IPv4。</p>
<h3 id="传统的-ip-地址分类法">传统的 IP 地址分类法</h3>
<p>在互联网诞生之初，IP 地址就有一套标准的分类方法，因为当时互联网上的设备还很少，需要用到 IP 的企业和机构也没有那么多。谁知道后来互联网发展的如此迅猛，导致这种分类方式用起来不太合理。</p>
<p>这种分类方式是将 IP 地址分成 A、B、C、D、E 五类，每一类都有固定的前缀和应用场景。</p>
<p>一个 IP 地址占用 32 bit ，用点分十进制表示，例如 192.168.0.188，一个点号分隔一个 8 bit。</p>
<ol>
<li>IP 地址可分为 A、B、C、D、E 五类，D类是广播地址，E类是保留地址（未启用），所以重点关注 A、B、C类；</li>
<li>A、B、C 类地址分为网络地址和主机地址，网络地址表示一个网络，主机地址分给具体的主机；</li>
<li>主机地址全为 0 和全为 1 的IP 有特殊用途，主机地址全为 0 ，表示网络号，代表这个网络本身；主机地址全为1，表示广播地址，代表这个网络中的所有主机；</li>
<li>每个类别中（除了 D、E类），都有一些地址有特殊的用户，留作私有地址或者回环地址，例如192.168、127.0.0.1；</li>
<li>子网掩码全为1的位数就是网络地址的位数；</li>
</ol>
<p><img src="https://hexo.moonkite.cn/blog/image-20221005210508217.png" alt=""></p>
<h4 id="a-类">A 类</h4>
<p><img src="https://hexo.moonkite.cn/blog/image-20221005210627806.png" alt=""></p>
<p>A 类地址前 8 位为网络地址，后24位为主机地址。</p>
<p>网络地址中第一位固定为0，有从0 ~ 127共128个网络，每个网络可容纳$2^{24}-2$ =16,777,214台主机。但其实可用的 IP 地址从[1.0.0.0] ~ [126.255.255.255]。</p>
<p><strong>特殊网络地址：</strong></p>
<p>但其中网络地址全0和全1的为特殊地址，不能使用，所以 A 类地址可用的网络数其实是 126个。</p>
<p>127.0.0.1，这个地址我们都非常熟悉，一般我们说这个是本地地址（localhost），其实这个地址准确的名称叫做「回环地址」，</p>
<p>可以理解为一个虚拟网卡，这个网卡只接收来自本机的数据包。</p>
<p>0.0.0.0，这个地址其实才代表本机，假设一台主机上有两个网卡，一个服务监听了 0.0.0.0 这个IP ，则发给这两个网卡的数据都会被监听到。</p>
<p>还有网络地址 10 开头的地址用作内网地址，从 10.0.0.0~10.255.255.255。好多公司的内网 IP 都是10网段的。</p>
<p><strong>特殊主机地址：</strong></p>
<p>每一个网络，主机地址全 0 和 全 1 的都是保留地址，所以每一个网络的主机数都是$2^n-2$ ，n 是主机地址的位数。</p>
<h4 id="b类">B类</h4>
<p><img src="https://hexo.moonkite.cn/blog/image-20221005210758624.png" alt=""></p>
<p>16位网络地址，16位主机地址。网络地址中前两位固定为 10，有$2^{14}$ =16384个网络，每个网络可容纳  $2^{16}-2$=65534台主机。</p>
<p>但其实可用的 IP 地址从128.0.0.0到191.255.255.250。</p>
<p><strong>特殊网络地址：</strong></p>
<p>172.16.0.0~172.31.255.255是私有地址。</p>
<p>10101100.0001000.00000000.00000000 ~ 10101100.00011111.11111111.11111111</p>
<p>169.254.0.0到169.254.255.255是保留地址。</p>
<p>10101001.11111110.00000000.00000000 ~ 10101001.11111110.11111111.11111111</p>
<p><strong>特殊主机地址：</strong></p>
<p>每一个网络，主机地址全 0 和 全 1 的都是保留地址，所以每一个网络的主机数都是 $2^n-2$ ，n 是主机号的位数。</p>
<h4 id="c类">C类</h4>
<p><img src="https://hexo.moonkite.cn/blog/image-20221005211227386.png" alt=""></p>
<p>24位网络地址，8位主机地址。网络地址中前三位固定为110，有 $2^{21}$ 个网络，每个网络可容纳 $2^{8}-2$ =254台主机。</p>
<p>但其实可用的 IP 地址从192.0.0.0~223.255.255.255。</p>
<p><strong>特殊网络地址：</strong></p>
<p>192.168.0.0～192.168.255.255 留作私有地址使用。</p>
<h4 id="d-类">D 类</h4>
<p><img src="https://hexo.moonkite.cn/blog/image-20221005211333851.png" alt=""></p>
<p>D类地址以 <strong>1110</strong> 开始，并且不区分网络地址和主机地址，这类地址用作是广播地址，用来接收广播消息</p>
<h4 id="e类">E类</h4>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1464eaeb8ad44d779d90a8bffca916b6~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>E类地址以1111开始，保留地址，还未启用。</p>
<h3 id="传统分类法缺陷">传统分类法缺陷</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01c65c8f648f40cd81f52639e62cb70a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h4 id="网络数和主机数搭配不协调">网络数和主机数搭配不协调</h4>
<p>A类、B类可用网络数很少，只有1万多个，但是每个网络的主机数又太多了，</p>
<p>现实中没有哪个机构或企业的主机数会有那么多，所以如果一个企业得到一个B类地址，其实只能用到很少的主机地址，剩下的就浪费了。</p>
<h4 id="整体网络数太少">整体网络数太少</h4>
<p>A、B、C类的网络数加起来只有200多万个，但是全世界有那么多机构、企业，每个企业都申请一个网络地址，显然是不够用的。</p>
<h4 id="路由难以聚合路由表过大">路由难以聚合，路由表过大</h4>
<p>虽然200多万的网络数据量在全世界范围内不算多，但是对于一个路由器的路由表来说就太多了。假设一个地区有十几万个 C类地址，那路由器想要路由这些地址，就要在路由表中记录这么多的路由表项，显然是不太合理的。</p>
<h3 id="无类别域间路由cidr分类法">无类别域间路由（CIDR）分类法</h3>
<p>正是因为传统的A、B、C、D、E类分法的一些缺陷，CIDR 便应运而生。</p>
<p>CIDR 仍然是用点分十进制的方式表示，IP v4 中仍然是 32 位，每8位一组，共4组。只是需要在后面加一个数字后缀，表示这个地址的网络地址是多少位。</p>
<p>传统的分类方法是以 8 位为最小单元，网络地址只能是8位、16位、24位，而在 CIDR 中用子网掩码区分网络地址和主机地址，连续为1的位数就是网络地址位数，用二进制可以清楚的看出来。</p>
<p>例如子网掩码是 11111111.00000000.00000000.00000000，前面8位连续都是1，表示8位的网络地址，子网掩码就是 255.0.0.0。</p>
<p>再比如子网掩码是 11111111.11100000.00000000.00000000，前面11位连续都是1，表示11位的网络地址，子网掩码就是 255.224.0.0。这与传统的 IP 地址分类法就不一样了。</p>
<p>看下面两个 CIDR IP 地址，一个 11位网络地址的 IP ，一个 22 位网络地址的 IP。</p>
<p>例如 209.34.21.7/11，表示前11位代表网络地址，后面的21位都是主机地址。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91c5b257db834f2191fbebdd9a08be10~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>207.128.28.4/22，表示前22位是网络地址，后面10位是主机地址。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bb75b435be94dcd897fb149609e9aef~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h4 id="超网和子网">超网和子网</h4>
<p>IP 地址的申请有专门的管理机构控制，互联网地址顶级指派机构会负责分派超大地址块，地址块就是一个IP下包换的 IP 地址集合。 这些超大地址块会分配给大型网络提供商，大型的网络提供商又可以再分派小一些的地址块，这些小的地址块会分配给中型、小型的网络服务提供商，最后一些企业或机构再跟这些中小型的网络服务提供商申请供内部使用、有对外功能的 IP 地址。</p>
<p>这些分配给大型网络提供商的超大的地址块就可以被称为超网，下面分派出去的地址块可以被称为子网。当然这个超网和子网的概念是相对的，对于一个企业而言，分给它 IP 的网络服务提供商所拥有的网络就是超网。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2abea433aff34c4285759b831dda9d82~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>上图这个例子中，假设 <code>209.32.0.0/11</code>这个11位前缀的网络被分给了一个大型网络服务提供商 A，那它可分配的地址数高达 200多万个，可想而知，没有任何一家企业或机构需要这么多个 IP 地址吧。</p>
<p>B 是比较大的企业，财大气粗，它去找A申请，于是 A 将 <code>209.34.20.0/22</code>这个前缀长度为22位的地址块分给了 B 。B 的旗下还有分公司，于是它又将 <code>209.34.21.0/24</code>这个地址块分给了其中的一个子公司。于是这个子公司就拥有了200多个 IP 地址，比如 <code>209.34.21.1/24</code>。</p>
<h4 id="什么是路由聚合">什么是路由聚合</h4>
<p>前面在说传统分类方式的时候，提到了一个缺点，就是路由难以聚合，可能会导致路由表过大，一个路由表可能要存上万、甚至更多的 C类地址记录。</p>
<p>CIDR 正好可以解决这个问题，这就是我们所说的路由聚合能力。那什么叫路由聚合呢。</p>
<p>路由聚合的意思是根据前缀进行聚合，有一些网络地址块它们虽然是不同的，但是他们的一部分前缀是相同的，这也是二进制的特性决定的。</p>
<p>十进制的 8 和 9是完全不同的两个数对不对，但是我们把它们改为二进制的看一下，就会发现他们的前三位都是一样的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db3ae04e519f4c2ba0aadd066c9bea1a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>看下面这张图中的例子，是将两个20位前缀的网络聚合为一个19位前缀的路由。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f63cadcc93b45f4851982cf19ada88d~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>我们看到上面这两个网络 <code>209.34.48.0/20</code>和<code>209.34.32.0/20</code>，它们的前19位二进制都是完全一致的，上面说到的，相同就可以聚合，所以将前19位聚合，聚合成一个 19位前缀的网络，也就是 <code>209.34.32.0/19</code>。</p>
<p>当有访问到 <code>209.34.48.0/20</code>和<code>209.34.32.0/20</code> 这两个网络中的地址时，其实它们两个对外都是显示的  <code>209.34.32.0/19</code>，也就是说这两个网络都会命中 19位前缀的路由记录，也就缩小了这个路由器的记录规模，而到哪个具体的 IP，就靠子网络中的路由了。</p>
<p>这相当于一种分而治之的策略，保证顶层路由表不会过大，子路由表也不会过大。</p>
<h2 id="ipv6">IPv6</h2>
<p>即使有了 CIDR 分类法，IPv4 的数量依然十分紧俏。目前 IPv4的地址已全部分配完毕，分到中国的大概有3亿多，而中国的终端设备这么多，大多数情况下要多个设备共用一个地址，这种情况下就要借助 NAT 技术了。</p>
<p><strong>什么是 NAT</strong></p>
<p>NAT 就是让多个内网主机，转成一个公网IP来连接互联网。拿平时用微信聊天来说，我们在公司的时候那么多同事共用一个热点，消息是怎么来回发送，而且每次都准确的到达终端的呢。</p>
<p>当发送消息的时候，消息经过 NAT 设备的转发，将发送地址变换为当前网络对外的公网地址；</p>
<p>当接收到消息时，消息经过 NAT 设备，根据 NAT 设备记录的信息(和端口号有关)，将消息转发给对应的内网终端。</p>
<p>但是 NAT 会导致网络的性能变差，而且 NAT 也是有数量限制的。这就使得 IPv6 势在必行了，目前，有很大一部分互联网公司都已经支持 IPv6了。</p>
<p>IPv6地址长度为 128位（bit），是IPv4的4倍。其所包含的 IP 个数为 $2^{128}$个，这个数字太大了，这么说吧，按照现在的人口数，随便用，根本就用不完。</p>
<h3 id="表示方法">表示方法</h3>
<p>常用的就是前面两种。</p>
<h4 id="冒分十六进制表示法">冒分十六进制表示法</h4>
<p>用 8 组冒号分隔的16进制数分隔，例如 <code>2408:8207:2462:bcc0:89b:16e1:771d:4bec</code></p>
<h4 id="0位压缩表示法">0位压缩表示法</h4>
<p>在某些情况下，一个IPv6地址中间可能包含很长的一段0，可以把连续的一段0压缩为“::”。但为保证地址解析的唯一性，地址中”::”只能出现一次，例如：</p>
<p>FF01:0:0:0:0:0:0:1101 → FF01::1101</p>
<p>0:0:0:0:0:0:0:1 → ::1</p>
<p>0:0:0:0:0:0:0:0 → ::</p>
<h3 id="ipv6的特点">IPv6的特点</h3>
<ol>
<li>
<p>IP地址依然适应互联网分层构造。分配与其地址结构相适应的IP地址，尽可能避免路由表膨胀。</p>
</li>
<li>
<p>包首部长度采用固定的值 （40 字节），不再采用首部检验码。简化首部结构，减轻路由器负荷。路由器不再做分片处理(通过路径 MTU 发现只由发送端主机进行分片处理），提升了性能。</p>
</li>
<li>
<p>﻿支持即插即用功能，即使没有DHCP 服务器也可以实现自动分配IP 地址。</p>
</li>
<li>
<p>采用认证与加密功能，应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能 (IPsec)。</p>
</li>
</ol>
<h2 id="ipv4-协议格式">IPv4 协议格式</h2>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a76417aa89d947c5bc21ea55375ad38f~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p><strong>版本</strong></p>
<p>版本字段占用 4 bit，用来标示当前使用的 IP 协议版本，只有 IPv4（0100） 和 IPv6（0110） 两个版本区分。</p>
<p><strong>首部长度</strong></p>
<p>首部长度表示占32bit的数目，也就是有多少个4字节（32bit/8=4字节），比如首部长度是5，就表示有5个4字节，也就是20个字节。</p>
<p>而用来表示首部长度的字段是4bit，这样一来它可表示的最大长度就是二进制的「1111」，也就是2^4-1=15，也就是最大可以是 15个4字节，也就是15*4=60个字节，也就是说首部的最大长度是60个字节，而通过图可以看出来固定的部分占20字节，那可选项部分的最大长度就是40字节。</p>
<p><strong>服务类型</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1496abc8d709451cba40f50f81ed7622~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>服务类型，英文全称 Type of Service。用来标示是一个什么类型的应用正在使用IP协议。</p>
<p>前面 3 个bit 用来标示优先级，但现在已经被忽略了。接着 4 个bit 用来标示子类型，每一个bit分别代表最小延迟、最大吞吐量、最高可靠性、最小费用。例如 Telnet 应用要求最小延迟，所以这4个bit分别是 「1000」。</p>
<p>最后一个bit是保留位，但必须是0。</p>
<p>但是现在很少有应用支持 TOS，所以了解一下就可以了。这属于理想很丰满，现实很骨感的一个体现。标准是标准，但是实现上会有一定差异。</p>
<p><strong>总长度字段</strong></p>
<p>IP 报文除了首部还要携带数据，总长度字段指整个 IP 报文的长度，单位是字节。总长度字段占2个字节，16bit，这样算下来，总共可以表示2^15-1 ，也就是65535个字节。虽然可以表示这么多字节，但是绝多数情况下都不会一次性传输这么大的数据量，会有很多因素影响每个数据报的最大值。</p>
<p>数据报的最大长度主要和上层应用限制和MTU限制有关系。</p>
<p>例如DNS服务就限制数据报最大长度为 512字节。</p>
<p>另外我们常用的以太网 MTU (最大传输单元)就是 1500字节，所以在以太网上的报文不能超过 1500字节。</p>
<p>可以用 <code>netstat -in</code> 查看本机网络接口的 MTU。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fac23d71eb674d2e8fa42b4a3ff9fc23~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>总长度-首部长度=数据长度。有一种情况，以太网要求报文的最小长度是46字节，但是 IP 数据报的总长度可能不足46字节，例如只传输很少的数据，这种情况下，以太网链路层就要将不足46字节的部分补全。这样一来，当接收方IP层接到这个报文后，就可以通过总长度字段和首部长度得出真正的数据长度，从而将后面多余的数据部分去掉。</p>
<p><strong>分片标示</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a56e41f255d45e09bea6ab95906e9d5~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>如果报文超过 IP 层允许的最大报文长度，就会进行 IP 分片，将原本的大报文分片成一个个小的报文，每一个小的报文都可能会从不同的路径发送到目标主机，而每一个分片报文发送到目的主机的顺序也不一定是按照原有顺序到达的。所以，在目的主机端获取到所有的报文分片后，要按照原始的顺序将一个个小的分片还原成原始的报文。</p>
<p>在还原的过程中就需要知道各个分片的顺序，标志、标示和片偏移字段就是为了完成这个还原的过程。</p>
<p>标志字段，当数据报被分片后，来自一个大报文的每个分片都会被赋予相同的值，用来表示这些分片来自同一个报文，在报文还原的时候用。</p>
<p>标示字段为 3 占3个bit，第一位始终是0，第二位是DF位，如果是1表示不分片，第三位是MF，如果是1，表示这个分片不是最后一个，后面还有更多的分片。</p>
<p>片偏移字段表示这个分片的偏移量，单位是 8 个字节，也就是 8*8=64个bit。例如第一个分片的偏移量是0，第二个分片的偏移量是1，则第二个分片相对第一个分片的偏移量是1，也就是 8 个字节。如下图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b5eed04e7db4186aa13f4696baef7a3~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>如果第二个偏移量的值是3，则相对于第一个分片的偏移量是 3*8字节=24字节。</p>
<p><strong>TTL</strong></p>
<p>IP数据报的生存时间，单位不是时间单位，而是跳数。在网络上，没经过一个路由器，叫做一跳，例如我们经常听到的下一跳路由，就是指一个数据包要经过的下一个路由器。</p>
<p>一般TTL是32或64，由初始主机设置，表示这个IP报文最多可经过32个路由或64个路由，每经过一个路由器，TTL 的值就减一，当这个值为0时，路由器就直接将这个报文丢弃。并发送 ICMP 报文给源主机，由源主机商的服务决定是重发还是怎么样。</p>
<p>之所以要设置一个值，是防止浪费太多网络资源，如果一个报文经过了好多路由器还没有到达目的地，很有可能就是网络有问题了，比如进入了一个循环网络，或者目的端未联网。</p>
<p><strong>协议</strong></p>
<p>协议字段，长度为8个bit，标识了上层所使用的协议，下面是几个比较常用的协议号。
1：ICMP，2：IGMP，6： TCP，17： UDP</p>
<p><strong>首部检验和</strong></p>
<p>首部检验和用来检验一份报文的正确性，当报文到达目的端后，用首部检验和规定的校验方法计算，并用计算出的结果和此报文本身携带的首部检验和字段做比较，如果结果一致，则说明报文没有问题，如果结果不一致，则直接丢弃报文。</p>
<p>在传输过程中 TTL 的值会一点点减小，所以在TTL减小的同时，也会动态调整首部检验和的内容，因为如果首部检验和如果不根据TTL进行调整的话，在报文达到目的端后，根据首部各字段的值进行计算，由于TTL已经减小，最终算出的检验和必定会与最开始的检验和不一致，即使是没有问题的报文也会被丢弃。</p>
<p><strong>可选项</strong></p>
<p>可选项可有可无，它有如下几种功能：</p>
<p>• 安全和处理限制（用于军事领域）</p>
<p>• 记录路径（让每个路由器都记下它的 IP地址）</p>
<p>• 时间戳（让每个路由器都记下它的 IP地址和时间）</p>
<p>• 宽松的源站选路（为数据报指定一系列必须经过的 IP地址）</p>
<p>• 严格的源站选路（与宽松的源站选路类似， 但是要求只能经过指定的这些地址， 不能经过其他的地址）。</p>
<p>这些选项很少被使用，并非所有的主机和路由器都支持这些选项。 选项字段一直都是以 32 bit作为界限，在必要的时候插入值为 0的填充字节。这样就保证 IP首部始终是32 bit的整数倍。但是最大长度不能超过40字节。</p>
<p><strong>数据</strong></p>
<p>数据就是真正要传输的内容了，当然包括上一层的头信息，例如 TCP头、UDP头。</p>
<h2 id="ipv6-协议格式">IPv6 协议格式</h2>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30aefa5845b4419ea4e49028e5dde391~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p><strong>版本</strong></p>
<p>版本字段占用 4 bit，用来标示当前使用的 IP 协议版本，IPv6 固定为 0110，也就是 6 。</p>
<p><strong>通信量类</strong></p>
<p>相当于IPv4 的 TOS (Type Of Service）字段，占用8 bit。由于 TOS 在 IPv4 中几乎都没有什么用处，未来可能会删掉这个字段。</p>
<p><strong>流标号</strong></p>
<p>占用20bit，准备用于服务质量(QoS)控制。使用这个字段提供怎样的服务已经成为未来研究的课题。不使用 QoS时，直接将所有位设置为 0 即可。</p>
<p>在进行服务质量控制时，将流标号设置为一个随机数，然后利用一种可以设置流的协议 RSVP (Resource Reservation Protocol)在路由器上进行QoS 设置。当某个包在发送途中需要 QoS时，需要附上 RSVP 预想的流标号。路由器接收到这样的 IP 包后先将流标号作为查找关键字，迅速从服务质量控制信息中查找并做相应处理。</p>
<p>此外，只有流标号、源地址以及目标地址三项完全一致时，才被认为是一个流（例如数据包进行了分片）。</p>
<p><strong>有效载荷长度</strong></p>
<p>占用 16bit，有效荷载长度是指包的数据部分的长度。IPv4的总长度是指包含首部在内的所有长度。然而IPv6中的这个有效载荷长度不包括首部，只表示数据部分的长度。</p>
<p><strong>下一个首部</strong></p>
<p>占用 8 bit，相当于IPv4中的协议字段。通常表示IP的上一层协议是TCP或UDP。不过在有IPv6扩展首部的情况下，该字段表示后面第一个扩展首部的协议类型。</p>
<p><strong>跳数限制</strong>（Hop Limit）</p>
<p>占用 8 bit。与 IPv4中的TTL概念一致。为了强调“可通过路由器个数”这个概念，才将名字改为Hop Limit。数据每经过一次路由器就减1，减到0则丢弃数据。</p>
<p><strong>源地址</strong></p>
<p>占用128bit，16字节。表示发送端IP地址。因为 IPv6 长度就是128bit。</p>
<p><strong>目标地址</strong></p>
<p>占用128bit，16字节。表示接收端IP地址。</p>
<p><strong>扩展首部</strong></p>
<p>IPv6的首部长度是固定的，共40字节。IPv4中的可选项就没地方放了，而 IPv6 增加了扩展首部的概念，通过扩展首部来实现IPv4中的可选项。 在IPv4中可选项长度固定为40字节，但是在IPv6中没有这样的限制。也就是说，IPv6的扩展首部可以是任意长度。扩展首部当中还可以包含扩展首部协议以及下一个扩展首部字段。</p>
<p><strong>数据</strong></p>
<p>要传输的数据，当然也就包含上层的头信息，例如UDP头、TCP头。</p>
<h2 id="路由选择">路由选择</h2>
<p>IP协议有一个特别重要的特质就是路由选择，就是决定一个 IP 数据报从哪条路走，最终能不能成功的到达目的端，全靠 IP 的路由选择功能。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/304c91f53dc64e75a16bbac7c0f952c2~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>如上图所示，主机1想把数据发往主机3，中间经过两个路由器，真实环境下会更多。最终路径假设是图中红线连接的部分，每一个红线都称为一跳。</p>
<p>IP数据包在每次发往下一跳地址的时候都会被重新封装，封装的头信息中的目的地址就是下一跳的 IP 地址。</p>
<p><strong>每一个设备是怎么得到下一跳 IP 的呢，这就要提到路由表了。</strong></p>
<p>路由器（包括可转发数据的主机）中维护着一张路由表，主要存放网络、主机与下一跳的对应关系。例如下表这样：</p>
<table>
<thead>
<tr>
<th>目标</th>
<th>子网掩码</th>
<th>下一跳</th>
<th>网络接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>192.168.8.0</td>
<td>255.255.255.0</td>
<td>0.0.0.0</td>
<td>en0</td>
</tr>
<tr>
<td>114.21.1.0</td>
<td>255.255.255.0</td>
<td>114.21.1.100</td>
<td>en0</td>
</tr>
<tr>
<td>0.0.0.0</td>
<td>0.0.0.0</td>
<td>192.168.8.1</td>
<td>en1</td>
</tr>
</tbody>
</table>
<h2 id="差错报告">差错报告</h2>
<p>前面说了，IP 协议不可靠，不保证数据一定能正确到达目的端，但是它还是提供了必要的差错报告机制，用来返回给上层使用程序，让上一层知道当前传输的数据发生了什么错误。至于如何处理，就不管了。</p>
<p>差错报文用 ICMP 协议发送，ICMP 是互联网控制报文协议，分为主动查询报文和差错报告报文，主动查询的例如 <code>ping</code>命令，绝大多数都是为了表示数据传输过程中发生了错误，以此来提示发送端。</p>
<p><strong>发送ICMP差错报文</strong></p>
<p>例如当数据包到达一个路由器，在路由器搜索了路由表的所有记录后，仍然没有发现合适的记录，并且路由表也没有配置默认项（默认项就是在没有找到绝对匹配的记录时默认发送的配置），这时候就会发送一个 <strong>ICMP 差错报文，表示网络或主机不可达</strong>，发送给谁呢，发送给这个IP数据包的发送端。</p>
<p><strong>发送ICMP重定向报文</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e18a24cfb60d45cfb72f285a2ff6eeaf~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>重定向报文更像是一种优化策略，如图，假设一个主机同时连接了两台路由器A和B，而路由表中只有其中一个路由器A的配置项。在某次发送数据时，主机1将数据包发给下一跳路由器A，而路由器A接收到数据包后，通过路由选择，下一跳是路由器B，就是图中红色的①②的路径，而此时路由器A发现自身、路由器B、主机1在同一局域网中，此时，路由器A便向主机1发送一个<strong>ICMP重定向报文</strong>。用来告诉主机1，“下次再有类似的包，直接发给路由器B就行了，别绕弯子了”。</p>
]]></content:encoded></item><item><title>4. 30张图说清楚 TCP 协议</title><link>https://moonkite.cn/category/network/30%E5%BC%A0%E5%9B%BE%E8%AF%B4%E6%B8%85%E6%A5%9A-TCP-%E5%8D%8F%E8%AE%AE/</link><pubDate>Tue, 28 Feb 2023 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/network/30%E5%BC%A0%E5%9B%BE%E8%AF%B4%E6%B8%85%E6%A5%9A-TCP-%E5%8D%8F%E8%AE%AE/</guid><description>大家好，我是风筝 轻解计算机网络已有高清 PDF 版本可以离线阅读了，全册 65 页，如果有需要离线版的高清 PDF 可以直接下载。 今天，继续来网管的自我修养之TC</description><content:encoded><![CDATA[<p><strong>大家好，我是风筝</strong></p>
<p>轻解计算机网络已有高清 PDF 版本可以离线阅读了，全册 65 页，如果有需要离线版的高清 PDF 可以<a href="https://pan.baidu.com/s/10LH_5afGftayMo8Q1Io_gA?pwd=f8hp">直接下载</a>。</p>
<p>今天，继续来网管的自我修养之TCP协议，这可是除 IP 协议外另一个核心协议了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/092fee6e14544be69784b5ba353e13a8~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>TCP 协议是网络传输中至关重要的一个协议，它位于传输层。向上支持 FTP、TELNET、SMTP、DNS、HTTP等常见的应用层协议，向下要与网络层的 IP 协议相互配合，实现可靠的网络传输。</p>
<h2 id="分层网络模型">分层网络模型</h2>
<h3 id="osi-7层模型">OSI 7层模型</h3>
<p>为了让全世界的计算机有效的互联起来，国际标准化组织提出了一种概念化的网络模型，<strong>开放式系统互联模型</strong>（Open System Interconnection Model），简称 OSI 模型。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbf440d1c638424589f64de544d1ae98~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>自上而下依次为应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。</p>
<h4 id="应用层">应用层</h4>
<p>应用层提供为应用软件而设计的接口，以设置与另一应用软件之间的通信。例如：HTTP、HTTPS、FTP、Telnet、SSH、SMTP、POP3等。</p>
<h4 id="表示层">表示层</h4>
<p>表示层把数据转换为能与接收者的系统格式兼容并适合传输的格式。</p>
<h4 id="会话层">会话层</h4>
<p>会话层负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接。</p>
<h4 id="传输层">传输层</h4>
<p>传输层把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:传输控制协议（TCP）等。</p>
<h4 id="网络层">网络层</h4>
<p>网络层决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组。网络表头包含了网络资料。例如:互联网协议（IP）等。</p>
<h4 id="数据链路层">数据链路层</h4>
<p>数据链路层负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成信息框。数据链表头（DLH）是包含了物理地址和错误侦测及改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串。例如以太网、无线局域网（Wi-Fi）和通用分组无线服务（GPRS）等。</p>
<p>分为两个子层：逻辑链路控制（logical link control，LLC）子层和介质访问控制（Media access control，MAC）子层。</p>
<h4 id="物理层">物理层</h4>
<p>物理层在局部局域网上传送数据帧，它负责管理电脑通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡等。</p>
<p>OSI 模型是国际标准模型，是指导互联网模型的概念标准。而在实际的设计实现过程中，最后形成了 TCP/IP 4层模型结构。</p>
<h3 id="tcpip-4层模型">TCP/IP 4层模型</h3>
<p>TCP/IP 模型实际上并不单单指 TCP 和 IP，实际上这一个协议簇，还包含了其他的一些协议，比如 UDP、ICMP、IGMP 等。</p>
<p>TCP/IP 模型是事实上的标准模型，在 7 层模型的基础上将最上面三层的应用层、表示层、会话层统一为应用层，将数据链路层和物理层统一为链路层或者叫网络接口层。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01a6141765d644fc9ab4ac508314b1d2~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>实际应用中还是以 4 层模型为准，毕竟这才是事实上的标准。还有一种 5 层模型的说法，实际上就是把 7 层中的应用层、表示层、会话层合并为应用层，其他层保持不变。</p>
<h2 id="数据的加工和传输过程">数据的加工和传输过程</h2>
<p>TCP/IP 模型每个层都有各自的功能和分工，当有用户数据想要发送给另一台设备的时候，数据自上而下，从应用层向链路层传递有一个复杂的过程。</p>
<p>以 Telnet 为例，Telnet 在传输层是使用 TCP 协议的。</p>
<p>数据从应用层进入，到达传输层，添加上 TCP首部，将数据加工成 TCP  段，称为 Segment。这是为了保证数据的可靠性。</p>
<p>接着数据到达网络层，在网络层使用 IP 协议，被添加上 IP 首部，将数据加工成 IP数据报，称为 datagram 。经过网络层 IP 协议的加工，指定目标地址和 MAC 地址，保证数据准确的发送到目标机器。</p>
<p>接着数据到达链路层，添加上以太网头部，将数据加工成以太网帧，称为 frame，包含了网卡等硬件相关的数据。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3757de1327d74768a5d53ffd6e0bb714~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>无论是 Telnet 还是  HTTP，都至少涉及到两台设备才能称之为网络互连，那发送方有一个数据自应用层向底层链路层的加工过程，对应的，在数据接收方，有一个数据从链路层向应用层解析的过程。这中间可能经历了漫长的传输介质，比如光纤，还可能有若干个中间设备，比如路由器、交换机等等。要保证数据在这么复杂的网络环境中可靠、准确的发送到目标机器，就是靠的 TCP、IP协议精巧的设计。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b29d33d0ff9459787c97a46d3810eea~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="tcp-协议">TCP 协议</h2>
<p>TCP，全称是 Transmission Control Protocol，传输控制协议。 是一种面向连接的、可靠的字节流服务协议，正因为它要保证可靠性，所以比起 UDP 协议要复杂的多，正是由于这种复杂性，导致它的性能比 UDP 差。</p>
<p>TCP 是 TCP/IP 模型中的传输层一个最核心的协议，不仅如此，在整个 4 层模型中，它都是核心的协议，要不然模型怎么会叫做 TCP/IP 模型呢。</p>
<p>它向下使用网络层的 IP 协议，向上为 FTP、SMTP、POP3、SSH、Telnet、HTTP 等应用层协议提供支持。其他的还有我们常用的 Redis 的 RESP 协议、MongoDB的网络协议，以及我们编程中用到的 Socket，都是 TCP 协议在背后提供支持的。</p>
<p>网络协议是通信计算机双方必须共同遵从的一组约定。如怎么样建立连接、怎么样互相识别等。只有遵守这个约定，计算机之间才能相互通信交流。它的三要素是：语法、语义、时序。</p>
<ol>
<li>
<p>语法：即数据与控制信息的结构或格式；</p>
</li>
<li>
<p>语义：即需要发出何种控制信息，完成何种动作以及做出何种响应；</p>
</li>
<li>
<p>时序（同步）：即事件实现顺序的详细说明。</p>
</li>
</ol>
<h3 id="tcp-协议格式">TCP 协议格式</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46ba0f81fc144b1cbd79664d22e9bbd4~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>TCP首部 + 用户数据被称为TCP段，其中 TCP 首部就是这里要主要研究的 TCP 协议的核心所在，用户数据部分是 TCP 段的负载。</p>
<p>TCP 段的大小也是有限制的，最大是 1460 字节，这是怎么算出的呢？</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/612ca8c8fc9942aea7d35a301f73ef1a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>最终由网卡发出去的数据包叫做以太网帧，以太网帧由以太网首部和负载构成。</p>
<p>以太网帧的负载就是一个 IP 数据报，IP数据报由IP首部和负载构成。</p>
<p>IP数据报的负载就是一个 TCP段。所以，TCP段所能搭载的最大数据量可以这样计算出来：</p>
<p>$TCP段搭载的数据大小 = 以太网帧大小-以太网首部-IP首部-TCP首部$</p>
<p>以太网帧的大小是固定的 1522字节，而IP首部和TCP首部的大小是不固定的，但是最少会各占20字节，所以最后算下来 TCP段搭载的数据大小最多为 1460字节。</p>
<p>$TCP段搭载的数据大小（最多1460） = 以太网帧大小（1522字节）-以太网首部（22字节）-IP首部（最少20字节）-TCP首部（最少20字节）$</p>
<p>下图是TCP协议的示意图，如果不算「可选项」部分的话，共占用 <code>32bit x 5 = 160bit</code>，也就是20个字节。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db1759d24ccc4660a29135fcfe81c990~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h4 id="源端口和目标端口">源端口和目标端口</h4>
<p>源端口和目标端口分别占用 2个字节，共占用 4 字节，分别记录数据发送端的端口号和数据接收端的端口号，这两个标记和 IP 协议中记录的发送端 IP 和接收端 IP组合起来，便可确定一个唯一的 TCP 连接。</p>
<h4 id="序号">序号</h4>
<p>由于TCP段的大小有限制，当要传输的数据量大于这个限制的时候，就要对数据进行分段，一段一段的发送，既然发送方要分段，那接收方就要对分段进行重组，才能还原回原始数据。在重组的过程中，要保证各段间的先后顺序，序号正是起到保证重组顺序的作用。</p>
<p>序号占用 4 字节，32 位，它的范围是 [0,$2^{32}$]​。TCP是字节流服务，会对每一个发送的字节进行编号。在建立连接的时候，系统会给定一个 ISN(初始序号)，然后这个设备在当前连接中发送的第一个字节的序号就是 ISN+1，假设 ISN 初始为0，那第一个字节的序号就是 1。</p>
<p>举个例子，假设ISN为0，发送端第一次发送 100 字节的数据包，那这第一个 TCP段的序号就是1，下次再发送 100字节的数据包，那这第二个 TCP段的序号就是 101。</p>
<p>这样一来，最大可以一直标记 $2^{32}$个字节，也就是 4个G的数据。当达到最大值后，又会从 0 开始标记。</p>
<p>序号只有在下面两种情况下才有用：</p>
<ol>
<li>数据字段至少包含一个字节。</li>
<li>是一个 SYN 段，或者是 FIN 段，或者是 RST 段。</li>
</ol>
<h4 id="确认序号">确认序号</h4>
<p>当数据发送出去，接收方收到之后，会回复一个确认序号回复给发送方，这个确认序号表示接收方希望下次接收的序号。例如发送了序号为501的，长度为100的TCP段，那接收方收到后要回复 601的确认序号，表示【0-600】的字节已经接收，下次希望收到第 601个字节以后的数据。</p>
<p>为了提高效率，并不是每次接收到TCP段都会马上回复给发送方，而是采用累积确认的方式，即每传送多个连续 TCP 段，可以只对最后一个 TCP 段进行确认。</p>
<p>确认序号只有在 ACK 标志位被设置的时候才有效。</p>
<h4 id="首部长度">首部长度</h4>
<p>之所以需要首部长度，是因为可选项的大小是不固定的，如果没有可选项的话，那首部长度就是 20字节。这个标示部分占 4 bit，单位是4字节，4bit 可表示的最大值是 15，一个单位表示的长度是4字节，所以首部长度最大可以是 <code>15 x 4字节</code>，也就是 60 字节。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdcdaf4143b24fec988ce4d8f27ed48c~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h4 id="保留">保留</h4>
<p>顾名思义，是保留位，占用6个比特位，目前的值为 0。</p>
<h4 id="6个标志位">6个标志位</h4>
<p>协议中有 6 个比特标记位，可以理解为 TCP 段的类型。</p>
<p><strong>URG</strong></p>
<p>1个比特位，当被设置为1时，表明紧急指针字段有效，该报文段有紧急数据，应尽快发送。</p>
<p><strong>ACK</strong></p>
<p>当 ACK 设置为1时，确认号才有效，连接建立后，所有的报文段ACK都为 1。</p>
<p><strong>PSH</strong></p>
<p>当 PSH 设置为1时，接收方应该尽快将这个报文段交给应用层，而不再等待整个缓存填满再交付。</p>
<p><strong>RST</strong></p>
<p>当 RST 为1时，表示连接出现严重错误，必须重新建立连接。</p>
<p><strong>SYN</strong></p>
<p>在建立连接时用到。</p>
<p>当SYN=1,ACK=0时，表明这是一个连接请求报文段。</p>
<p>当SYN=1,ACK=1时，表明对方同意连接。</p>
<p><strong>FIN</strong></p>
<p>用来释放一个连接窗口。当FIN=1时，表明此报文段的发送方不再发送数据，请求释放单向连接。TCP断开连接用到。</p>
<h4 id="窗口大小">窗口大小</h4>
<p>大小为2个字节，表示发送方自己的接收窗口，用来告诉对方允许发送的数据量，最大为65535字节。</p>
<h4 id="检验和">检验和</h4>
<p>校验和是必需的，是一个端到端的校验和，由发送端计算，然后由接收端验证。其目的是为了发现TCP首部和数据在发送端到接收端之间发生的任何改动。如果接收方检测到校验和有差错，则TCP段会被直接丢弃。</p>
<h4 id="紧急指针">紧急指针</h4>
<p>占2字节，当URG=1时，紧急指针表示本报文段中的紧急数据的字节数，表示从这个 TCP段的序号开始的后的若干个字节是紧急数据，之后的就是普通数据。</p>
<p>假设此TCP段的序号为101，紧急指针为30，那就表示从 101开始，直到 131，【101，131】这个区间内为紧急数据。</p>
<h2 id="三次握手和四次挥手">三次握手和四次挥手</h2>
<p>数据要完成传输，必须要建立连接。由于建立TCP连接的过程需要来回3次，所以，将这个过程形象的叫做三次握手。</p>
<p>而连接断开的时候要经过四次数据传输，所以也被称为4次挥手。</p>
<p>啥都别说了，先看图吧。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66c23a7215f64e3098e1e8bd3b0fdeb4~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h3 id="三次握手建立连接">三次握手，建立连接</h3>
<p>结合上面的图来看更清楚。</p>
<p>先说三次握手吧，连接是后续数据传输的基础。就像我们打电话一样，必须保证我和对方都拿着电话在听，才能保证我们两个说的话对方能够接收到。</p>
<p>三次握手大概就是这个意思：</p>
<p>张三想跟李四聊聊天，于是张三拨通了李四的手机号，李四听到铃声响起，按了接听按钮。</p>
<p>张三：Hi，李四，是你吗？唠两块钱的呀！</p>
<p>李四：Hi，张三，是我，可以唠。</p>
<p>张三：好，我确定是你了，接下来我要开始和你唠了。</p>
<p>看上去多少有点儿死板，但程序上确实就是这样的。</p>
<p><strong>1、第一次握手</strong></p>
<p>首先客户端发起连接请求，向服务器发送 TCP段，段中包含了目标端口和本机端口，设置 SYN 标志位为1，序号为 x，也就是初始序号 ISN，如果是第一个连接，很有可能就是 0。当然，此时服务器对应的端口要处于监听状态。此时，客户端进入 SYNC_SENT 状态，等待服务器的确认。</p>
<p><strong>2、第二次握手</strong></p>
<p>服务端收到客户端发来的 SYN 段，对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)，这就是确认序号。同时，服务端还要发送 SYN 请求信息，将SYN位置为1，Sequence Number为 y（服务端的TCP段序号）。服务器端将上述所有信息放到一个TCP段（即SYN+ACK段）中，一并发送给客户端，此时服务器进入SYN_RECV状态。</p>
<p><strong>3、第三次握手</strong></p>
<p>客户端接收到服务端发来的 SYN+ACK 段后，发送一个 ACK 给服务端，将 Acknowledgment Number 设置为 y+1。此时客户端进入 ESTABLISHED（已连接）状态，服务端接收到此 TCP段，也将进入 ESTABLISHED 状态，也就标志着三次握手结束，连接成功建立。</p>
<p>三次握手完成之后，连接就建立了，之后就可以愉快的传输数据了。</p>
<h3 id="四次挥手江湖再见">四次挥手，江湖再见</h3>
<p>一旦有了感情（连接），再分手就难了，难到需要四次挥手。不像 UDP 那样，没有连接，说分就分。</p>
<p>当客户端和服务端双方发送数据完成后，一般会由客户端主动发起断开连接的请求，当然，也有少数情况是服务端主动发起。</p>
<p>以最常见的客户端发起断开连接为例，说一下四次挥手的过程。</p>
<p><strong>1、第一次挥手</strong></p>
<p>客户端设置序号（Sequence Number）和确认序号（Acknowledgment Number），发送一个 FIN 段给服务器。这时，客户端进入 FIN_WAIT_1状态，意味着客户端没有数据要发送了。</p>
<p><strong>2、第二次挥手</strong></p>
<p>服务端收到 FIN 报文段，向客户端发送一个 ACK 段，客户端进入 FIN_WAIT_2 状态。表示服务端已同意连接关闭请求。</p>
<p><strong>3、第三次挥手</strong></p>
<p>服务端向客户端发送 FIN 段，请求关闭连接，同时服务端进入 LAST_ACK 状态。</p>
<p><strong>4、第四次挥手</strong></p>
<p>客户端收到服务端发来的 FIN 段，向服务端发送 ACK 段，之后客户端进入TIME_WAIT状态。服务端收到客户端的ACK 段以后，就关闭连接。</p>
<p>上面就是由客户端主动发起关闭连接的过程。</p>
<h3 id="半关闭状态">半关闭状态</h3>
<p>TCP 是一个全双工的字节流服务，意思就是说两个端点都可以同时发送和接收消息。</p>
<p>正常情况下需要四次挥手才能完成连接的完全断开。但是有一种情况是这样的，只主动关闭自己到对方的连接，但是对方还是可以给自己发送数据。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ede4d31feef84a349b3ace62397e57ef~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="用-wireshark-抓住-tcp">用 WireShark 抓住 TCP</h2>
<p>Wireshark 是帮助我们分析网络请求的利器，建议每个同学都装一个。我们先用 Wireshark 抓取一个完整的连接建立、发送数据、断开连接的过程。</p>
<p>我这儿只简单的介绍一下操作流程。</p>
<p>1、首先打开 Wireshark，在欢迎界面会列出当前机器上的所有网口、虚机网口等可以抓取的部件。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a22fe57fc81246078177720ef00d7c1d~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>2、我接下来要用 Telnet 连接一个外网服务器，所以我选择第一个 WI-FI:en0，这样 Wireshark 就会捕获我连接的 wifi 上的网络传输。</p>
<p>3、我只想要抓一下最简单的 TCP 连接、发数据、断开的过程，所以要做一下抓取过滤。Wireshark 中的过滤器可以实现这样的需求。在下图红框部分可以选了一个过滤器。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/646367ea6257466097d6f046439ed33d~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>4、因为当前没有直接可用的符合要求的过滤器，所以，需要自己写一个。点击前面的绿色书签图标，然后在弹出窗口中点击加号添加一个。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de380b7952d74b75898f5e25dd8a7911~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>内容如下，语法就不解释了，一看就知道。</p>
<pre tabindex="0"><code>tcp and host 你的远程ip
</code></pre><p>5、选择好刚添加的这个过滤器，双击wifi这个 interface 进入就开始捕获了。</p>
<p>6、我用 telnet 连接这台服务器的 6379 端口 <code>telnet ip 6379</code>，因为这台服务器上装着 redis，可以模拟发数据。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad7c53277bee41658421eaf7e0b678cf~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>在控制台中连接到 6379 端口成功，然后在 Wireshark 上马上捕获到了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d17fef11da044e8b869d38054cdc2db1~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>这就是三次握手的过程。</p>
<p>7、然后直接关掉终端，这样会自动触发断开连接，并且发送最少的数据，方便我们观察。整个的过程都被 Wireshark 完整的捕捉到了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/581209c810bf47c4bb361c54b03328bc~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>第一部分是连接建立的三次握手，第二部分是发了长度为 1个字节的数据，第三步是客户端主动发起的断开连接的四次挥手过程。</p>
<h3 id="wireshark-简单介绍">Wireshark 简单介绍</h3>
<p>有图先看图</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a82bfc84c42f43f7984bf78adc51af0b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p><strong>概览信息</strong></p>
<p>也就是图中最上面的红色框部分。这一次的连接建立和中断一共产生了来回 8 次的请求，每次请求会在列表上列出时间、源端IP、目的端IP、以太网帧长度以及概览信息，包括数据传输方向（源端口-&gt;目标端口）、标记情况、序号、确认序号、窗口大小等等。</p>
<p><strong>以太网帧</strong></p>
<p>在每次请求信息中，还包括以太网帧，因为信息最终都会通过帧的形式发送出去。</p>
<p><strong>IP数据报</strong></p>
<p>还有 IP 数据报内容，其中包含了源端 IP 和 目的端 IP 等信息。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d30d2f0d678c49338b87a18c25750874~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p><strong>TCP段</strong></p>
<p>TCP 段当然是重点了，其中包含了 TCP 协议中的所有信息，包括端口号、</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7b932c9224046fc9667ed0fb77752aa~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="粘包半包">粘包、半包</h2>
<p><strong>MTU是什么</strong></p>
<p>MTU 全称是最大传输单元，一个在网络上传输的包不能无限大，MTU 一般是对于链路层而言的，拿以太网来说，在链路层允许发送的最大的以太网帧的数据部分就是 1500字节。注意是以太网帧的<strong>数据部分</strong>，再加上以太网帧的头部，会大于1500字节。</p>
<p>通过 <code>ifconfig</code>（windows 系统是 ipconfig）可查看本机各个网络接口（网卡）的MTU 大小。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4f60ecef46943948c6e4bfcc4a65c4f~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p><strong>MSS是什么</strong></p>
<p>MSS 指TCP最大报文长度，是TCP协议定义的一个选项，MSS选项用于在TCP连接建立时，收发双方协商通信时每一个报文段所能承载的最大数据长度。还是用以太网为例，MTU是 1500字节，减去TCP头（20字节）和IP头（20字节），就是MSS 1460字节。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6f3ebebe61f4a19bf2dd7fb2e7c92dc~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h3 id="粘包">粘包</h3>
<p>粘包就是将几个比较小的 TCP 包合并成一个包，这样就只发送一次就可以将多个小包发送出去。例如下面这样，一个TCP报文请求中，包含小包A、B、C，每一个小包原本都是一个TCP报文。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a718ab33ca1b43b29bb5bdf48b60639c~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>为什么要粘包呢？一个一个发送不行吗？</p>
<p>其实是可以的，只不过在多数情况下来一个包马上就发送可能会造成网络拥塞，一个TCP 报文传输到链路层的时候，会加上TCP头和IP头，占用40字节，如果发送的数据内容很小，比如只有1个字节，为了这一字节的内容，要有40倍的额外的信息被传输，是不是有点浪费。</p>
<p>为了减少这种浪费，TCP 协议就做了一些优化，比如 Nagle 算法：</p>
<ul>
<li>Nagle 算法规定每次只有收到上一个包的确认（ACK）之后，才会发送下一个包，在这个时间段内正好将小的包粘到一起；</li>
<li>但是太多的包也不行，大小不能超过 MSS ，也就是前面刚说的 1460字节，太大了装不下；</li>
<li>如果没有那么多小包，也不能一直等着，有一个超时时间，大约是200ms，超过这个时间也要发送；</li>
</ul>
<p>由于现在的宽带和设备性能的提升，Nagle 算法其实可以关闭了，有些设备上默认就是关闭的，也可以在写 Socket 的代码的时候主动关闭掉，关闭之后呢，只要接收端处理能力够快，可以保证来一个包马上发送，对那些要求实时反馈的应用来说尤其重要。</p>
<p>那来一个包发一个包，是不是就不会有粘包的问题了？也不是，这就要看接收端的处理能力了，接收端会有一个接收缓冲区，来不及被应用程序处理的会暂时放到这里，如果应用程序处理能力较差，这里还是会出现粘包。</p>
<h3 id="拆包">拆包</h3>
<p>既然发生了粘包，就要把这些大包拆成小包。怎么拆分其实都是上层应用的事儿了，核心要点就是约定好分隔符。举个简单的例子，比如说将包A和包B用一个特殊字符 <code>$</code>分隔开，那应用在拆包的时候就要根据这个特殊字符进行分隔。当然了，真实情况要比这个复杂的多，如果你用过 Netty，就会发现 Netty 提供了多种处理粘包拆包的方式。</p>
<h3 id="什么是半包">什么是半包</h3>
<p>粘包是为了将多个小包变成一个大包，而半包是把超大包拆成小包。比如下图，假设包B是一个很大的包，已经超过了MSS 了，单单发送它自己都发不过去了，所以只能将它拆开，一部分一部分的发送。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6dd02633ce2940b5a4ac61555e9fe717~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>半包就没那么复杂了，纯粹是因为单独的包太大，协议不支持这么大的包，只能拆开。</p>
<p>这样一部分一部分的包，到了接收端之后就要将其合并为一个整体，合并也比较简单，就是如果这个部分包没有开始或没有结束标志，就表示它不是完整的，需要给其找到对应的其他部分。</p>
<h2 id="滑动窗口">滑动窗口</h2>
<p><strong>接收方通告的窗口</strong>称为 offered window，意思就是说我这边可以接受的最大字节数为这么多。例如下图中的红框部分为 offered window， 大小为 6 字节，发送端最大一次只能发送 6 个字节，要不然接收方就没有能力接收了。</p>
<p><strong>可用窗口</strong> = offered window - 已经发送但未被确认的字节大小，这个值由发送方自己计算。前面说了三次握手，发送方发出去包，接收方接到后会反回一个 ACK，发出去但未收到ACK的数据也会占用窗口，表明接收方正在处理，所以，可用窗口的大小是 offered window 减去未收到 ACK 的大小。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7239584a23fb42d8918028aa919d8c00~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>为什么叫滑动窗口呢，看上面的图，把一个个字节想象成排成一排的格子。</p>
<p><strong>首先看时刻1</strong>：红色格子的部分就是offered window，大小为6字节，后面10、11、12字节因为没在窗口内，所以不能发送。已发送但未被确认的也占用窗口大小，所以最终可用窗口就是 7、8、9这三个字节。</p>
<p>**再看时刻2：**刚才未被确认的 4、5、6字节收到了 ACK，所以1-6都变成了过去式，然后窗口覆盖到了7、8、9、10、11、12 这6个字节，对比时刻1和时刻2，给我们的感觉就是窗口（红色格子）向右滑动了，这就是所谓的滑动窗口了。</p>
<p>还有，窗口两个边沿的相对运动增加或减少了窗口的大小。</p>
<ul>
<li>
<p>当窗口左边沿向右边沿靠近为窗口合拢。这种现象发生在数据被发送和确认时，假设现在接收方处理数据的时间变长了，来不及快速处理，那接收方在下次ACK的时候返回的窗口大小可能就会变小。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42dd5a467e86426e9ab199f59cdd36e7~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
</li>
<li>
<p>当窗口右边沿向右移动时将允许发送更多的数据， 我们称之为窗口张开。 这种现象发 生在另一端的接收进程读取已经确认的数据并释放了 TCP的接收缓存时。</p>
</li>
</ul>
<h2 id="慢启动和拥塞避免算法">慢启动和拥塞避免算法</h2>
<p>在使用 TCP 传输的过程中，肯定是希望数据传送的越快越好，但是在实际使用场景中，由于发送端和接收端处理数据的速度不一致，或者由于中间路由器性能限制、带宽限制等原因，发送的速度越快，越有可能导致丢包的情况。比如一下子发送了10M的数据出来，但是中间路由器只能处理 5 M，很可能就会把一些包丢弃。</p>
<p>因而设计了慢启动和拥塞避免算法，这两个设计都是为了合理的匹配发端的发送速度与收端的处理速度。</p>
<h3 id="慢启动">慢启动</h3>
<p>在连接刚建立的时候，发送端也不知道应该按什么速度发比较合适，所以就采用了一种渐进式的方式，就是慢启动的方式。</p>
<p>前面说了 offered window 是接收端的，在发送端也有一个窗口，叫做拥塞窗口，记做 cwnd，拥塞窗口初始化为 1 ，表示 1个报文段，也就是允许发送1个报文段，之后每当每当收到接收端返回的 ACK 时，就将 cwnd 的值加1。第一次发送一个数据报，当收到 ACK 后，cwnd 变为2，然后下一次发送两个数据报，当收到这两个数据报的 ACK 时，cwnd 就变成 4 。以此类推，这个增长是呈指数级的。</p>
<p>但是，在这个过程中，也是有限制的，发送的数据报大小要在消息接收端返回的通告窗口大小和 cwnd 中取较小的那个值。假设一个报文大小为 1024 字节，当 cwnd 为2，通告窗口大小为 4096 字节时，那发送端你可以连着发送2个数据报，也就是取 cwnd 的值，当 cwnd 为8 时，通告窗口大小仍然为 4096 字节时，那发送端最多可连续发送 4 个数据报，也就是不能超过 4096 字节。</p>
<h3 id="拥塞避免">拥塞避免</h3>
<p>拥塞避免算法其实和慢启动是在一起使用的。在慢启动中除了有拥塞窗口外， 还有一个叫做启动门限（ssthresh）的参数。启动门限默认的是 65535 字节。</p>
<p>在慢启动中，cwnd 是呈指数级增长，但是这个增长速度太快了，所以，拥塞避免算法就是让这个增速减缓的方式。</p>
<p>当 cwnd &lt; ssthresh 的时候，就使用慢启动。</p>
<p>当 cwnd &gt; ssthresh 的时候，就启动拥塞避免算法。</p>
<p>拥塞避免算法保证当 cwnd 超过限制之后，每次收到一个确认时将 cwnd 增加 1/cwnd。</p>
<p>当拥塞发生时（超时或收到重复确认），ssthresh 被设置为当前窗口大小的一半（cwnd和接收方通告窗口大小的最小值，但最少为 2个报文段）。</p>
<p><strong>用一张图来说明慢启动和拥塞避免算法</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e475ac6088a4775b86fd820a06ad5c9~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>假定当 cwnd 为32个报文段时就会发生拥塞。于是设置 ssthresh 为1 6个报文段， 而 cwnd 为1个报文段。 在时刻 0发送了一个报文段， 并假定在时刻 1接收到它的 ACK，此时 cwnd 增加为2。接着发送了2个报文段，并假定在时刻 2接收到它们的 ACK，于是 cwnd 增加为4 （对每个 ACK 增加1次）。这种指数增加算法一直进行到在时刻 3和4之间收到8个A C K后 cwnd 等 于 ssthresh 时才停止，从该时刻起，cwnd 以线性方式增加，在每个往返时间内最多增加 1个报 文段。</p>
<p>正如我们在这个图中看到的那样， 术语“慢启动”并不完全正确。 它只是采用了比引起 拥塞更慢些的分组传输速率， 但在慢启动期间进入网络的分组数增加的速率仍然是在增加的。 只有在达到 ssthresh 拥塞避免算法起作用时，这种增加的速率才会慢下来。</p>
<h2 id="重传机制">重传机制</h2>
<p>什么情况下要重传，当发送端认为丢包了就要重传，有两种情况下发送端就认为丢包了，于是就会发起重传。</p>
<h3 id="超时重传">超时重传</h3>
<p>发送端在一段时间（超时时间）后没有收到发送端返回的 ACK ，就认为这个包丢了，这个超时时间并不是固定的。</p>
<p>这里面有两个概念，RTT 和 RTO。</p>
<ul>
<li>
<p>RTT（Round Trip Time）：往返时延，也就是数据包从发出去到收到对应 ACK 的时间。RTT 是针对连接的，每一个连接都有各自独立的 RTT。</p>
</li>
<li>
<p>RTO（Retransmission Time Out）：重传超时，也就是前面说的超时时间。</p>
</li>
</ul>
<h3 id="快速重传">快速重传</h3>
<p>接收端回复的 ACK 会带着包的序号，当接收端重复三次收到同一个序号的ACK时，就要重传这个包；</p>
<p>比如下面图中画的这样：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d85f32a261443fe9c9c597d5a78d3b2~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>1、seq=1的包发过去，接收端ACK=2，表示期望下次出现的序号为2，然后发送端就发了 seq=2的包，接收端接到后回复 ACK=3，表示期望下次收到序号为3的包，这是发送端第一次收到 ACK=3;</p>
<p>2、发送端继续发送 seq=3 的包，但是这个包可能传输的比较慢（比如路由选择的不好），接收端一直没收到；</p>
<p>3、发送端先不管，继续发送 seq=4 的包，接收端收到后，回复ACK，正常情况下应该是 ACK=5，但是序号为3的包还没收到，所以再次回复ACK=3，这是第二次收到ACK=3；</p>
<p>4、发送端继续不管，接着发送 seq=5的包，接收端收到后，回复ACK，正常情况下应该是 ACK=6，但是序号为3的包还没收到，所以再次回复ACK=3，这是第三次收到ACK=3；</p>
<p>到目前为止，已经收到三次 ACK=3了，然后发送端就重新发送 seq=3的包，这时候就当做这个包已经丢了。这就是快速重传。</p>
]]></content:encoded></item><item><title>5. 为什么说 ICMP 协议是网络最强辅助</title><link>https://moonkite.cn/category/network/ICMP/</link><pubDate>Tue, 28 Feb 2023 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/network/ICMP/</guid><description>轻解计算机网络已有高清 PDF 版本可以离线阅读了，全册 65 页，如果有需要离线版的高清 PDF 可以直接下载。 ICMP 全称互联网控制报文协议（Internet Cntrol Message P</description><content:encoded><![CDATA[<p>轻解计算机网络已有高清 PDF 版本可以离线阅读了，全册 65 页，如果有需要离线版的高清 PDF 可以<a href="https://pan.baidu.com/s/10LH_5afGftayMo8Q1Io_gA?pwd=f8hp">直接下载</a>。</p>
<p>ICMP 全称互联网控制报文协议（Internet Cntrol Message Protocol），是网络层的重要协议。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20221220173724892.png" alt=""></p>
<h2 id="icmp-是干啥用的">ICMP 是干啥用的</h2>
<p>它到底是用来干啥的呢？为啥叫控制报文协议，控制的是什么？</p>
<p>ICMP 分为查询报文和差错报文两大类。查询报文是我们主动发起的，比如ping命令；而差错报文是在发生差错之后要发给源端的，这都是互联网协议模型约定好的。</p>
<p>ICMP的差错报文反馈发生在通信环境中的遇到的各种问题。通过这些信息，使管理者可以对所发生的问题作出诊断，然后采取适当的措施解决。</p>
<p>ICMP的差错报文是整个数据传输链路中非常重要的一个环节。打个比喻，差错报文就是一个只报告坏消息的信使，当数据包在网络中一路畅通的时候，ICMP 差错报文就像隐身了一样，你根本不会知道它的存在，一旦数据包在网络中碰到了各种各样的障碍，这个信使就出来活动了，它的目的只有一个，就是把这个数据包遭遇的不测通知给发送端，但是话术就那么20多种（对应差错代码）。</p>
<p>比如下面两个场景，想必你也有点熟悉吧。</p>
<ul>
<li>
<p>当路由器收到一份IP数据报但又不能转发时，就要发送一份 ICMP「主机不可达」差错报文。</p>
</li>
<li>
<p>当IP数据报应该被发送到另一个路由器时，收到数据报的路由器就要发送 ICMP「重定向」差错报文给IP数据报的发送端。</p>
</li>
</ul>
<h2 id="icmp-协议说明">ICMP 协议说明</h2>
<p>虽然工作在网络层，看上去和 IP 协议是并列的，但是 ICMP 报文要附加 IP 头，一般被 IP 层或者更高层的协议（例如TCP或UDP）使用。很少有应用程序直接使用 ICMP 协议，除了 <code>ping</code>、<code>traceroute</code>。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20221220174122068.png" alt=""></p>
<h3 id="icmp-协议格式">ICMP 协议格式</h3>
<p>ICMP 协议格式和 IP 协议、TCP 协议这些比起来，那还是非常简单的。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20221220184548013.png" alt=""></p>
<p><strong>类型</strong></p>
<p>类型字段占用 8 位，主要定义报文的大类，比如类型为 3 统一表示的是<code>不可达</code>，而具体原因是什么则要由代码字段决定。</p>
<p><strong>代码</strong></p>
<p>代码字段同样占用 8 位，代码字段其实就是类型下的子类型，比如上面说了类型为 3 是不可达，代码为 0 表示网络不可达，代码为 1 表示主机不可达。</p>
<p><strong>检验和</strong></p>
<p>用于错误检查，和 IP 协议的检验和的作用一致。</p>
<p><strong>内容</strong></p>
<p>因为类型和代码不同，表示产生差错的原因不同，不同的原因都要有对应的描述，内容这部分就是用来描述产生差错的原因的。</p>
<p>接下来会举几个例子说明。</p>
<p>下面这张图是 ICMP 的分类，包括查询报文和差错报文，需要原始 Excel 的同学可以回复 <code>ICMP</code>获取源文件。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20221220154258361.png" alt=""></p>
<h3 id="目的不可达差错报文">目的不可达差错报文</h3>
<p>目的不可达是网络传输中经常遇到的问题，各位在开发的过程中可能也碰到过，尤其是做网络编程的时候，经常会碰到，比如连错IP了，比如端口设置错了。</p>
<p>通过上表可知，当类型为 3 的时候，都是不可达的错误，而代码可以从 0 -15，也就是说有16种不可达的具体原因。这种情况下的协议格式是下面这样的。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20221221142236231.png" alt=""></p>
<p>类型为 3 ，代码 0 - 15。检验和后面有 4 个字节的空间是不使用的，但是必须为0 ，没理由，就这样。</p>
<p>前面说到了内容部分是根据类型和代码不同而不同的。如果是目的不可达，也就是类型是 3 的情况下，内容分为两部分，IP首部和原始IP数据报中数据部分的前 8 个字节。</p>
<p><strong>原始IP数据报中数据部分</strong>指的就是TCP或者UDP这些网络层之上的协议，拿 TCP 来说，TCP 是传输层的，当 TCP 数据报到达网络层，会加上 IP 首部，变成一个 IP 数据包。所以这里说的数据部分就是 TCP 数据报，但是这个数据报可能很大，所以只用前  8 个字节就够了，因为前8个字节包含的信息已经足够用了。</p>
<p>回想一下 TCP 协议的格式，前 8 个字节就是下图红框部分，包含源端口和目的端口以及序号。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20221221150234847.png" alt=""></p>
<p>例如代码为 3 的时候，差错信息是端口不可达，那有了 TCP 协议的前8个字节就能知道导致这个错误的原始数据报文中的目的端口是多少，不可达的端口也就是这个端口。也可以知道原始报文的源端口是多少，有了源端口号就知道这个数据包是哪个用户进程发出来的，就可以交给这个进程对这个差错及时进行处理了。</p>
<blockquote>
<p>源端口号是关联用户进程的重要标示，比如我们开发了一个应用，这个应用占用了 8888和8898两个端口，如果安装了这个应用的机器收到了一个差错报文，而差错报文中的内容部分的原始数据包前8个字节拆解后，发现源端口是8898，那就知道这个要交给我们开发的这个应用去处理了。</p>
</blockquote>
<p>下面是一个端口不可达的差错报文，用 WireSharek 监测到的格式。</p>
<p>telnet 一个没有开放的端口即可获得 ICMP 端口不可达的差错报文。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20221221160828726.png" alt=""></p>
<h3 id="查询报文">查询报文</h3>
<p>将 ICMP 用作查询报文的场景比较少，用作查询报文的意思就像是使用 ARP 协议或者 TCP 协议这种，是我们主动发起的，只不过选了 ICMP 协议。</p>
<p>比如 <code>ping</code> 和 <code>traceroute</code>这两个，之后我们再讲，这两个比较有意思，对 ICMP 应用很巧妙。</p>
<p>另外，可以用作无盘系统启动过程中来获取自身的子网掩码。还可以用作向第三方系统查询当前的时间戳。</p>
<p>了解一下就可以了。</p>
<h2 id="有一些场景不发送差错报文">有一些场景不发送差错报文</h2>
<p>有些场景下是不发送差错报文的，这样做的目的是为了防止ICMP差错报文带来广播风暴。</p>
<ol>
<li>
<p>ICMP差错报文本身发生差错，是不会对差错报文再发送差错报文的。是不是读起来有点绕，TCP 、UDP 出错会发送差错报文，但是 ICMP差错报文在通知源端的过程出错了，那就不管了，要不然可能就没玩没了的发了，比如源端的网线断了。但是， ICMP查询报文可能会产生ICMP差错报文，比如ping命令在传输过程中出错了，源端会收到差错报文。</p>
</li>
<li>
<p>目的地址是广播地址或多播地址（D类地址）的IP数据报，不发送差错报文。</p>
</li>
<li>
<p>作为链路层广播的数据报，不发送差错报文，ARP 就是典型的链路层广播数据报。</p>
</li>
<li>
<p>不是IP分片的第一片，不发送差错报文。数据如果过长，网络层是会进行分片的，这些分片实际上还是同一个数据包的，这种情况下只对第一片发送差错报文，其他分片不管。</p>
</li>
<li>
<p>源地址不是单个主机的数据报，不发送差错报文。 源地址不能为零地址、环回地址、广播地址或多播地址。</p>
</li>
</ol>
<h2 id="总结">总结</h2>
<p>1、 ICMP 在网络层，但要加上 IP 首部；</p>
<p>2、ICMP 分为查询报文和差错报文，主要用到的还是差错报文；</p>
<p>3、ICMP 的差错报文就好像一个只通知坏消息的信息，当数据报在网络中出现问题的时候，及时告知源端，告知的内容包括原因以及产生错误的原始数据报的必要部分；</p>
<p>4、有一些情况是不会发送 ICMP 差错报文的，这样做是为了防止网络风暴；</p>
]]></content:encoded></item><item><title>6. 什么是 CDN</title><link>https://moonkite.cn/category/network/cdn/</link><pubDate>Tue, 28 Feb 2023 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/network/cdn/</guid><description>大家好，我是风筝 轻解计算机网络已有高清 PDF 版本可以离线阅读了，全册 65 页，如果有需要离线版的高清 PDF 可以直接下载。 当你在访问淘宝、京东准备剁手的时</description><content:encoded><![CDATA[<p><strong>大家好，我是风筝</strong></p>
<p>轻解计算机网络已有高清 PDF 版本可以离线阅读了，全册 65 页，如果有需要离线版的高清 PDF 可以<a href="https://pan.baidu.com/s/10LH_5afGftayMo8Q1Io_gA?pwd=f8hp">直接下载</a>。</p>
<p>当你在访问淘宝、京东准备剁手的时候，虽然进入页面的时候有很多的图片、很多的内容，但是加载起来却很快，让你剁手的动作如水般丝滑。嗖的一下好看的商品图片就出来了，嗖的一下就付款了。当然图片算是比较小的资源了，那些视频网站呢，每一个视频好几百M、好几个G，同时有好多的请求过来，就算服务器能抗住，带宽能跟的上吗？</p>
<p>难道就是靠大厂背后充足的服务器、宽带资源以及过硬的优化技术了吗？当然了，这肯定是必要的条件，除此之外就靠我们今天要说的 CDN 技术了。</p>
<h2 id="什么是-cdn">什么是 CDN</h2>
<p>CDN即内容分发网络（Content Delivery Network）的简称，是建立在承载网基础上的虚拟分布式网络，能够将源站内容（包括各类动静态资源）智能缓存到全球各节点服务器上。这样不仅方便了用户就近获取内容，提高了资源的访问速度，也分担了源站压力。</p>
<p>CDN(Content Delivery Network)是指内容分发网络，也称为内容传送网络，这个概念始于1996年，是美国麻省理工学院的一个研究小组为改善互联网的服务质量而提出的。为了能在传统IP网上发布丰富的宽带媒体内容，他们提出在现有互联网基础上建立一个内容分发平台专门为网站提供服务，并于1999年成立了专门的CDN服务公司，为Yahoo提供专业服务。由于CDN是为加快网络访问速度而被优化的网络覆盖层，因此被形象地称为“网络加速器”。</p>
<p>CDN 的核心就是加快网络访问速度，看下面这张图，不同地方的终端用户会访问到最近的 CDN 服务器，而 CDN 服务器上的内容是源服务器集群上的，不管是通过主动拉取还是被动接收的，总之数据内容是一致的，而且离用户最近，获取成本最小速度更快。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20201126152253207-20201126213204087.png" alt=""></p>
<p>现在国内一些比较有实力的大公司会自建 CDN 网络，用来提升服务性能，当然，成本也是很巨大的，想想看啊，方便用户就近获取内容就意味着要在各个地方建立内容节点服务器，就不说向全世界提供服务，就面向整个中国，就要有多少个节点吧。</p>
<p>好在现在很多国内云服务提供商都有 CDN 服务，可以大大降低自建 CDN 的成本。</p>
<h2 id="使用场景">使用场景</h2>
<p>从 CDN 含义本身分析，内容分发网络嘛，肯定是需要快速获取内容的场景才需要 CDN。这些内容包括以下这些：</p>
<ol>
<li>网站中的静态资源文件，比如图片、js 脚本、样式文件等小文件；</li>
<li>大文件，比如一些软件下载站、一些视频、图像资源下载站等；</li>
<li>在线音频、视频网站，比如网易云音乐、腾讯视频等；</li>
</ol>
<p>比如我打开天猫商城看了一下，看到其中很多静态文件都来自于不同的域名，有很多域名中带着 CDN 字样，明显都是来自于 CDN 节点的。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20201126212257681.png" alt=""></p>
<p>那都是静态文件啊，动态内容能不能也放到 CDN 上呢？那这就变味儿了，CDN 只放静态内容可以快速简单的实现，如果加入动态内容，那不就成了多机房分布式部署了吗。倒也不是没有折中的办法，<strong>边缘计算</strong>就是这样一种策略，边缘节点既能做 CDN，也具备一些计算能力，可以有一些简单的动态执行能力。这就不在讨论的范围之内了。</p>
<p>如果你做过前端开发的话，可能用过一些 JavaScript 开发CDN，比如七牛云和又拍云等等。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20201127093905091.png" alt=""></p>
<h2 id="原理">原理</h2>
<h3 id="没有-cdn-的请求路径">没有 CDN 的请求路径</h3>
<p>在没有 CDN 的情况下，一次资源请求的路径是什么样子的呢。</p>
<p>1、首先用户在浏览器输入域名，比如进入天猫主页；</p>
<p>2、用户所在的电脑查询 hosts 中看是否有对应的 IP ，如果有就直接请求 IP；</p>
<p>3、如果没有在本地缓存，则向本地 DNS 发起请求，本地 DNS 查找域名对应的 IP（一般是 A 记录）；</p>
<p>4、如果本地 DNS 没有找到，则向上级 DNS 服务器请求，一级一级的知道查到最顶级 DNS 服务器；</p>
<p>5、向找到的域名对应的 IP 发起请求；</p>
<p>6、资源所在的集群向客户端返回请求的资源，比如图片、样式文件、视频文件等；</p>
<h3 id="有了-cdn-之后">有了 CDN 之后</h3>
<p>当有了 CDN 接入之后，事情就稍微变得复杂了一点。</p>
<p>1、用户在浏览器输入域名，比如进入天猫主页；</p>
<p>2、用户所用的电脑向本地 DNS 服务器请求，查询域名的IP地址；
3、本地 DNS 服务器中如果缓存有这个域名的记录，则直接响应用户的解析请求，否则本地DNS向根DNS 查询域名的授权服务器；
4、根DNS将域名授权DNS记录返回给本地DNS；
5、本地 DNS 得到域名的授权DNS记录后，继续向域名授权DNS查询域名的IP地址；
6、域名授权DNS查询域名记录后(一般是CNAME)，返回给本地DNS；
7、本地DNS得到域名记录后，向智能DNS查询域名的IP地址；
8、智能DNS根据一定的算法和策略(比如静态拓扑，容量等)，将最合适的CDN节点IP地址返回给 本地DNS；
9、本地DNS将得到的域名IP地址，返回给用户终端；
10、用户得到域名IP地址后，访问站点服务器；
11、CDN节点服务器应答请求，将内容返回给客户端，CDN服务器同时在本地进行保存，以备下次使用。</p>
<p>下面的流程图画出了整个请求过程。</p>
<p><img src="https://hexo.moonkite.cn/blog/cdn%E6%B5%81%E7%A8%8B.png" alt=""></p>
<p>大致的流程就是上面的样子，真实情况下，智能 DNS 可能更加复杂一些。因为一个地区的 CDN 很可能不是单纯的一台机器或一个集群，而是一个小范围的分布式部署。</p>
<p>比如全国范围内是一个大的 CDN 网络，那智能 DNS 其实就是一个智能负载均衡器，它会根据一系列的指标，比如地理位置、线路等情况返回一个 IP 地址，这个地址可能并不是一个 CDN 服务器的 IP，而是一个小范围的智能负载均衡器地址，这个负载均衡器可能协调的某一个省的 CDN 节点，当定向到这个负载均衡器之后，又会根据一系列的指标，将返回一个最合适的 CDN 节点的 IP 给客户端。</p>
<h2 id="cdn-核心部件">CDN 核心部件</h2>
<h3 id="智能-dns">智能 DNS</h3>
<p>智能调度DNS是CDN服务中的关键系统，当用户访问加入CDN服务的网站时，域名解析请求将最终由 “智能调度DNS”负责处理。它通过一组预先定义好的策略，将当时最接近用户的节点地址提供给用户，使用户可以得到快速的服务。同时它需要与分布在各地的CDN节点保持通信，跟踪各节点的健康状态、容量等信息，确保将用户的请求分配到就近可用的节点上。</p>
<h3 id="缓存功能服务">缓存功能服务</h3>
<h4 id="负载均衡器">负载均衡器</h4>
<p>CDN 节点通常都是以集群或者区域集群的形式存在的，负载均衡器可以将请求分派到最合适的 CDN 服务器上。负载均衡器可能是硬件 F5，也可能是 LVS、HA、Nginx 等软件形式。</p>
<h4 id="内容缓存服务器">内容缓存服务器</h4>
<p>CND 提供的就是内容加速，当然要有地方存内容了。如果是小的静态文件还好，如果是大的视频文件等，那对大容量的存储和高速读也是有一定要求的。</p>
<h3 id="内容管理服务">内容管理服务</h3>
<p>最开始内容都是存储在源服务器中的，那总得想办法让内容存储到各个 CDN 节点上。那通过什么方式呢，最简单的办法就是当客户端访问的某个 CDN 之后，发现里面没有需要的内容，就到源服务器上去拉取。</p>
<p>内容传输可以有两种模式，一种推模式，一种拉模式。推模式是源服务器像各个 CDN 节点主动推送，这种方式就比较灵活了，但是实现比较复杂，假设有个管理控制台，管理员选择某些需要推送的文件，然后选择需要推送的 CDN 节点，点击推送按钮，将文件主动推送过去。</p>
<h2 id="指标">指标</h2>
<h3 id="通用指标">通用指标</h3>
<p>衡量 CDN 服务的性能有如下几个指标：</p>
<ul>
<li>延时：指一个数据包从用户的计算机发送到网站服务器，然后再立即从网站服务器返回用户计算机的来回时间。延时越低，性能越好。</li>
<li>下载速度：指用户从网络上或者网络服务器上下载的数据时的传输速度。下载速度越快，性能越好。</li>
<li>打开速度：指用户打开网站的速度。打开速度越快，性能越好。</li>
<li>丢包率：指用户在网络传输中所丢失数据包数量占所发送数据组的比率。</li>
<li>回源率：回源率分为回源请求数比例及回源流量比例两种。
<ul>
<li>回源请求数比：指边缘节点对于没有缓存、缓存过期（可缓存）和不可缓存的请求占全部请求记录的比例。越低则性能越好。</li>
<li>回源流量比：回源流量是回源请求文件大小产生的流量和请求本身产生的流量。所以回源流量比=回源流量/（回源流量+用户请求访问的流量），比值越低，性能越好。</li>
</ul>
</li>
<li>缓存命中率：指终端用户访问加速节点时，该节点已缓存了要被访问的数据的次数占全部访问次数的比例。缓存命中率越高，性能越好。</li>
</ul>
<h2 id="好处">好处</h2>
<p>1、本地Cache加速，提高了企业站点（尤其含有大量图片和静态页面站点）的访问速度，并大大提高以上性质站点的稳定性；
2、镜像服务消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量；
3、远程访问用户根据DNS负载均衡技术，智能自动选择Cache服务器，选择最快的Cache服务器，加快远程访问的速度；
4、带宽优化：自动生成服务器的远程Mirror（镜像）cache服务器，远程用户访问时从cache服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点WEB服务器负载等功能；
5、集群抗攻击：广泛分布的CDN节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种DDos攻击对网站的影响，同时保证较好的服务质量 。</p>
]]></content:encoded></item><item><title>7. 轻解计算机网络系列离线高清 PDF 下载</title><link>https://moonkite.cn/category/network/%E8%BD%BB%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%A6%BB%E7%BA%BFPDF/</link><pubDate>Tue, 28 Feb 2023 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/network/%E8%BD%BB%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%A6%BB%E7%BA%BFPDF/</guid><description>一提到计算机网络，大部分同学想到的都是理论、枯燥、犯困，记不住，就算当时记住了，过两天也忘了。 我上大学的时候也是这样，以至于计算计算机网络这</description><content:encoded><![CDATA[<p>一提到计算机网络，大部分同学想到的都是理论、枯燥、犯困，记不住，就算当时记住了，过两天也忘了。</p>
<p>我上大学的时候也是这样，以至于计算计算机网络这门课程好像一直离我很遥远。</p>
<p>前些天，终于在离开大学多年后又重新学了一遍计算机网络，重新拾起了一部分，时至今日已略有小成，并且将学习过程中的笔记总结成册，取名《轻解计算机网络》，尽量用简单的语言和图片帮助大家从零开始理解计算机网络。</p>
<p>本小册先介绍如何学习计算机网络，分享了我的一些学习方法和经验，然后从宏观视角介绍了计算机网络的分层模型，接着深入到细节，用多张图的形式交接网络中特别重要的几个协议，最后再将前面的内容串起来，以路由表、转发表、ARP 表的视角再来理解数据是如何在网络世界传输的，这样用总-分-总的形式，帮助大家彻底理解计算机网络。</p>
<p>整体目录结构：
<img src="https://hexo.moonkite.cn/blog/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.jpg" alt="目录结构"></p>
<p>我们自己在学习网络的时候会遇到一些问题，比如学习某个概念的时候往往会牵扯出很多其他的概念，你开始的时候想理解一个点，理解的过程中会发现，要理解这个点，必须要理解其他的点，这好多的点就构成了一个面，必须来回穿插着学。</p>
<p>本小册也是这样，可能读前面的内容不是很理解，但是读到最后会发现前面的很多地方都通了。</p>
<p>如果有需要离线版的高清 PDF 可以到这里下载。</p>
<p><img src="https://hexo.moonkite.cn/blog/v2-35a00716051c612299a89f56308f7328_1440w.jpg" alt="img"></p>
]]></content:encoded></item><item><title>Java Stream 高级用法</title><link>https://moonkite.cn/category/java/Java-Stream-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</link><pubDate>Thu, 12 Jan 2023 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/java/Java-Stream-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</guid><description>因为最近做了一个小需求，数据量不大，功能也比较简单，但是计算维度非常多，大部分的计算逻辑其实都可以直接写 SQL 实现，但是那样的话性能就太差了，所</description><content:encoded><![CDATA[<p>因为最近做了一个小需求，数据量不大，功能也比较简单，但是计算维度非常多，大部分的计算逻辑其实都可以直接写 SQL 实现，但是那样的话性能就太差了，所以最终采用了在内存中直接计算，这时候 Stream 就有大用处了。</p>
<p>Java Stream 是 JDK 8 开始提供的一种函数式风格的集合操作方法。我之前写过一篇 <a href="https://mp.weixin.qq.com/s?__biz=MzAxMjA0MDk2OA==&amp;mid=2449469926&amp;idx=1&amp;sn=69167b936c8e42bb3bbdf0c79882553a&amp;chksm=8fbcbf81b8cb369785923acda2bd3f708360ebaf633d9ca0e02e5788e22d8161f5abba2dd3d8&amp;token=723642012&amp;lang=zh_CN#rd"> Java Stream 的文章 - 8000字长文让你彻底了解 Java 8 的 Lambda、函数式接口、Stream 用法和原理</a>，在掘金社区获得了超过 500 个赞，说明大家还是很喜欢用 Stream 的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5607342158c1409585bf1f6504d1ac53~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>上一篇主要介绍了一些基础用法，这一篇主要就介绍三个功能，<strong>排序、分组和 teeing</strong>，teeing 是 JDK 12 才出现的。</p>
<h2 id="排序">排序</h2>
<h3 id="基本数据类型排序">基本数据类型排序</h3>
<p>基本数据类型就是字符串、整型、浮点型这些，也就是要排序的列表中的元素都是这些基本类型的，比如 <code>List&lt;Integer&gt;</code>的。</p>
<p>下面就用一个整型列表举例说明。</p>
<p><strong>正序排序</strong></p>
<p>正序排序，也可以叫做按照自然顺序排序，对于整型来说就是从小到大的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">integerList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">integerList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">collect</span> <span class="o">=</span> <span class="n">integerList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">sorted</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">collect</span><span class="o">);</span>
</span></span></code></pre></div><p>输出结果是 <code>[0, 1, 2, 3, 4]</code>，这很简单没什么好说的。</p>
<p><strong>倒序排序</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">integerList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">integerList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">collect2</span> <span class="o">=</span> <span class="n">integerList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">sorted</span><span class="o">(</span><span class="n">Comparator</span><span class="o">.</span><span class="na">reverseOrder</span><span class="o">())</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">collect2</span><span class="o">);</span>
</span></span></code></pre></div><p>倒序排就是从大到小排序，也很简单在 <code>sorted()</code>方法中添加 <code>Comparator.reverseOrder()</code> 就可以了。</p>
<p><code>sorted()</code> 方法接收的参数是<code>Comparator</code> 函数式接口，在 <a href="https://mp.weixin.qq.com/s?__biz=MzAxMjA0MDk2OA==&amp;mid=2449469926&amp;idx=1&amp;sn=69167b936c8e42bb3bbdf0c79882553a&amp;chksm=8fbcbf81b8cb369785923acda2bd3f708360ebaf633d9ca0e02e5788e22d8161f5abba2dd3d8&amp;token=723642012&amp;lang=zh_CN#rd">8000字长文让你彻底了解 Java 8 的 Lambda、函数式接口、Stream 用法和原理</a> 这篇文章清楚的讲了函数式接口和方法引用，可以翻过去看看。</p>
<h3 id="非基本类型实体排序">非基本类型实体排序</h3>
<p>基本类型的列表排序很简单，但是在实际项目中用到的情况不太多，经常用到的还是我们自定义类型的排序，比如项目中有一个用户实体、一个订单实体、一个产品实体等。</p>
<p>首先定一个<code>Product</code>实体类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">lombok.Data</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @author fengzheng
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Data</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Product</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 唯一标示
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Integer</span> <span class="n">id</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 所属类别
</span></span></span><span class="line"><span class="cl"><span class="cm">      */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Integer</span> <span class="n">type</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 商品名称
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 价格
</span></span></span><span class="line"><span class="cl"><span class="cm">      */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Double</span> <span class="n">price</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h4 id="按某一个字段排序">按某一个字段排序</h4>
<p>对应到我上面定义的这个实体，可以是按照 <code>id</code> 排序，或者按照 <code>price</code>排序。</p>
<p><strong>正序排序</strong></p>
<p>假设按照 <code>price</code>从小到大排序，也就是按照价格由低到高排序。</p>
<p>对应到 SQL 上，可以表示成这样的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">product</span><span class="w"> </span><span class="k">order</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">price</span><span class="w"> </span><span class="k">asc</span><span class="w">
</span></span></span></code></pre></div><p>那用 Stream 实现呢？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">productList</span> <span class="o">=</span> <span class="n">initProductList</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">collect</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">sorted</span><span class="o">(</span><span class="n">Comparator</span><span class="o">.</span><span class="na">comparing</span><span class="o">(</span><span class="n">Product</span><span class="o">::</span><span class="n">getPrice</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></span></code></pre></div><p>等价于</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">collect</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">sorted</span><span class="o">((</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">.</span><span class="na">getPrice</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">y</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()))</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></span></code></pre></div><p>等价于</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">comparator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">Product</span> <span class="n">p1</span><span class="o">,</span> <span class="n">Product</span> <span class="n">p2</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">p1</span><span class="o">.</span><span class="na">getPrice</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">p2</span><span class="o">.</span><span class="na">getPrice</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">collect</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">sorted</span><span class="o">((</span><span class="n">p1</span><span class="o">,</span> <span class="n">p2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">comparator</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">p1</span><span class="o">,</span> <span class="n">p2</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></span></code></pre></div><p>这里面主要由我们提供自定义的就是函数式接口 <code>Comparator</code>，凡是实现了 compare () 方法的都可以。</p>
<p>上面我们自定义的这个 <code>comparator</code>，重载了 <code>compare</code>方法。compare 方法的返回值规则：</p>
<ol>
<li>前者小于后者，返回 -1；</li>
<li>前者大于后者，返回 1；</li>
<li>前者等于后者，返回 0；</li>
</ol>
<p>所以可以理解为，如果 compare 返回的是 1， Stream 就会交换两个实体的位置。所以这样一来，倒序排序就很好整了。</p>
<p><strong>倒序排序</strong></p>
<p>可以这样写，使用 reversed() 方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">collect</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">sorted</span><span class="o">(</span><span class="n">Comparator</span><span class="o">.</span><span class="na">comparing</span><span class="o">(</span><span class="n">Product</span><span class="o">::</span><span class="n">getPrice</span><span class="o">).</span><span class="na">reversed</span><span class="o">())</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></span></code></pre></div><p>或者可以</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">collect</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="na">sorted</span><span class="o">(</span><span class="n">Comparator</span><span class="o">.</span><span class="na">comparing</span><span class="o">(</span><span class="n">Product</span><span class="o">::</span><span class="n">getPrice</span><span class="o">,</span><span class="n">Comparator</span><span class="o">.</span><span class="na">reverseOrder</span><span class="o">()))</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></span></code></pre></div><p>还可以直接直接使用compare ，倒序排序就简单了，稍微改一下就好了。</p>
<p>直接用 <code>Lambda </code>表达式的写法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">collect</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">sorted</span><span class="o">((</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="o">.</span><span class="na">getPrice</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()))</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></span></code></pre></div><p>等价于，抽取出自定义 <code>Comparator</code>的方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">comparator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">Product</span> <span class="n">p1</span><span class="o">,</span> <span class="n">Product</span> <span class="n">p2</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">p2</span><span class="o">.</span><span class="na">getPrice</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">p1</span><span class="o">.</span><span class="na">getPrice</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">collect</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">sorted</span><span class="o">((</span><span class="n">p1</span><span class="o">,</span> <span class="n">p2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">comparator</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">p1</span><span class="o">,</span> <span class="n">p2</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></span></code></pre></div><p>倒序和正序的区别其实就是将 <code>compare()</code>前后两个元素的位置对调一下。</p>
<p>对于大小比较的可以直接用 <code>compare()</code>方法，但是有一些情况可能不止这么简单。没有关系，我们不是可以自定义 Comparator 吗，在 Comparator  重写的 compare 方法中可以加入我们的排序逻辑，不管多么特殊、多么复杂，只要返回一个 int 类型的就可以了。</p>
<h4 id="按照多个字段排序">按照多个字段排序</h4>
<p>还有一些情况要按照两个甚至多个字段排序，一个主排序，一个次要排序。比如我们想要先按 type 升序，再按 price 降序。</p>
<p>对应到 SQL 上就像这样</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">product</span><span class="w"> </span><span class="k">order</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="k">asc</span><span class="p">,</span><span class="n">price</span><span class="w"> </span><span class="k">desc</span><span class="w">
</span></span></span></code></pre></div><p>那用 Stream 来实现是怎么样的呢？用 <code>thenComparing</code>连接多个要排序的属性。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">collect</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">sorted</span><span class="o">(</span><span class="n">Comparator</span><span class="o">.</span><span class="na">comparing</span><span class="o">(</span><span class="n">Product</span><span class="o">::</span><span class="n">getType</span><span class="o">).</span><span class="na">thenComparing</span><span class="o">(</span><span class="n">Product</span><span class="o">::</span><span class="n">getPrice</span><span class="o">,</span> <span class="n">Comparator</span><span class="o">.</span><span class="na">reverseOrder</span><span class="o">())).</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></span></code></pre></div><p>或者还可以定义两个 Comparator</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">typeComparator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">Product</span> <span class="n">p1</span><span class="o">,</span> <span class="n">Product</span> <span class="n">p2</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">p1</span><span class="o">.</span><span class="na">getType</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">p2</span><span class="o">.</span><span class="na">getType</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">priceComparator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">Product</span> <span class="n">p1</span><span class="o">,</span> <span class="n">Product</span> <span class="n">p2</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">p2</span><span class="o">.</span><span class="na">getPrice</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">p1</span><span class="o">.</span><span class="na">getPrice</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">};</span>
</span></span><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">collect</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">sorted</span><span class="o">(</span><span class="n">typeComparator</span><span class="o">.</span><span class="na">thenComparing</span><span class="o">(</span><span class="n">priceComparator</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></span></code></pre></div><p>怎么样，一点难度都没有吧。</p>
<h2 id="分组">分组</h2>
<p>除了排序，还有一个非常有用而且经常会用的功能就是分组功能。分组功能是 <code>collect（）</code>方法提供的功能，返回值是一个字典类型。</p>
<h3 id="根据-type-进行分组">根据 type 进行分组</h3>
<p>对应到 SQL 中就是下面这样</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">product</span><span class="w"> </span><span class="k">group</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">type</span><span class="w">
</span></span></span></code></pre></div><p>用 Stream 来实现呢，就是下面这样子</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span><span class="n">Product</span><span class="o">::</span><span class="n">getType</span><span class="o">));</span>
</span></span></code></pre></div><p>最后生成的对象是一个 Map 类型，key 是用来作为分组依据的字段值，value 是一个列表，也就是同一组的对象集合。在这个例子中，key 就是 product 对象的 type 属性，value 就是 type 相同的 Product 对象的集合。</p>
<p>如果只是求出每一个组所包含的对象个数，可以这样实现，不用遍历 Map 这么麻烦。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span><span class="n">Product</span><span class="o">::</span><span class="n">getType</span><span class="o">,</span> <span class="n">Collectors</span><span class="o">.</span><span class="na">counting</span><span class="o">()));</span>
</span></span></code></pre></div><h3 id="根据两个或多个字段分组">根据两个或多个字段分组</h3>
<p>有时候我们可能会根据不止一个字段进行分组，比如想按照类别相同且价格相同进行分组。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">.</span><span class="na">getType</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34;|&#34;</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()));</span>
</span></span></code></pre></div><p>等价于，将分组依据单独抽取出一个方法，这样就可以加入比较复杂的逻辑了，最终返回的是一个字符串。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">   <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">buildGroupKey</span><span class="o">(</span><span class="n">p</span><span class="o">)));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">buildGroupKey</span><span class="o">(</span><span class="n">Product</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="na">getType</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34;|&#34;</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="na">getPrice</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>为什么两个字段之间要加一个分隔符呢，这是因为有些情况我们还会用到分组依据中的某一个字段，加入分隔符之后方便拆分字符串。当然了，也可以拿到这个分组下的任意一个元素获取。</p>
<h3 id="嵌套分组">嵌套分组</h3>
<p>上面的根据多个字段分组是把多个字段当做同一级别并且的关系处理，还有一些时候呢，我们想要先按一个字段分组，再分组中再按另一个字段分组，这样就形成了一个嵌套关系，比如先按 type 分组，再按 price 分组，这就相当于是一个二维字典（两个层级）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;&gt;&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span><span class="n">Product</span><span class="o">::</span><span class="n">getType</span><span class="o">,</span> <span class="n">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span><span class="n">Product</span><span class="o">::</span><span class="n">getPrice</span><span class="o">)));</span>
</span></span></code></pre></div><p>通过返回值类型就可以看出来是怎么样的一个层级关系。</p>
<h2 id="teeing">teeing()</h2>
<p>这是 JDK 12 才出来的方法，所以要用这个方法，比如在 JDK12 以上才行。它的作用是对两个收集器（Collectors）的结果进行处理。上面的例子中，求出最高价格和最低价格的，并输出为一个字符串，将两个价格用 <code>~</code>符号连接。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">teeing</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">Collectors</span><span class="o">.</span><span class="na">minBy</span><span class="o">(</span><span class="n">Comparator</span><span class="o">.</span><span class="na">comparing</span><span class="o">(</span><span class="n">Product</span><span class="o">::</span><span class="n">getPrice</span><span class="o">)),</span>
</span></span><span class="line"><span class="cl">  <span class="n">Collectors</span><span class="o">.</span><span class="na">maxBy</span><span class="o">(</span><span class="n">Comparator</span><span class="o">.</span><span class="na">comparing</span><span class="o">(</span><span class="n">Product</span><span class="o">::</span><span class="n">getPrice</span><span class="o">)),</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="n">max</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">min</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">getPrice</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34;~&#34;</span> <span class="o">+</span> <span class="n">max</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">getPrice</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">));</span>
</span></span><span class="line"><span class="cl"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
</span></span></code></pre></div><p>最终得到的结果是一个字符串，打印如下，测试数据没有做小数位限制。</p>
<pre tabindex="0"><code>4.347594572793579~89.43160979811124
</code></pre><p>最终的返回类型根据teeing() 方法的最后一个参数的返回结果而定。 min 和 max 这两个参数就是前两个收集器 <code>Collectors.minBy</code>和 <code>Collectors.maxBy</code>的返回结果，因为返回类型是 <code>Optional </code>，所以再取值的时候要加上 <code>get</code>。</p>
<h2 id="总结">总结</h2>
<p>Stream 提供了很丰富的 API ，最大的好处是让我们可以少写很多代码，熟练掌握之后，可以在一些对应的场景快速实现我们想要的逻辑。</p>
<p>有同学说，不行啊，又是 filter 、又是 collect、又是 Collectors ，根本记不住啊。没关系，记不住也正常，它本来就是一个工具，我们其实只要知道它可以实现什么功能，具体的用法可以随用随查吗。这不，我的这两篇文章就可以放进收藏夹里，什么时候用，什么时候打开查一下就好了。</p>
<p>下次碰到类似的场景，记得用 Stream 试一下吧。</p>
]]></content:encoded></item><item><title>用了这么久 IDEA，你竟然不知道 Live Templates ？</title><link>https://moonkite.cn/category/java/%E7%94%A8%E4%BA%86%E8%BF%99%E4%B9%88%E4%B9%85-IDEA%E4%BD%A0%E7%AB%9F%E7%84%B6%E4%B8%8D%E7%9F%A5%E9%81%93-Live-Templates-/</link><pubDate>Mon, 09 Jan 2023 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/java/%E7%94%A8%E4%BA%86%E8%BF%99%E4%B9%88%E4%B9%85-IDEA%E4%BD%A0%E7%AB%9F%E7%84%B6%E4%B8%8D%E7%9F%A5%E9%81%93-Live-Templates-/</guid><description>Live Templates 是什么，听上去感觉挺玄乎的。有的同学用过之后觉得简直太好用了，不能说大大提高了开发效率吧，至少也是小小的提高一下，节省了很多敲重复代码的</description><content:encoded><![CDATA[<p>Live Templates 是什么，听上去感觉挺玄乎的。有的同学用过之后觉得简直太好用了，不能说大大提高了开发效率吧，至少也是小小的提高一下，节省了很多敲重复代码的时间。有的同学用过之后说：没什么用，奇技淫巧罢了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b10eae52495040dcb830c47e74d235bb~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>就算你没听过这个概念，但是或多或少你可能都用到过一点，就算没有用过的话，也可能见到过一些，没吃过猪肉可能也见过猪跑，就像下面这样的操作。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/990a1304105d456d9d533b7f69cb3fce~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>总结一下呢，它就类似于一种快捷指令（神奇代码），只要你在 IDEA 中输入特定的字母组合，IDEA 就会帮你在当前输入的位置插入一段预先定义好的代码，代码可以是固定的，也可以定义一些上下文变量，适用于那些常用的、使用频率较高的声明或重复代码段。</p>
<p>比如声明静态 <code>final</code> 的 <code>String</code>，在不用 Live Tmeplates 的情况下，我们会手动在 IDEA 中依次敲出 &ldquo;public static final String&rdquo; 这一行代码，当然可能借助 IDEA 的只能提示，每个单词只需要敲前两个字母。在使用了 Live Tmeplates 的情况下， 我们只需要敲出 <code>psfs</code>这四个字母，然后按回车键，IDEA 就会帮我们在 <code>psfs</code>这个位置插入 &ldquo;public static final String&rdquo;  这一行。</p>
<p>没用过的同学是不是赶紧打开 IDEA 试一下呢？在设置界面，输入 <code>Live Templates</code>，然后找到右侧的 <code>Java</code>就可以看到内置的模板。不光有 Java 的，对于多种文件类型都有支持，比如 SQL 、JavaScript、JSP 、Kotlin 等。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c9c858aab4746ee91419de2cdb75860~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>下面介绍几个 IDEA 内置的、常用的模板。</p>
<h2 id="常用的-live-templates">常用的 Live Templates</h2>
<p><strong>main 和 psvm</strong></p>
<p>main 方法插入，虽然我们已经可以很熟练的盲打出下面这一段代码，但是只敲四个字母是不是会更快呢。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="变量声明">变量声明</h3>
<p>下面一些是常用的变量声明</p>
<p><strong>psfs</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> 
</span></span></code></pre></div><p><strong>psfi</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> 
</span></span></code></pre></div><p><strong>prsf</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> 
</span></span></code></pre></div><p><strong>St</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">String</span> 
</span></span></code></pre></div><h3 id="控制台输出">控制台输出</h3>
<p>下面是控制台输出，还有一些，不一一列举了。</p>
<p><strong>sout</strong></p>
<p>文本输出，最常用到的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
</span></span></code></pre></div><p><strong>souf</strong></p>
<p>带格式化的文本输出。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">();</span>
</span></span></code></pre></div><h3 id="循环迭代">循环迭代</h3>
<p><strong>fori</strong></p>
<p>输入完，按回车后，光标会在 <code>i&lt;</code>的位置，等待输入临界值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl">    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span></code></pre></div><p><strong>iter</strong></p>
<p>用 forEach 的方式循环，在一个数组或者列表变量下方使用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">array</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><strong>itco</strong></p>
<p>用迭代器的方式迭代，同样是在一个列表变量下方使用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="o">(</span><span class="n">Iterator</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span> <span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">();</span> <span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">String</span> <span class="n">next</span> <span class="o">=</span>  <span class="n">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="surround-templates">Surround Templates</h3>
<p>这种模板是在选中一段代码后，然后使用快捷键 <code>option</code>+<code>command</code>+<code>j</code>调出提示框，然后选择一个模板类型。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f132f6d26154fa3a345a51cf8922e95~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>这个快捷键是 MAC 系统下的，如果你用的是 windows，可以通过点击 <code>code</code>菜单项，找到 <code>Sorround With</code>，看看快捷键是什么。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/603c6f09293847d8a667812821b741ed~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p><strong>C</strong></p>
<p>实现一个 <code>Callable</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Callable</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">callable</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Callable</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">public</span> <span class="n">Object</span> <span class="nf">call</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;hello&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">};</span>
</span></span></code></pre></div><p><strong>RL 和 WL</strong></p>
<p>插入一段读锁或写锁加解锁代码。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 要先声明一个读写锁实例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ReadWriteLock</span> <span class="n">readWriteLock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantReadWriteLock</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">readWriteLock</span><span class="o">.</span><span class="na">readLock</span><span class="o">().</span><span class="na">lock</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="k">try</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;hello&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">readWriteLock</span><span class="o">.</span><span class="na">readLock</span><span class="o">().</span><span class="na">unlock</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="自定义-template">自定义 Template</h2>
<p>有时候我们经常会高频词的使用一段相似的代码， 比如做网络开发的同学，会经常用到 Socket 相关的初始化代码。</p>
<p>对于这种我们自己经常要写的某些类似的代码段，就可以抽取出一个 Template 出来，方便我们使用。</p>
<p>下面我就实现一个自定的 Template，来看一下是不是大大简化了重复性劳动。有的同学可能觉得无所谓的事儿，复制、粘贴也挺省事儿。见仁见智吧，觉得有用的可以尝试一下，觉得鸡肋的也无所谓，反正也不影响最后的功能实现。</p>
<p>比如我最新在做一些系统优化的工作，这个过程中，我会频繁的用 <code>commons-lang3</code>的 <code>StopWatch</code>来看某些方法或者某些代码段的执行时间。比如下面的代码段：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">StopWatch</span> <span class="n">stopWatch</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StopWatch</span><span class="o">(</span><span class="s">&#34;代码段&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">stopWatch</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="k">try</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="n">stopWatch</span><span class="o">.</span><span class="na">stop</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;执行时间 %s%n&#34;</span><span class="o">,</span><span class="n">stopWatch</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
</span></span></code></pre></div><p>由于我比较懒，所以我不想每次都敲重复的内容，连粘贴复制都不想。所以就想到了 Live Template。</p>
<p>1、打开 IDEA 的设置窗口，找到 Editor 下的 <code>Live Templates</code>，在右侧找到 <code>Java</code>，点击最右侧的加号。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0e64b8c32884741bf16863c44589bb3~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20230103224026372"></p>
<p>2、输入这个 Template 的名字，到时候可以在编辑器中通过输入这个名字来插入这个模板。</p>
<p>输入描述，帮助我们记忆。</p>
<p>最后输入模板的内容。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f71f863323a439f86df1b0c5a447309~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20230103224347657"></p>
<p>我给这个模板起名为 <code>watch</code>，模板内容如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">StopWatch</span> <span class="n">stopWatch</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StopWatch</span><span class="o">(</span><span class="s">&#34;$MESSAGE$&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">stopWatch</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">$SELECTION$</span>
</span></span><span class="line"><span class="cl"><span class="n">stopWatch</span><span class="o">.</span><span class="na">stop</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;执行时间 %s%n&#34;</span><span class="o">,</span><span class="n">stopWatch</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
</span></span></code></pre></div><p><code>$SELECTION$</code>表示选中的部分，我们要监控的正好是某个方法或者某个代码段，所以正好可以用 Surround Templates，并且在内容中用了 <code>$SELECTION$</code>，模板就默认为  Surround Templates了。</p>
<p><code>$MESSAGE$</code>就是一个占位符的作用，当我们插入这个模板后，光标会定位到这个占位符，我们就可以在需要定制的地方输入我们想要的内容了。在这里呢，由于我的一个方法中可能用到多个 StopWatch，所以正好在这儿占位，给不同的 StopWatch 赋予不同的名字。</p>
<p>可以通过下面的演示看一下效果。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f603e2288fa4ceab96dbf3ebdab86b3~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="live-template-支持的变量">Live Template 支持的变量</h2>
<p>有一些情况下，我们希望插入的内容不只是固定不变的代码段，而是希望加入一些上下文相关的内容，比如当前方法的入参，比如当前类名，比如当前方法名等。用下面这个例子说明一下。</p>
<p>有一个内置的模板叫做 <code>soutm</code>，它的描述是这样的：Prints current class and method names to System.out，打印当前类和方法名，我们看一下效果，直接将当前类和方法名 <code>Study.main</code>填充到了<code>println</code>参数位置上。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcdb780b64e649ea9963c80610f2cc05~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>模板内容是这样的，其中用到了两个变量是表示当前类名的 <code>$CLASS_NAME$</code>和表示当前方法名的<code>$METHOD_NAME$</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;$CLASS_NAME$.$METHOD_NAME$&#34;</span><span class="o">);</span>
</span></span></code></pre></div><p>更多的可用变量可以到 IDEA 官网查看，看到这些变量后，可能会打开你的思路，更近一步的为你提高开发效率。不过不用这些变量也没关系，上面这写其实差不多也够用了。</p>
<p>官网地址：https://www.jetbrains.com/help/idea/template-variables.html#predefined_functions</p>
]]></content:encoded></item><item><title>新项目为什么决定用 JDK 17了</title><link>https://moonkite.cn/category/java/JDK17/</link><pubDate>Fri, 16 Dec 2022 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/java/JDK17/</guid><description>最近在调研 JDK 17，并且试着将之前的一个小项目升级了一下，在测试环境跑了一段时间。最终，决定了，新项目要采用 JDK 17 了。 JDK 1.8：“不是说好了，他</description><content:encoded><![CDATA[<p>最近在调研 JDK 17，并且试着将之前的一个小项目升级了一下，在测试环境跑了一段时间。<strong>最终，决定了，新项目要采用 JDK 17 了。</strong></p>
<p>JDK 1.8：“不是说好了，他发任他发，你用 Java 8 吗？”</p>
<p>不光是我呀，连 Spring Boot 都开始要拥护 JDK 17了，下面这一段是 Spring Boot 3.0 的更新日志。</p>
<blockquote>
<p>Spring Boot 3.0 requires Java 17 as a minimum version. If you are currently using Java 8 or Java 11, you&rsquo;ll need to upgrade your JDK before you can develop Spring Boot 3.0 applications.</p>
</blockquote>
<p>Spring Boot 3.0 需要 JDK 的最低版本就是 JDK 17，如果你想用 Spring Boot 开发应用，你需要将正在使用的 Java 8 或 Java 11升级到 Java 17。</p>
<p>选用 Java 17，概括起来主要有下面几个主要原因：</p>
<p>1、JDK 17 是 LTS (长期支持版)，可以免费商用到 2029 年。而且将前面几个过渡版（JDK 9-JDK 16）去其糟粕，取其精华的版本；</p>
<p>2、JDK 17 性能提升不少，比如重写了底层 NIO，至少提升 10% 起步；</p>
<p>3、大多数第三方框架和库都已经支持，不会有什么大坑；</p>
<p>4、准备好了，来吧。</p>
<p><strong>拿几个比较好玩儿的特性来说一下 JDK 17 对比 JDK 8 的改进。</strong></p>
<h2 id="密封类">密封类</h2>
<p>密封类应用在接口或类上，对接口或类进行继承或实现的约束，约束哪些类型可以继承、实现。例如我们的项目中有个基础服务包，里面有一个父类，但是介于安全性考虑，值允许项目中的某些微服务模块继承使用，就可以用密封类了。</p>
<p>没有密封类之前呢，可以用 <code>final</code>关键字约束，但是这样一来，被修饰的类就变成完全封闭的状态了，所有类都没办法继承。</p>
<p>密封类用关键字 <code>sealed</code>修饰，并且在声明末尾用 <code>permits</code>表示要开放给哪些类型。</p>
<p>下面声明了一个叫做 <code>SealedPlayer</code>的密封类，然后用关键字 <code>permits</code>将集成权限开放给了 <code>MarryPlayer</code>类。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">sealed</span> <span class="kd">class</span> <span class="nc">SealedPlayer</span> <span class="n">permits</span> <span class="n">MarryPlayer</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">play</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;玩儿吧&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>之后 <code>MarryPlayer</code> 就可以继承 <code>SealedPlayer</code>了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">non</span><span class="o">-</span><span class="n">sealed</span> <span class="kd">class</span> <span class="nc">MarryPlayer</span> <span class="kd">extends</span> <span class="n">SealedPlayer</span><span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">play</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;不想玩儿了&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>继承类也要加上密封限制。比如这个例子中是用的 <code>non-sealed</code>，表示不限制，任何类都可以继承，还可以是 <code>sealed</code>，或者 <code>final</code>。</p>
<p>如果不是 permits 允许的类型，则没办法继承，比如下面这个，编译不过去，会给出提示 &ldquo;java: 类不得扩展密封类：org.jdk17.SealedPlayer（因为它未列在其 &lsquo;permits&rsquo; 子句中）&rdquo;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">non</span><span class="o">-</span><span class="n">sealed</span> <span class="kd">class</span> <span class="nc">TomPlayer</span> <span class="kd">extends</span> <span class="n">SealedPlayer</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">play</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="空指针异常">空指针异常</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="n">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toLowerCase</span><span class="o">();</span>
</span></span></code></pre></div><p>JDK1.8 的版本下运行：</p>
<pre tabindex="0"><code>Exception in thread &#34;main&#34; java.lang.NullPointerException
	at org.jdk8.App.main(App.java:10)
</code></pre><p>JDK17的版本（确切的说是14及以上版本）</p>
<pre tabindex="0"><code>Exception in thread &#34;main&#34; java.lang.NullPointerException: Cannot invoke &#34;String.toLowerCase()&#34; because &#34;s&#34; is null
	at org.jdk17.App.main(App.java:14)
</code></pre><p>出现异常的具体方法和原因都一目了然。如果你的一行代码中有多个方法、多个变量，可以快速定位问题所在，如果是 JDK1.8，有些情况下真的不太容易看出来。</p>
<h2 id="yield关键字">yield关键字</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">calc</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span><span class="n">String</span> <span class="n">operation</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">var</span> <span class="n">result</span> <span class="o">=</span> <span class="k">switch</span> <span class="o">(</span><span class="n">operation</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="s">&#34;+&#34;</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">yield</span> <span class="n">a</span> <span class="o">+</span> <span class="n">a</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="s">&#34;*&#34;</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">yield</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">default</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="换行文本块">换行文本块</h2>
<p>如果你用过 Python，一定知道Python 可以用 <code>'hello world'</code>、<code>&quot;hello world&quot;</code>、<code>''' hello world '''</code>、<code>&quot;&quot;&quot; hello world &quot;&quot;&quot; </code>四种方式表示一个字符串，其中后两种是可以直接支持换行的。</p>
<p>在 JDK 1.8 中，如果想声明一个字符串，如果字符串是带有格式的，比如回车、单引号、双引号，就只能用转义符号，例如下面这样的 JSON 字符串。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">String</span> <span class="n">json</span> <span class="o">=</span> <span class="s">&#34;{\n&#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">        <span class="s">&#34;  \&#34;name\&#34;: \&#34;古时的风筝\&#34;,\n&#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">        <span class="s">&#34;  \&#34;age\&#34;: 18\n&#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">        <span class="s">&#34;}&#34;</span><span class="o">;</span>
</span></span></code></pre></div><p>从 JDK 13开始，也像 Python 那样，支持三引号字符串了，所以再有上面的 JSON 字符串的时候，就可以直接这样声明了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="err">String</span> <span class="err">json</span> <span class="err">=</span> <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">        {
</span></span></span><span class="line"><span class="cl"><span class="s2">          &#34;</span><span class="err">name</span><span class="s2">&#34;: &#34;</span><span class="err">古时的风筝</span><span class="s2">&#34;,
</span></span></span><span class="line"><span class="cl"><span class="s2">          &#34;</span><span class="err">age</span><span class="s2">&#34;: 18
</span></span></span><span class="line"><span class="cl"><span class="s2">        }
</span></span></span><span class="line"><span class="cl"><span class="s2">        &#34;&#34;&#34;</span><span class="err">;</span>
</span></span></code></pre></div><h2 id="record记录类">record记录类</h2>
<p>类似于 Lombok 。</p>
<p>传统的Java应用程序通过创建一个类，通过该类的构造方法实例化类，并通过getter和setter方法访问成员变量或者设置成员变量的值。有了record关键字，你的代码会变得更加简洁。</p>
<p>之前声明一个实体类。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>使用 <code>Record</code>类之后，就像下面这样。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">record</span> <span class="nf">User</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>调用的时候像下面这样</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">RecordUser</span> <span class="n">recordUser</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RecordUser</span><span class="o">(</span><span class="s">&#34;古时的风筝&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">recordUser</span><span class="o">.</span><span class="na">name</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">recordUser</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
</span></span></code></pre></div><p>输出结果</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4cddc522449d49be9ec057f5d63eed41~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>Record 类更像是一个实体类，直接将构造方法加在类上，并且自动给字段加上了 getter 和 setter。如果一直在用 Lombok 或者觉得还是显式的写上 getter 和 setter 更清晰的话，完全可以不用它。</p>
<h2 id="g1-垃圾收集器">G1 垃圾收集器</h2>
<p>JDK8可以启用G1作为垃圾收集器，JDK9到 JDK 17，G1 垃圾收集器是默认的垃圾收集器，G1是兼顾老年代和年轻代的收集器，并且其内存模型和其他垃圾收集器是不一样的。</p>
<p>G1垃圾收集器在大多数场景下，其性能都好于之前的垃圾收集器，比如CMS。</p>
<h2 id="zgc">ZGC</h2>
<p>从 JDk 15 开始正式启用 ZGC，并且在 JDK 16后对 ZGC 进行了增强，控制 stop the world 时间不超过10毫秒。但是默认的垃圾收集器仍然是 G1。</p>
<p>配置下面的参数来启用 ZGC 。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">-XX:+UseZGC
</span></span></code></pre></div><p><strong>可以用下面的方法查看当前所用的垃圾收集器</strong></p>
<p>JDK 1.8 的方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">jmap -heap <span class="m">8877</span>
</span></span></code></pre></div><p>JDK 1.8以上的版本</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">jhsdb jmap --heap --pid <span class="m">8877</span>
</span></span></code></pre></div><p>例如下面的程序采用 ZGC 垃圾收集器。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adef9657c0254619a05a1bdb0b6d07a9~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="其他一些小功能">其他一些小功能</h2>
<p>1、支持 List.of()、Set.of()、Map.of()和Map.ofEntries()等工厂方法实例化对象；</p>
<p>2、Stream API 有一些改进，比如 <code>.collect(Collectors.toList())</code>可以直接写成 <code>.toList()</code>了，还增加了 <code>Collectors.teeing()</code>，这个挺好玩，有兴趣可以看一下；</p>
<p>3、<code>HttpClient</code>重写了，支持 HTTP2.0，不用再因为嫌弃 HttpClient 而使用第三方网络框架了，比如OKHTTP；</p>
<h2 id="升级-jdk-和-idea">升级 JDK 和 IDEA</h2>
<p>安装 JDK 17，这个其实不用说，只是推荐一个网站，这个网站可以下载各种系统、各种版本的 JDK 。地址是 <a href="https://adoptium.net/">https://adoptium.net/</a></p>
<p>还有，如果你想在 IDEA 上使用 JDK 17，可能要升级一下了，只有在 <code>2021.02</code>版本之后才支持 JDK 17。</p>
]]></content:encoded></item><item><title>过两年 JVM 可能就要被GraalVM替代了</title><link>https://moonkite.cn/category/java/Graalvm/</link><pubDate>Tue, 13 Dec 2022 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/java/Graalvm/</guid><description>今天说一说 GraalVM。 GraalVM 是 Oracle 大力发展和想要推广的新一代 JVM ，目前很多框架都已经渐渐支持 GraalVM 了，比如我们在用的 Spring 也已经推出了对 GraalVM 兼容的工具包了</description><content:encoded><![CDATA[<p>今天说一说 GraalVM。</p>
<p>GraalVM 是 Oracle 大力发展和想要推广的新一代 JVM ，目前很多框架都已经渐渐支持 GraalVM 了，比如我们在用的 Spring 也已经推出了对 GraalVM 兼容的工具包了。</p>
<p>既然说的这么厉害，那么它到底是何方神圣呢。</p>
<h2 id="graalvm-和-jvm-的关系">GraalVM 和 JVM 的关系</h2>
<p>既然叫做VM，那肯定和 JVM 有关系的吧。JVM 全称 Java 虚拟机，我们都知道，Java 程序是运行在虚拟机上的，虚拟机提供 Java 运行时，支持解释执行和部分的（JIT）即时编译器，并且负责分配和管理 Java 运行所需的内存，我们所说的各种垃圾收集器都工作在 JVM 中。</p>
<p>比如 Oracle JDK、OpenJDK ，默认的 JVM 是 HotSpot 虚拟机，这是当前应用最广泛的一个虚拟机。我们平时见到的各种将虚拟机的书籍、文章、面试题，基本上都是说的 HotSpot 虚拟机。</p>
<p>除此之外，还有一些商用，或者说小众的虚拟机存在，比如IBM 的J9 JVM，商用的 Zing VM 等。</p>
<p>那 GraalVM 是另一种 Java 虚拟机吗？</p>
<p>是，又不全是。</p>
<p>GraalVM 可以完全取代上面提到的那几种虚拟机，比如 HotSpot。把你之前运行在 HotSpot 上的代码直接平移到 GraalVM 上，不用做任何的改变，甚至都感知不到，项目可以完美的运行。</p>
<p>但是 GraalVM 还有更广泛的用途，不仅支持 Java 语言，还支持其他语言。这些其他语言不仅包括嫡系的 JVM 系语言，例如 Kotlin、Scala，还包括例如 JavaScript、Nodejs、Ruby、Python 等。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85cedb09df80420c9ee6108117fa8adb~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>GraalVM 的野心不止于此，看上面的图，它的目的是搭建一个 Framework，最终的目标是想要支持任何一种语言，无论哪种语言，可以共同跑在 GraalVM 上，不存在跨语言调用的壁垒。</p>
<h2 id="graalvm-和jdk有什么关系">GraalVM 和JDK有什么关系</h2>
<p>Java 虚拟机都是内置在 JDK 中的，比如Orcale JDK、OpenJDK，默认内置的都是 HotSpot 虚拟机。</p>
<p>GraalVM 也是一种 JDK，一种高性能的 JDK。完全可以用它替代 OpenJDK、Orcale JDK。</p>
<h2 id="graalvm-如何运行-java-程序">GraalVM 如何运行 Java 程序</h2>
<p>说了半天，是不是还是不知道 GraalVM 到底是什么。</p>
<ul>
<li>
<p>GraalVM - 还包含 Graal （JIT）即时编译器，可以结合 HotSpot 使用</p>
</li>
<li>
<p>GraalVM – 是一种高性能 JDK，旨在加速 Java 应用程序性能，同时消耗更少的资源。</p>
</li>
<li>
<p>GraalVM - 是一种支持多语言混编的虚拟机程序，不仅可以运行 JVM 系列的语言，也可支持其他语言。</p>
</li>
</ul>
<p>GraalVM 提供了两种方式来运行 Java 程序。</p>
<h3 id="第一种结合-hotspot-使用">第一种：结合 HotSpot 使用</h3>
<p>上面说了，GraalVM 包含 Graal （JIT）即时编译器，自从 JDK 9u 版本之后，Orcale JDK 和 OpenJDK 就集成了 Graal 即时编译器。我们知道 Java 既有解释运行也有即时编译。</p>
<p>当程序运行时，解释器首先发挥作用，代码可以直接执行。随着时间推移，即时编译器逐渐发挥作用，把越来越多的代码编译优化成本地代码，来获取更高的执行效率。即时编译器可以选择性地编译热点代码，省去了很多编译时间，也节省很多的空间。比如多次执行的方法或者循环、递归等。</p>
<p>JDK 默认使用的是 C2 即时编译器，C2是用C++编写的。而使用下面的参数可以用 Graal 替换 C2。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler
</span></span></code></pre></div><p>Graal 编译器是用 Java 实现的，用 Java 实现自己的编译器。Graal 基于一些假设的条件，采取更加激进的方式进行优化。采用 Graal 编译器之后，对性能有会有一定的提升。</p>
<p>但是如果你还是在用 JDK8，那对不起了，GraalVM 的一切都用不了。</p>
<h3 id="第二种aot-编译本地可执行程序">第二种：AOT 编译本地可执行程序</h3>
<p>这是 GraalVM 真正厉害的地方。</p>
<p>AOT 提前编译，是相对于即时编译而言的。AOT在运行过程中耗费 CPU 资源来进行即时编译，而程序也能够在启动的瞬间就达到理想的性能。例如 C 和 C++语言采用的是AOT静态编译，直接将代码转换成机器码执行。而 Java 一直采用的是解释 + 即时编译技术，大多数情况下 Java 即时编译的性能并不比静态编译差，但是还是一直朝着 AOT 编译的方向努力。</p>
<p>但是 Java 对于 AOT 来说有一些难点，比如类的动态加载和反射调用。</p>
<p>GraalVM 显然是已经克服了这些问题，使用 GraalVM 可以直接将 Java 代码编译成本地机器码形态的可执行程序。</p>
<p>我们目前运行 Java 一定要安装 JDK 或者 JRE 对不对，如果将程序直接编译成可执行程序，就不用在服务器上安装 JDK 或 JRE 了。那就是说运行 Java 代码其实也可以不用虚拟机了是吗？</p>
<p>GraalVM 的 AOT 编译实际上是借助了 SubstrateVM 编译框架，可以将 SubstrateVM  理解为一个内嵌精简版的 JVM，包含异常处理，同步，线程管理，内存管理（垃圾回收）和 JNI 等组件。</p>
<p>SubstrateVM 的启动时间非常短，内存开销非常少。用这种方式编译出的 Java 程序的执行时间可与C语言持平。</p>
<p>下图是使用即时编译（JVM运行）与 AOT (原生可执行程序)两种方式的 CPU 和内存使用情况对比，可以看出来，AOT 方式下 CPU 和内存的使用都非常少。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aae8240e7bd040ad96cc4947ad3c548d~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>除了运行时占用的内存少之外，用这种方式最终生成的可执行文件也非常小。这对于云端部署非常友好。目前很多场景下都使用 Docker 容器的方式部署，打一个 Java 程序的镜像包要包含完整的 JVM 环境和编译好的 Jar 包。而AOT 方式可以最大限度的缩小 Docker 镜像的体积。</p>
<p><strong>缺点</strong></p>
<p>好处多多，当然也有一些弊端。对于反射这种纯粹在运行时才能确定的部分，不可能完全通过优化编译器解决，只能通过增加配置的方式解决。麻烦是麻烦了一点，但是是可行的，Spring Boot 2.7的版本已经支持原生镜像了，Spring 这种非常依赖反射的框架都可以支撑，我们用起来也应该没问题。</p>
<h2 id="graalvm-如何支持多语言">GraalVM 如何支持多语言</h2>
<p>要支持多语言，就要说到 GraalVM 中的另一个核心组件 Truffle 了。</p>
<p>Truffle 是一个用 Java 写就的语言实现框架。基于 Truffle 的语言实现仅需用 Java 实现词法分析、语法分析以及针对语法分析所生成的抽象语法树（Abstract Syntax Tree，AST）的解释执行器，便可以享用由 Truffle 提供的各项运行时优化。</p>
<p>就一个完整的 Truffle 语言实现而言，由于实现本身以及其所依赖的 Truffle 框架部分都是用 Java 实现的，因此它可以运行在任何 Java 虚拟机之上。</p>
<p>当然，如果 Truffle 运行在附带了 Graal 编译器的 Java 虚拟机之上，那么它将调用 Graal 编译器所提供的 API，主动触发对 Truffle 语言的即时编译，将对 AST 的解释执行转换为执行即时编译后的机器码。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87d8ead82cc54120b3e91a98465fb12d~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>目前除了 Java， JavaScript、Ruby、Python 和许多其他流行语言都已经可以运行在 GraalVM 之上了。</p>
<p>GraalVM 官方还提供了完整的文档，当有一天你开发了一款新的语言，也可以用 Truffle  让它跑在 GraalVM 上。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f487e72828d4b4d892a4cde51bea8fd~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h3 id="安装和使用">安装和使用</h3>
<p>GraalVm 目前的最新版本是 22.3，分为社区版和企业版，就好像 OpenJDK 和 商用的 Orcale 的 JDK ，企业版会多一些性能分析的功能，用来帮助更大程度的优化性能。</p>
<p>社区版是基于OpenJDK 11.0.17, 17.0.5, 19.0.1，而商业版基于Oracle JDK 8u351, 11.0.17, 17.0.5, 19.0.1，所以，如果你想用免费的，只能将程序升级到 JDK 11 以上了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d5f3f31ebe04241a7b5a466382889aa~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>GraalVM 支持 Windows、Linux、MacOS ，可以用命令安装最新版，或者直接下载对应 Java 版本的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/950626b9458844f7ad06ced978787ee5~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>我是下载的 Java 11 的版本，下载下来的压缩包，直接解压，然后配置环境变量。把解压目录配置到环境变量的 <code>JAVA_HOME</code>就可以了。</p>
<p>解压好其实就相当于安装完毕了，查看一下版本。</p>
<p>进入到解压目录下的<code>bin</code>目录中，运行 <code>java -version</code>。运行结果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97101a8288334db2a9872df728c7b481~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20221130105634757"></p>
<h2 id="运行代码">运行代码</h2>
<h3 id="常用方式运行">常用方式运行</h3>
<p>也就是我们平时一直在用的这种方式，把 GrralVM 当做 OpenJDK 使用，只不过把即时编译器换成了 Graal 。就是前面说的第一种方式。</p>
<p>安装完成后，就可以把它当做正常的 JDK 使用了，比如 <code>javac</code>、<code>jps</code>、<code>jmap</code>等都可以直接用了。大多数人还是用 IDEA 的，所以就直接在 IDEA 中使用就好了。</p>
<p>1、先随意创建一个 Java 项目。</p>
<p>2、创建完成后，打开项目设置。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0dd751cb7d294df781f77552064615f2~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>3、在打开的项目设置弹出框中选择 <code>SDKs</code>，点击加号，选择前面解压的 GraalVM 目录。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3d3f721b00a410e9d490234165ddc41~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>4、然后选择刚刚添加的这个 JDK。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/744a58afa8f9430fb4cc34daee5c0d18~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>5、最后运行一段测试代码。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloWorld</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Hello GraalVM!&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">*</span> <span class="mi">100</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7f797c478b04af8ad606767b6d9458e~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>上面这样的运行方式，其实就相当于前面说的第一种运行方式</p>
<h3 id="native-image-方式运行">native-image 方式运行</h3>
<p>这种方式就是 AOT 编译成机器码，已可执行文件的形式出现。<code>native-image</code> 可以命令行的形式执行，也可以在配合 Maven 执行，我这儿就直接演示用 Maven 形式的了，毕竟IDEA 搭配 Maven 用习惯了。</p>
<p>1、<strong>安装<code>native-image</code> 工具包</strong></p>
<p><code>native-image</code> 是用来进行 AOT 编译打包的工具，先把这个装上，才能进行后面的步骤。</p>
<p>安装好 GraalVM 后，在 <code>bin</code>目录下有一个叫做 <code>gu</code>的工具，用这个工具安装，如果将 <code>bin</code>目录添加到环境中，直接下面的命令安装就行了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">gu install native-image
</span></span></code></pre></div><p>如果没有将 <code>bin</code>目录加到环境变量中，要进入到 <code>bin</code>目录下，执行下面的命令安装。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">./gu install native-image
</span></span></code></pre></div><p>这个过程可能比较慢，因为要去 github 上下载东西，如果一次没成功（比如超时），多试两次就好了。</p>
<p>2、<strong>配置 Maven</strong></p>
<p>配置各种版本</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"> <span class="nt">&lt;properties&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;project.build.sourceEncoding&gt;</span>UTF-8<span class="nt">&lt;/project.build.sourceEncoding&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;maven.compiler.source&gt;</span>${java.specification.version}		<span class="nt">&lt;/maven.compiler.source&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;maven.compiler.target&gt;</span>${java.specification.version}<span class="nt">&lt;/maven.compiler.target&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;native.maven.plugin.version&gt;</span>0.9.12<span class="nt">&lt;/native.maven.plugin.version&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;imageName&gt;</span>graalvm-demo-image<span class="nt">&lt;/imageName&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;mainClass&gt;</span>org.graalvm.HelloWorld<span class="nt">&lt;/mainClass&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;/properties&gt;</span>
</span></span></code></pre></div><p><code>native.maven.plugin.version</code>是要用到的编译为可执行程序的 Maven 插件版本。</p>
<p><code>imageName</code>是生成的可执行程序的名称。</p>
<p><code>mainClass</code>是入口类全名称。</p>
<p>配置 build 插件</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl">  <span class="nt">&lt;build&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;plugins&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;plugin&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;groupId&gt;</span>org.codehaus.mojo<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;artifactId&gt;</span>exec-maven-plugin<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;version&gt;</span>3.0.0<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;executions&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;execution&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;id&gt;</span>java-agent<span class="nt">&lt;/id&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;goals&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;goal&gt;</span>exec<span class="nt">&lt;/goal&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;/goals&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;configuration&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;executable&gt;</span>java<span class="nt">&lt;/executable&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;workingDirectory&gt;</span>${project.build.directory}<span class="nt">&lt;/workingDirectory&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;arguments&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;argument&gt;</span>-classpath<span class="nt">&lt;/argument&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;classpath/&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;argument&gt;</span>${mainClass}<span class="nt">&lt;/argument&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;/arguments&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;/configuration&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;/execution&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;execution&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;id&gt;</span>native<span class="nt">&lt;/id&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;goals&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;goal&gt;</span>exec<span class="nt">&lt;/goal&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;/goals&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;configuration&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;executable&gt;</span>${project.build.directory}/${imageName}<span class="nt">&lt;/executable&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;workingDirectory&gt;</span>${project.build.directory}<span class="nt">&lt;/workingDirectory&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;/configuration&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;/execution&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;/executions&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;/plugin&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;plugin&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;groupId&gt;</span>org.apache.maven.plugins<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;artifactId&gt;</span>maven-compiler-plugin<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;version&gt;</span>3.8.1<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;configuration&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;source&gt;</span>${maven.compiler.source}<span class="nt">&lt;/source&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;target&gt;</span>${maven.compiler.source}<span class="nt">&lt;/target&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;/configuration&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;/plugin&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;plugin&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;groupId&gt;</span>org.apache.maven.plugins<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;artifactId&gt;</span>maven-jar-plugin<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;version&gt;</span>3.2.2<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;configuration&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;archive&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;manifest&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;addClasspath&gt;</span>true<span class="nt">&lt;/addClasspath&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;mainClass&gt;</span>${mainClass}<span class="nt">&lt;/mainClass&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;/manifest&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;/archive&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;/configuration&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;/plugin&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;plugin&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;groupId&gt;</span>org.apache.maven.plugins<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;artifactId&gt;</span>maven-assembly-plugin<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;executions&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;execution&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;phase&gt;</span>package<span class="nt">&lt;/phase&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;goals&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;goal&gt;</span>single<span class="nt">&lt;/goal&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;/goals&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;/execution&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;/executions&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;configuration&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;archive&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;manifest&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;addClasspath&gt;</span>true<span class="nt">&lt;/addClasspath&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;mainClass&gt;</span>${mainClass}<span class="nt">&lt;/mainClass&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;/manifest&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;/archive&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;descriptorRefs&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;descriptorRef&gt;</span>jar-with-dependencies<span class="nt">&lt;/descriptorRef&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;/descriptorRefs&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;/configuration&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;/plugin&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/plugins&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;/build&gt;</span>
</span></span></code></pre></div><p>配置 profiles</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl">  <span class="nt">&lt;profiles&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;profile&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;id&gt;</span>native<span class="nt">&lt;/id&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;build&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;plugins&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;plugin&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;groupId&gt;</span>org.graalvm.buildtools<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;artifactId&gt;</span>native-maven-plugin<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;version&gt;</span>${native.maven.plugin.version}<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;extensions&gt;</span>true<span class="nt">&lt;/extensions&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;executions&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;execution&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;id&gt;</span>build-native<span class="nt">&lt;/id&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;goals&gt;</span>
</span></span><span class="line"><span class="cl">                  <span class="nt">&lt;goal&gt;</span>build<span class="nt">&lt;/goal&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;/goals&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;phase&gt;</span>package<span class="nt">&lt;/phase&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;/execution&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;execution&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;id&gt;</span>test-native<span class="nt">&lt;/id&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;goals&gt;</span>
</span></span><span class="line"><span class="cl">                  <span class="nt">&lt;goal&gt;</span>test<span class="nt">&lt;/goal&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;/goals&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;phase&gt;</span>test<span class="nt">&lt;/phase&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;/execution&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;/executions&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;configuration&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;fallback&gt;</span>false<span class="nt">&lt;/fallback&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;buildArgs&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;arg&gt;</span>-H:DashboardDump=fortune -H:+DashboardAll<span class="nt">&lt;/arg&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;/buildArgs&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;agent&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;enabled&gt;</span>true<span class="nt">&lt;/enabled&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;options&gt;</span>
</span></span><span class="line"><span class="cl">                  <span class="nt">&lt;option&gt;</span>experimental-class-loader-support<span class="nt">&lt;/option&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;/options&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;/agent&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;/configuration&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;/plugin&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;/plugins&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;/build&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/profile&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;/profiles&gt;</span>
</span></span></code></pre></div><p>3、使用 maven 编译，打包成本地可执行程序。</p>
<p>执行 Maven 命令</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">mvn clean package
</span></span></code></pre></div><p>或者</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">mvn  -Pnative -Dagent package 
</span></span></code></pre></div><p>编译打包的过程比较慢，因为要直接编译成机器码，所以比一般的编译过程要慢一些。看到下面的输入日志，说明打包成功了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/691d3aaf162b4890b0b6160c2a715e50~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>4、运行可执行程序包，打开 target 目录，已经看到了<code>graalvm-demo-image</code>可执行程序包了，大小为 11.58M。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83ae594348264945ad56fc05b6130779~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>然后就可以运行它了，进入到目录下，执行下面的命令运行，可以看到正常输出了。注意了，这时候已经是没有用到本地 JVM 了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">./graalvm-demo-image 
</span></span><span class="line"><span class="cl">Hello GraalVM!
</span></span></code></pre></div><p>这时候，用 <code>jps -l</code>命令已经看不到这个进程了，只能通过 <code>ps</code>看了。</p>
<h2 id="总结">总结</h2>
<p>虽然我们还没有看到有哪个公司说在用 GraalVM 了，但是 <code>Quarkus</code>、<code>Spring Boot</code>、<code>Spring</code>等很多的框架都已经支持 GraalVM 的 Native-image 模式，而且在 Orcale 的大力推广下，相信不久之后就会出现在更多的产品中。赶紧体验一下吧。</p>
]]></content:encoded></item><item><title>JVM 内存溢出的原因及预防</title><link>https://moonkite.cn/category/java/JVM-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E9%A2%84%E9%98%B2/</link><pubDate>Thu, 02 Sep 2021 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/java/JVM-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E9%A2%84%E9%98%B2/</guid><description>我们都知道 Java 程序都是跑在 JVM 上的，一旦 JVM 有什么风吹草动，必然会影响服务的稳定性。幸运的话，服务会发生抖动，可能有部分请求出现延迟或异常。不幸的</description><content:encoded><![CDATA[<p>我们都知道 Java 程序都是跑在 JVM 上的，一旦 JVM 有什么风吹草动，必然会影响服务的稳定性。幸运的话，服务会发生抖动，可能有部分请求出现延迟或异常。不幸的话，JVM 直接崩溃，导致服务完全中断。</p>
<p>这可不是什么好事，与 JVM 一起崩溃的，除了服务，还有我们的心态。</p>
<p>所谓的 JVM 崩溃，一般情况下就是指内存溢出，也就是 OutOfMemoryError 和 StackOverflowError。另外还有一种情况就是堆外内存占用过大，这种情况会导致 JVM 所在机器的内存被撑爆，从而导致机器重启等异常情况发生，我们把这种情况叫做内存泄漏。</p>
<p>那什么情况下会造成 JVM 崩溃呢，有哪几种类型的崩溃呢？俗话说，知己知彼，方能百战不殆。了解了发生崩溃的原因，才能更好的解决 JVM 崩溃问题。</p>
<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccf8e870e83a435e9684be5527ccc7a6~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20201016165948638"></p>
<p>首先还是放出 JVM 内存模型图，JVM 要理解起来是很抽象的，借助下面这张图可以具象化的了解 JVM 内存模型，而发生溢出的几个部分都可以在图中找到。在 JDK 8 中，永久代已经不存在了，取而代之的是元空间（metaspace）。</p>
<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad12b760a3e64e179acff90d4041a911~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20201019183925854"></p>
<p>下面就以 Hotspot JDK 8 为背景，看一下 JVM 内存溢出和内存泄漏的几种情况。</p>
<p>首先设置 JVM 启动参数，限制堆空间大小，堆空间设置为 20M，其中新生代10M，元空间10M，并指定垃圾收集算法采用 CMS 算法。之后的例子都会使用这套参数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">-XX:+UseConcMarkSweepGC
</span></span><span class="line"><span class="cl">-XX:+UseCMSInitiatingOccupancyOnly
</span></span><span class="line"><span class="cl">-XX:CMSInitiatingOccupancyFraction<span class="o">=</span><span class="m">70</span>
</span></span><span class="line"><span class="cl">-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses
</span></span><span class="line"><span class="cl">-XX:+CMSClassUnloadingEnabled
</span></span><span class="line"><span class="cl">-XX:+ParallelRefProcEnabled
</span></span><span class="line"><span class="cl">-XX:+CMSScavengeBeforeRemark
</span></span><span class="line"><span class="cl">-verbose:gc
</span></span><span class="line"><span class="cl">-Xms20M
</span></span><span class="line"><span class="cl">-Xmx20M
</span></span><span class="line"><span class="cl">-Xmn10M
</span></span><span class="line"><span class="cl">-XX:+PrintGCDetails
</span></span><span class="line"><span class="cl">-XX:SurvivorRatio<span class="o">=</span><span class="m">8</span>
</span></span><span class="line"><span class="cl">-XX:+HeapDumpOnOutOfMemoryError
</span></span><span class="line"><span class="cl">-XX:MetaspaceSize<span class="o">=</span>10M
</span></span><span class="line"><span class="cl">-XX:MaxMetaspaceSize<span class="o">=</span>10M
</span></span><span class="line"><span class="cl">-XX:HeapDumpPath<span class="o">=</span>/Users/fengzheng/jvmlog
</span></span></code></pre></div><h2 id="堆溢出">堆溢出</h2>
<p>堆溢出，应该是最常见的一种内存溢出的场景了。JVM 中分配绝大多数对象实例和数组都存在堆上，另外堆内存也是垃圾收集器工作的主要战场。</p>
<p>当我们的 Java 程序启动的时候，会指定堆空间的大小，新建对象和数组的时候会分配到堆上面，当新对象申请空间的时候，如果堆内存不够了，就会发生垃圾收集动作，大多数时候会发生在新生代，叫做 Minor GC。当新生代回收完成，空间仍然不够的话，会发生一次 FullGC。FullGC 后，空间仍然不够，此时就会发生 OOM 错误，也就是堆溢出。</p>
<h3 id="模拟一下这个场景">模拟一下这个场景</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">_1K</span> <span class="o">=</span> <span class="mi">1024</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">List</span><span class="o">&lt;</span><span class="kt">byte</span><span class="o">[]&gt;</span> <span class="n">byteList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">  <span class="n">quietlyWaitingForCrashHeap</span><span class="o">(</span><span class="n">byteList</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">quietlyWaitingForCrashHeap</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="kt">byte</span><span class="o">[]&gt;</span> <span class="n">byteList</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">byteList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">500</span> <span class="o">*</span> <span class="n">_1K</span><span class="o">]);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">//Thread.sleep(1000);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>上面的方法会持续的向<code>List&lt;byte[]&gt;</code>数组中每次添加500k的元素，整个堆只有20M，可想而知，程序一运行起来，马上就会将对空间填满，导致后面的元素加不进去，而又回收不掉，从而导致堆内存溢出。</p>
<p>下面是程序运行之后的结果，经过垃圾回收最终还是没有多余的空间，从而发生 <code>java.lang.OutOfMemoryError: Java heap space</code>异常。</p>
<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3771d9e922c34f38a68e7ecdd1331286~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20201016211017630"></p>
<p>发生堆内存溢出的根本原因就是使用中的对象大小超过了堆内存大小。</p>
<p>堆内存空间设置的太小，要根据预估的实际使用堆大小合理的设置堆空间设置。</p>
<p>程序有漏洞导致，某些静态变量持续的增大，例如缓存数据错误的初始化，导致缓存无止境的增加，最终导致堆内存溢出。针对这种情况，恐怕没什么好方法，除了做好测试之外，就是在问题发生后做好日志分析。</p>
<h2 id="栈溢出">栈溢出</h2>
<p>虚拟机栈是用来存储局部变量表、操作数栈、动态链接、方法出口等信息的，每调用一个 Java 方法就会为此方法在虚拟机栈中生成栈帧。</p>
<p>栈除了包括虚拟机栈之外，还包括本地方法栈，当调用的方法是本地方法（例如 C 语言实现的方法）时，会用到本地方法栈。不过，在 HotSpot 虚拟机中，虚拟机栈和本地方法栈被合二为一了。</p>
<h3 id="模拟栈溢出场景">模拟栈溢出场景</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">stackOverflow</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">* stackoverflow
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">stackOverflow</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">stackOverflow</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在上面的代码中，stackOverflow() 方法的调用是一个无限递归的过程，没有递归出口。前面说了，每调用一个方法就会在虚拟机栈中生成栈帧，无限的递归，必定造成无限的生成栈帧，最后导致栈空间被填满，从而发生溢出。</p>
<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0144fcce3ffb48d480f455788623e403~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20201019122447325"></p>
<p>上面模拟了最常见的一种状况，产生这种状况的原因很可能是由于程序 bug 导致的，一般来说，递归必定会有递归出口，如果由于某些原因导致了程序在执行的过程中无法达到出口条件，那就会造成这种异常。还有就是循环体，循环体的循环次数如果过大，也有可能出现栈溢出。</p>
<p>另外还可能是其他比较不容易出现的原因，比如创建的线程数过多，线程创建要在虚拟机栈中分配空间，如果创建线程过多，可能会出现 <code>OutOfMemoryError</code>异常，但是一般来说，都会用线程池的方法代替手动创建线程的方式，所以，这种情况不容易出现。</p>
<h2 id="元空间溢出">元空间溢出</h2>
<p>用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译(JIT)后的代码等数据，在 JDK 8 中，已经用 metaSpace 代替了永久代的。默认情况下 metaSpace 的大小是没有限制的，也就是所在服务器的实际内存大小，但是，一般情况下，最好还是设置元空间的大小。</p>
<p>一般在产生大量动态生成类的情景中，可能会出现元空间的内存溢出。</p>
<h3 id="模拟元空间溢出">模拟元空间溢出</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">List</span><span class="o">&lt;</span><span class="kt">byte</span><span class="o">[]&gt;</span> <span class="n">byteList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//quietlyWaitingForCrashHeap(byteList);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// stackOverflow();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">methodAreaOverflow</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">methodAreaOverflow</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Enhancer</span> <span class="n">enhancer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Enhancer</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">enhancer</span><span class="o">.</span><span class="na">setUseCache</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">enhancer</span><span class="o">.</span><span class="na">setSuperclass</span><span class="o">(</span><span class="n">MethodOverflow</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">enhancer</span><span class="o">.</span><span class="na">setCallback</span><span class="o">(</span><span class="k">new</span> <span class="n">MethodInterceptor</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">      <span class="kd">public</span> <span class="n">Object</span> <span class="nf">intercept</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">,</span> <span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">objects</span><span class="o">,</span> <span class="n">MethodProxy</span> <span class="n">methodProxy</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">methodProxy</span><span class="o">.</span><span class="na">invokeSuper</span><span class="o">(</span><span class="n">o</span><span class="o">,</span> <span class="n">objects</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">      <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">enhancer</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(++</span><span class="n">i</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>通过 CGLIB 的方式动态的创建很多个动态类，这样一来，类信息就会越来越多的存到元空间，从而导致元空间溢出。</p>
<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e20f0e634ef341ee8a0617e62c2768c0~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20201019163227576"></p>
<p>例如在使用 Spring、 MyBatis 等技术框架的时候会动态创建 Bean 实例类，另外，Spring AOP 也会产生动态代理类。</p>
<h2 id="堆外内存溢出">堆外内存溢出</h2>
<p>大多数情况下，内存都会在 JVM 堆内存中分配，很少情况下需要直接在堆外分配内存空间。使用堆外内存的几个好处是：</p>
<ul>
<li>在进程间可以共享，减少虚拟机间的复制</li>
<li>对垃圾回收停顿的改善：如果应用某些长期存活并大量存在的对象，经常会出发YGC或者FullGC，可以考虑把这些对象放到堆外。过大的堆会影响Java应用的性能。如果使用堆外内存的话，堆外内存是直接受操作系统管理( 而不是虚拟机 )。这样做的结果就是能保持一个较小的堆内内存，以减少垃圾收集对应用的影响。</li>
<li>在某些场景下可以提升程序I/O操纵的性能。少去了将数据从堆内内存拷贝到堆外内存的步骤。</li>
</ul>
<p>通常在需要大量频繁的进行 IO 操作的时候会用到堆外内存，例如 Netty、RocketMQ 等使用到了堆外内存，目的就是为了加快速度。</p>
<p>所以，在出现系统内存占用过大的情况时，排查堆栈无果后，可以看一下堆外内存的使用情况，看看是不是堆外内存溢出了。</p>
<h2 id="总结">总结</h2>
<h3 id="事前做好配置">事前做好配置</h3>
<p>JVM 问题本身就是比较抽象和难以直观发现的，所以在项目上线前除了做好代码逻辑的测试外，还要对 JVM 参数进行合理配置，根据应用程序的体量和特点选择好合适的参数，比如堆栈大小、垃圾收集器种类等等。</p>
<p>另外，垃圾收集日志一定要有保留，还有就是发生内存溢出时要保存 dump 文件。</p>
<h3 id="事中做好监控">事中做好监控</h3>
<p>在程序上线运行的过程中，做好 JVM 的监控工作，比如用 Spring Admin 这种比较轻量的监控工具，或者大型项目用 Cat、SkyWallking 等这些分布式链路监控系统。</p>
<h3 id="事后做好现场保护和分析">事后做好现场保护和分析</h3>
<p>再合理的参数配置和监控平台，也难免不发生异常，这也是很正常的，不出现异常才有问题好吧。在发生异常之后，要及时的保留现场，如果是多实例应用，可以暂时将发生异常的实例做下线处理，然后再进行问题的排查。如果是单实例的服务，那要及时的确认最新的日志和dump已经留存好，确认完成后，再采取错误让服务重启。</p>
]]></content:encoded></item><item><title>手把手教你编译属于自己的 JDK</title><link>https://moonkite.cn/category/java/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E8%87%AA%E5%B7%B1%E7%9A%84-JDK/</link><pubDate>Sat, 03 Apr 2021 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/java/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E8%87%AA%E5%B7%B1%E7%9A%84-JDK/</guid><description>你每天写的 Java 代码都需要 JDK 的支持，都要跑在 JVM 上，难道你就不好奇 JDK 长什么样子吗。好奇，就来编译并实现一个自己的 JDK 吧。 本次编译环境 macOS 10.12，编</description><content:encoded><![CDATA[<p>你每天写的 Java 代码都需要 JDK 的支持，都要跑在 JVM 上，难道你就不好奇 JDK 长什么样子吗。好奇，就来编译并实现一个自己的 JDK 吧。</p>
<p>本次编译环境 macOS 10.12，编译的是 JDK 11 版本。</p>
<h3 id="安装-openjdk-11">安装 OpenJDK 11</h3>
<p>编译 OpenJDK 需要先在机器上安装 OpenJDK 10 或者 OpenJDK 11，作为 Boot JDK。
先安装 openJDK 11 编译需要，可以到 adoptopenjdk 网站去下载。</p>
<p><strong>pkg 格式安装</strong></p>
<p>进入页面 <code>https://adoptopenjdk.net/index.html?variant=openjdk11&amp;jvmVariant=hotspot</code> 直接下载下载，然后双击就可以完成安装了。</p>
<p><strong>tar.gz 格式安装</strong></p>
<p>1、进入页面 <code>https://adoptopenjdk.net/installation.html?variant=openjdk11&amp;jvmVariant=hotspot#x64_mac-jdk</code> 下载 tar.gz 包</p>
<p>2、解压</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">tar -xf OpenJDK11U-jdk_x64_mac_hotspot_11.0.5_10.tar.gz
</span></span></code></pre></div><p>解压后是一个 macOS 包，可通过右键-&gt;显示包内容查看里面的文件。</p>
<p>3、加入环境变量 PATH 中，当然如果你使用其他版本的 JDK 作为开发使用，请忽略这一步。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span><span class="nv">$PWD</span>/jdk-11.0.5+10/Contents/Home/bin:<span class="nv">$PATH</span>
</span></span></code></pre></div><p>4、macOS JDK 默认目录在<code>/Library/Java/JavaVirtualMachines</code>,把第 2 步解压的内容放到此目录下，之后编译的过程中会在这个目录下查找 JDK 10 或 JDK 11。</p>
<p>下面是我本地的目录结构，有 7 、8、11 这三个版本，开发时候还是默认使用 8 的。</p>
<p><img src="https://hexo.moonkite.cn/blog/1.png" alt="1"></p>
<h3 id="安装-xcode">安装 xcode</h3>
<p>实际上我们需要的不是 xcode，而是 LLVM 的编译命令 clang。当然你可以单独安装 LLVM，但限于此篇是写给 Java 开发者的，安装 xcode 是最简单的版本。</p>
<p>我本地是很早之前安装的 xcode 8.1，编译起来是没问题的，如果你用的是比较新的版本，应该也不会出现什么问题，可以亲自试一试。</p>
<h3 id="开始编译">开始编译</h3>
<p><strong>1、下载 OpenJDK 11 源码</strong></p>
<p>OpenJDK 的源码放在了网站 <a href="http://hg.openjdk.java.net/">http://hg.openjdk.java.net/</a> 上，我们要下载的 JDK11 目录在 <a href="http://hg.openjdk.java.net/jdk-updates/jdk11u/">http://hg.openjdk.java.net/jdk-updates/jdk11u/</a>。</p>
<p>进入页面后，先点击左侧的 browse，再选择一种压缩格式下载。</p>
<p><img src="https://hexo.moonkite.cn/blog/2.png" alt="2"></p>
<p>当然还可以用 hg 命令 clone 到本地，使用 hg 需要安装 mercurial，如果网速不好或者不稳定，建议不要使用这种方式。</p>
<pre tabindex="0"><code>hg clone https://hg.openjdk.java.net/jdk/jdk11/
</code></pre><p><strong>2、解压源码包</strong></p>
<p>将你刚刚下载的压缩包解压，请解压到一个全英文目录下，不要使用中文，减少编译时带来的麻烦。</p>
<p><strong>3、configure</strong></p>
<p>进入上一步解压后的目录，执行如下命令。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sh configure --with-target-bits<span class="o">=</span><span class="m">64</span> --enable-ccache --with-jvm-variants<span class="o">=</span>server  --with-boot-jdk-jvmargs<span class="o">=</span><span class="s2">&#34;-Xlint:deprecation -Xlint:unchecked&#34;</span> --disable-warnings-as-errors --with-debug-level<span class="o">=</span>slowdebug 2&gt;<span class="p">&amp;</span><span class="m">1</span> <span class="p">|</span> tee configure_mac_x64.log
</span></span></code></pre></div><p>执行这个命令的前提是我已经将 OpenJDK 11 放到了 <code>/Library/Java/JavaVirtualMachines</code>目录下。</p>
<p>如果不放到这个目录下，也是可以的，需要额外指定参数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">--with-boot-jdk<span class="o">=</span>OpenJDK 目录
</span></span></code></pre></div><p>如果出现如下输出，说明这一步就正常了。</p>
<p><img src="https://hexo.moonkite.cn/blog/3.png" alt="3"></p>
<p><strong>4、make</strong></p>
<p>正式开始编译了，使用 make 命令即可。</p>
<pre tabindex="0"><code>make
</code></pre><p>首次编译会比较慢，我的是 MacBook Pro i5 8G 的那款，大概编译了 10 几分钟吧。当出现如下输出的时候，说明编译成功。</p>
<pre tabindex="0"><code>Finished building target &#39;default (exploded-image)&#39; in configuration &#39;macosx-x86_64-normal-server-slowdebug&#39;
</code></pre><p>编译好之后，会在当前目录出现 build 目录，进去之后，看到有个 <code>macosx-x86_64-normal-server-slowdebug</code> 就是最终的目录。</p>
<h3 id="idea-中配置使用编译好的-jdk">IDEA 中配置使用编译好的 JDK</h3>
<p>1、打开 IDEA ,找到 File-&gt;Project Structure。</p>
<p><img src="https://hexo.moonkite.cn/blog/4.png" alt="4"></p>
<p>2、添加一个 JDK</p>
<p><img src="https://hexo.moonkite.cn/blog/5.png" alt="5"></p>
<p>3、选择上面源码编译好的 jdk</p>
<p><img src="https://hexo.moonkite.cn/blog/6.png" alt="6"></p>
<p>4、最后启动项目的时候指定这个 JDK 就可以了。</p>
<h3 id="用-clion-调试">用 CLion 调试</h3>
<p>1、打开 CLion ,导入项目，选择下载的源码所在位置的 src 目录。</p>
<p><img src="https://hexo.moonkite.cn/blog/7.png" alt="7"></p>
<p>2、配置 Debug Configurations，选择 Executable 为编译好的 java 可执行程序，在 bin 目录下，并且移除 Build 设置。</p>
<p>Program arguments 设置为 -version，也可以设置其他的。设置为 -version 的意思是 java -version。</p>
<p><img src="https://hexo.moonkite.cn/blog/8.png" alt="8"></p>
<p>3、最后在源码中打个断点，比如 jni.cpp 或 thread.cpp 中，然后点击 debug ,就可以调试啦。</p>
<h3 id="打造自己的-jdk">打造自己的 JDK</h3>
<p>标题说的有点儿悬，打造自己的 JDK 哪儿有那么容易，况且还确实没那个实力。这里就是介绍一种思路，比如有些时候，我们调试 Java 代码最后发现走到了 JVM 层，这种情况下，我们就跟不进去了。执行到 JVM 层之后，里面的各种变量是怎么变换的我们就不知道了。这时候，我们找到 JVM 对应的代码稍微改一下，比如加个 printf 输出一下参数值就可以清晰的看出来了。</p>
<p><strong>修改 JDK 代码</strong></p>
<p>我在打开的 CLion 中找到了 java.c 文件的 <code>JavaMain(void * _args)</code> 方法，在里面加了一行打印代码，就勉强算实现了自己的 JDK 吧(微笑脸)。</p>
<p>万里长征第一步嘛，别的不重要，留下脚印儿才是关键。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">printf</span><span class="p">(</span><span class="s">&#34;古时的风筝 JDK </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span></code></pre></div><p><img src="https://hexo.moonkite.cn/blog/9.png" alt="9"></p>
<p><strong>重新编译修改后的源码</strong></p>
<p>修改之后，在终端中进入到源码目录的根目录，然后执行 make 命令。</p>
<p>因为之前已经编译过了，所以再次执行 make 是进行的增量编译，所以速度很快。</p>
<p><strong>好了，见证奇迹的时刻到了</strong></p>
<p>我们之前已经在 IDEA 中添加了编译好的 JDK，并且指定给了一个项目。仅为测试，代码如下。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;hello jvm&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>当我们运行这个项目的时候，如果是平常的 JDK，会在控制台输出 hello jvm ，对不对。</p>
<p>可是，现在指定的不是平常的 JDK ，是被我加持过的 JDK 。</p>
<p>开始运行，输出的结果如下，看到没，刚刚加上的那行代码起作用了。</p>
<p><img src="https://hexo.moonkite.cn/blog/10.png" alt="10"></p>
<h3 id="风筝说">风筝说</h3>
<p>真正能做到 JDK 定制开发的人并不多，我也完全没这个实力。但是每个 Java 开发者都编译一下 JDK 源码，翻一翻代码还是很有必要的。毕竟，我们每天写的代码都需要 JDK 的支持，都要跑在 JVM 上，我们就不好奇它们长成什么模样吗。</p>
<p>另外，这也可能为我们日常解决问题提供一种思路。有人说，最好的老师就是搜索引擎，大多数情况下是没错，但有的时候最好的方式往往就是看一眼源码。</p>
<p>为什么有的人解决问题的速度快，有些看似不能解决的问题放到大牛手里就能很快解决。有时候就是解决问题的维度不一样，人家是在三维的世界里，你却一直在二维的平面里转圈圈，比方说遇到程序问题，只能分析 Java 层面的问题这就是二维，进到 JDK、JVM 源码那就是进到的三维。维度高了，角度变了，解决问题的可能性和方式也就多了。这就好比三体里高等文明利用二向箔进行打击，完全不在一个体量下。</p>
<p>赶紧行动吧，编译一个你自己的 JDK。</p>
]]></content:encoded></item></channel></rss>