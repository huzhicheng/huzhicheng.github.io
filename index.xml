<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:webfeeds="http://webfeeds.org/rss/1.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>古时的风筝</title><link>https://moonkite.cn/</link><description>Recent content on 古时的风筝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 02 Jun 2023 08:56:23 +0800</lastBuildDate><atom:link href="https://moonkite.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>Java 上进了，JDK21马上就要来了，感受一下它的魅力</title><link>https://moonkite.cn/category/java/JDK21%E9%A9%AC%E4%B8%8A%E5%B0%B1%E8%A6%81%E6%9D%A5%E4%BA%86%E6%84%9F%E5%8F%97%E4%B8%80%E4%B8%8B%E5%AE%83%E7%9A%84%E9%AD%85%E5%8A%9B/</link><pubDate>Fri, 02 Jun 2023 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/java/JDK21%E9%A9%AC%E4%B8%8A%E5%B0%B1%E8%A6%81%E6%9D%A5%E4%BA%86%E6%84%9F%E5%8F%97%E4%B8%80%E4%B8%8B%E5%AE%83%E7%9A%84%E9%AD%85%E5%8A%9B/</guid><description>目前 Java 的最新稳定版是 JDK 20，但这是个过渡版，JDK21就是 LTS 版的了，也快要发布了，在今年9月份（也就是2023年9月）就要正式发布了。 但是，</description><content:encoded><![CDATA[<p>目前 Java 的最新稳定版是 JDK 20，但这是个过渡版，JDK21就是 LTS 版的了，也快要发布了，在今年9月份（也就是2023年9月）就要正式发布了。</p>
<p>但是，猜都不用猜，你肯定还在用 Java 8 吧！</p>
<h2 id="更丝滑的并发编程模式">更丝滑的并发编程模式</h2>
<p>如果说之前的 JDK17你还觉得没必要折腾，那 JDK21确实有必要关注一下了。因为 JDK21 引入了一种新型的并发编程模式。</p>
<p>当前 Java 中的多线程并发编程绝对是另我们都非常头疼的一部分，感觉就是学起来难啃，用起来难用。但是转头看看使用其他语言的朋友们，根本就没有这个烦恼嘛，比如 GoLang，感觉人家用起来就很丝滑呢。</p>
<p>JDK21 中就在这方面做了很大的改进，让Java并发编程变得更简单一点，更丝滑一点。确切的说，在 JDK19或JDK20中就有这些改进了。</p>
<p>那具体是什么呢？让我们来具体来看一下。下面是JDK21的 Feature。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20230531172947636.png" alt=""></p>
<p>其中<code>Virtual Threads</code>、<code>Scoped Values</code>、<code>Structured Concurrency</code>就是针对多线程并发编程的几个功能。我们今天也主要来说一下他们。</p>
<h3 id="虚拟线程virtual-threads">虚拟线程（Virtual Threads）</h3>
<p>虚拟线程是基于协程的线程，它们与其他语言中的协程具有相似之处，但也存在一些不同之处。</p>
<p>虚拟线程是依附于主线程的，如果主线程销毁了，那虚拟线程也不复存在。</p>
<p>相同之处：</p>
<ol>
<li>虚拟线程和协程都是轻量级的线程，它们的创建和销毁的开销都比传统的操作系统线程要小。</li>
<li>虚拟线程和协程都可以通过暂停和恢复来实现线程之间的切换，从而避免了线程上下文切换的开销。</li>
<li>虚拟线程和协程都可以使用异步和非阻塞的方式来处理任务，提高应用程序的性能和响应速度。</li>
</ol>
<p>不同之处：</p>
<ol>
<li>虚拟线程是在 JVM 层面实现的，而协程则是在语言层面实现的。因此，虚拟线程的实现可以与任何支持 JVM 的语言一起使用，而协程的实现则需要特定的编程语言支持。</li>
<li>虚拟线程是一种基于线程的协程实现，因此它们可以使用线程相关的 API，如 <code>ThreadLocal</code>、<code>Lock</code> 和 <code>Semaphore</code>。而协程则不依赖于线程，通常需要使用特定的异步编程框架和 API。</li>
<li>虚拟线程的调度是由 JVM 管理的，而协程的调度是由编程语言或异步编程框架管理的。因此，虚拟线程可以更好地与其他线程进行协作，而协程则更适合处理异步任务。</li>
</ol>
<p>总的来说，虚拟线程是一种新的线程类型，它可以提高应用程序的性能和资源利用率，同时也可以使用传统线程相关的 API。虚拟线程与协程有很多相似之处，但也存在一些不同之处。</p>
<p>虚拟线程确实可以让多线程编程变得更简单和更高效。相比于传统的操作系统线程，虚拟线程的创建和销毁的开销更小，线程上下文切换的开销也更小，因此可以大大减少多线程编程中的资源消耗和性能瓶颈。</p>
<p>使用虚拟线程，开发者可以像编写传统的线程代码一样编写代码，而无需担心线程的数量和调度，因为 JVM 会自动管理虚拟线程的数量和调度。此外，虚拟线程还支持传统线程相关的 API，如 <code>ThreadLocal</code>、<code>Lock</code> 和 <code>Semaphore</code>，这使得开发者可以更轻松地迁移传统线程代码到虚拟线程。</p>
<p>虚拟线程的引入，使得多线程编程变得更加高效、简单和安全，使得开发者能够更加专注于业务逻辑，而不必过多地关注底层的线程管理。</p>
<h3 id="结构化并发structured-concurrency">结构化并发（Structured Concurrency）</h3>
<p>结构化并发是一种编程范式，旨在通过提供结构化和易于遵循的方法来简化并发编程。使用结构化并发，开发人员可以创建更容易理解和调试的并发代码，并且不容易出现竞争条件和其他与并发有关的错误。在结构化并发中，所有并发代码都被结构化为称为任务的定义良好的工作单元。任务以结构化方式创建、执行和完成，任务的执行总是保证在其父任务完成之前完成。</p>
<p>Structured Concurrency（结构化并发）可以让多线程编程更加简单和可靠。在传统的多线程编程中，线程的启动、执行和结束是由开发者手动管理的，因此容易出现线程泄露、死锁和异常处理不当等问题。</p>
<p>使用结构化并发，开发者可以更加自然地组织并发任务，使得任务之间的依赖关系更加清晰，代码逻辑更加简洁。结构化并发还提供了一些异常处理机制，可以更好地管理并发任务中的异常，避免因为异常而导致程序崩溃或数据不一致的情况。</p>
<p>除此之外，结构化并发还可以通过限制并发任务的数量和优先级，防止资源竞争和饥饿等问题的发生。这些特性使得开发者能够更加方便地实现高效、可靠的并发程序，而无需过多关注底层的线程管理。</p>
<h3 id="作用域值scoped-values">作用域值（Scoped Values）</h3>
<p>作用域值是JDK 20中的一项功能，允许开发人员创建作用域限定的值，这些值限定于特定的线程或任务。作用域值类似于线程本地变量，但是设计为与虚拟线程和结构化并发配合使用。它们允许开发人员以结构化的方式在任务和虚拟线程之间传递值，无需复杂的同步或锁定机制。作用域值可用于在应用程序的不同部分之间传递上下文信息，例如用户身份验证或请求特定数据。</p>
<h2 id="试验一下">试验一下</h2>
<p>进行下面的探索之前，你要下载至少 JDK19或者直接下载 JDK20，JDK 20 目前（截止到2023年9月份）是正式发布的最高版本，如果你用 JDK 19的话，没办法体验到Scoped Values的功能。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20230428164027447.png" alt=""></p>
<p>或者是直接下载 JDK 21 的 Early-Access Builds（早期访问版本）。在这个地址下载 「https://jdk.java.net/21/」，下载对应的版本。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20230428165054158.png" alt=""></p>
<p>如果你用的是 IDEA ，那你的IDEA 版本最起码是2022.3 这个版本或者之后的，否则不支持这么新的 JDK 版本。</p>
<p>如果你用的是 JDK19或者 JDK20的话，要在你的项目设置中将 <code>language level</code>设置为19或20的 Preview 级别，否则编译的时候会提示你无法使用预览版的功能，虚拟线程就是预览版的功能。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20230428165350127.png" alt=""></p>
<p>如果你用的是 JDK21的话，将 <code>language level</code> 设置为 <code>X -Experimental Features</code>，另外，因为 JDK21不属于正式版本，所以需要到 IDEA 的设置中（注意是 IDEA 的设置，不是项目的设置了），将这个项目的 <code>Target bytecode version</code>手动修改为21，目前可选的最高就是20，也就是JDK20。设置为21之后，就可以使用 JDK21中的这些功能了。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20230531214527330.png" alt=""></p>
<h2 id="虚拟线程的例子">虚拟线程的例子</h2>
<p>我们现在启动线程是怎么做的呢？</p>
<p>先声明一个线程类，<code>implements</code> 自 <code>Runnable</code>，并实现 <code>run</code>方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleThread</span> <span class="kd">implements</span> <span class="n">Runnable</span><span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;当前线程名称：&#34;</span> <span class="o">+</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">        <span class="k">try</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>然后就可以使用这个线程类，然后启动线程了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="k">new</span> <span class="n">SimpleThread</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</span></span></code></pre></div><p>中规中矩，没毛病。</p>
<p>有了虚拟线程之后呢，怎么实现呢？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Thread</span><span class="o">.</span><span class="na">ofPlatform</span><span class="o">().</span><span class="na">name</span><span class="o">(</span><span class="s">&#34;thread-test&#34;</span><span class="o">).</span><span class="na">start</span><span class="o">(</span><span class="k">new</span> <span class="n">SimpleThread</span><span class="o">());</span>
</span></span></code></pre></div><p>下面是几种使用虚拟线程的方式。</p>
<p>1、直接启动一个虚拟线程</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">startVirtualThread</span><span class="o">(</span><span class="k">new</span> <span class="n">SimpleThread</span><span class="o">());</span>
</span></span></code></pre></div><p>2、使用 ofVirtual()，builder 方式启动虚拟线程，可以设置线程名称、优先级、异常处理等配置</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Thread</span><span class="o">.</span><span class="na">ofVirtual</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">name</span><span class="o">(</span><span class="s">&#34;thread-test&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">start</span><span class="o">(</span><span class="k">new</span> <span class="n">SimpleThread</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">//或者
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">ofVirtual</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">name</span><span class="o">(</span><span class="s">&#34;thread-test&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">uncaughtExceptionHandler</span><span class="o">((</span><span class="n">t</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">  <span class="o">})</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">unstarted</span><span class="o">(</span><span class="k">new</span> <span class="n">SimpleThread</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</span></span></code></pre></div><p>3、使用 Factory 创建线程</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">ThreadFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">ofVirtual</span><span class="o">().</span><span class="na">factory</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">newThread</span><span class="o">(</span><span class="k">new</span> <span class="n">SimpleThread</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="n">thread</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&#34;thread-test&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</span></span></code></pre></div><p>4、使用 Executors 方式</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">ExecutorService</span> <span class="n">executorService</span> <span class="o">=</span> <span class="n">Executors</span><span class="o">.</span><span class="na">newVirtualThreadPerTaskExecutor</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">Future</span><span class="o">&lt;?&gt;</span> <span class="n">submit</span> <span class="o">=</span> <span class="n">executorService</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="k">new</span> <span class="n">SimpleThread</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="n">Object</span> <span class="n">o</span> <span class="o">=</span> <span class="n">submit</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
</span></span></code></pre></div><h2 id="结构化编程的例子">结构化编程的例子</h2>
<p>想一下下面这个场景，假设你有三个任务要同时进行，只要任意一个任务执行完成并返回结果了，那就可以直接用这个结果了，其他的两个任务就可以停止了。比如说一个天气服务，通过三个渠道获取天气情况，只要有一个渠道返回就可以了。</p>
<p>这种场景下， 在 Java 8 下应该怎么做呢，当然也可以了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 执行任务并返回 Future 对象列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">List</span><span class="o">&lt;</span><span class="n">Future</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">futures</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="na">invokeAll</span><span class="o">(</span><span class="n">tasks</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 等待任一任务完成并获取结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="na">invokeAny</span><span class="o">(</span><span class="n">tasks</span><span class="o">);</span>
</span></span></code></pre></div><p>使用 <code>ExecutorService</code>的<code>invokeAll</code>和<code>invokeAny</code>实现，但是会有一些额外的工作，在拿到第一个结果后，要手动关闭另外的线程。</p>
<p>而 JDK21中呢，可以用结构化编程实现。</p>
<p><code>ShutdownOnSuccess</code>捕获第一个结果并关闭任务范围以中断未完成的线程并唤醒调用线程。
适用于任意子任务的结果都可以直接使用，并且无需等待其他未完成任务的结果的情况。
它定义了获取第一个结果或在所有子任务失败时抛出异常的方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="o">(</span><span class="n">var</span> <span class="n">scope</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StructuredTaskScope</span><span class="o">.</span><span class="na">ShutdownOnSuccess</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Future</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">res1</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">runTask</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">Future</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">res2</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">runTask</span><span class="o">(</span><span class="mi">2</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">Future</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">res3</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">runTask</span><span class="o">(</span><span class="mi">3</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">scope</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;scope:&#34;</span> <span class="o">+</span> <span class="n">scope</span><span class="o">.</span><span class="na">result</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ExecutionException</span> <span class="o">|</span> <span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">runTask</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">long</span> <span class="n">l</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Random</span><span class="o">().</span><span class="na">nextLong</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">l</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;第&#34;</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">&#34;个任务：&#34;</span> <span class="o">+</span> <span class="n">s</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><strong>ShutdownOnFailure</strong></p>
<p>执行多个任务，只要有一个失败（出现异常或其他主动抛出异常情况），就停止其他未执行完的任务，使用scope.throwIfFailed捕捉并抛出异常。
如果所有任务均正常，则使用 Feture.get() 或*Feture.resultNow() 获取结果</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="o">(</span><span class="n">var</span> <span class="n">scope</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StructuredTaskScope</span><span class="o">.</span><span class="na">ShutdownOnFailure</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Future</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">res1</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">runTaskWithException</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">Future</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">res2</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">runTaskWithException</span><span class="o">(</span><span class="mi">2</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">Future</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">res3</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">runTaskWithException</span><span class="o">(</span><span class="mi">3</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">scope</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">scope</span><span class="o">.</span><span class="na">throwIfFailed</span><span class="o">(</span><span class="n">Exception</span><span class="o">::</span><span class="k">new</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">res1</span><span class="o">.</span><span class="na">resultNow</span><span class="o">();</span> <span class="c1">//或 res1.get()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">res1</span><span class="o">,</span> <span class="n">res2</span><span class="o">,</span><span class="n">res3</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">Future</span><span class="o">::</span><span class="n">resultNow</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">joining</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;直接结果:&#34;</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//throw new RuntimeException(e);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 有一定几率发生异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">runTaskWithException</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">long</span> <span class="n">l</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Random</span><span class="o">().</span><span class="na">nextLong</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="o">(</span><span class="n">l</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">throw</span> <span class="k">new</span> <span class="n">InterruptedException</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">l</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;第&#34;</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">&#34;个任务：&#34;</span> <span class="o">+</span> <span class="n">s</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="scoped-values-的例子">Scoped Values 的例子</h2>
<p>我们肯定都用过 <code>ThreadLocal</code>，它是线程本地变量，只要这个线程没销毁，可以随时获取 ThredLocal 中的变量值。Scoped Values 也可以在线程内部随时获取变量，只不过它有个作用域的概念，超出作用域就会销毁。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ScopedValueExample</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">final</span> <span class="kd">static</span> <span class="n">ScopedValue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">LoginUser</span> <span class="o">=</span> <span class="n">ScopedValue</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ScopedValue</span><span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">LoginUser</span><span class="o">,</span> <span class="s">&#34;张三&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">run</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">new</span> <span class="n">Service</span><span class="o">().</span><span class="na">login</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">                <span class="o">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2000</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Service</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="nf">login</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;当前登录用户是：&#34;</span> <span class="o">+</span> <span class="n">LoginUser</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>上面的例子模拟一个用户登录的过程，使用 <code>ScopedValue.newInstance()</code>声明了一个 <code>ScopedValue</code>，用 <code>ScopedValue.where</code>给 <code>ScopedValue</code>设置值，并且使用 run 方法执行接下来要做的事儿，这样一来，<code>ScopedValue</code>就在 run() 的内部随时可获取了，在run方法中，模拟调用了一个service 的login方法，不用传递LoginUser这个参数，就可以直接通过<code>LoginUser.get</code>方法获取当前登录用户的值了。</p>
]]></content:encoded></item><item><title>VsCode ChatGPT 插件，一个代码助手</title><link>https://moonkite.cn/category/product/1-VsCode-ChatGPT-%E6%8F%92%E4%BB%B6%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81%E5%8A%A9%E6%89%8B/</link><pubDate>Fri, 02 Jun 2023 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/product/1-VsCode-ChatGPT-%E6%8F%92%E4%BB%B6%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81%E5%8A%A9%E6%89%8B/</guid><description>一个 VsCode 插件版的代码助手，通过接入 ChatGPT，直接在 VsCode 中向 ChatGPT 提问</description><content:encoded><![CDATA[<p><strong>安装地址</strong>：<a href="https://marketplace.visualstudio.com/items?itemName=fengzheng.code-chatgpt-assistant"><strong>mini ChatGPT</strong></a></p>
<p>其实很早之前就想学学 VSCode 插件开发了，但是又不知道做什么，加上我这半吊子前端水平，迟迟没有动手。</p>
<p>最近 ChatGPT 火的一塌糊涂，我也一直在用，真的非常好用，有些问题之前需要 Google 搜索，现在用 ChatGPT 基本上都能直接解决，效率提升了不少。</p>
<p>但是吧，浏览器和 IDE 来回切换又很麻烦，所以我灵机一动，那就开发个 ChatGPT 插件吧，即可以学习学习 VSCode 插件开发，又可以做一个方便的效率工具，岂不是一举两得，美哉美哉。</p>
<p>于是我就动手写了下面这个插件，叫做 <code>mini ChatGPT</code>，现在已经发布到 VSCode 插件市场了。</p>
<p>有条件的同学可以安装一下，试试效果如何。</p>
<p><strong>插件功能特点</strong></p>
<ul>
<li>界面简洁，没有多余的干扰；</li>
<li>像 ChatGPT 官网输出效果一致，打字效果实时输出；</li>
<li>支持两轮上下文（太多了浪费 tokens），大致等于支持上下文；</li>
<li>代码美化+格式化，并且可以一键复制，直接粘贴到 vscode 中；</li>
</ul>
<p><img src="https://hexo.moonkite.cn/blog/image-20230509181750193.png" alt=""></p>
<h2 id="插件安装">插件安装</h2>
<p><strong>当然了，这是需要科学上网的。</strong></p>
<p>你可以直接在 VSCode 的商店直接搜索 <code>mini ChatGPT</code>安装。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20230509183628014.png" alt=""></p>
<p>也可以到应用市场上安装。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20230509183750997.png" alt=""></p>
<p>插件地址：https://marketplace.visualstudio.com/items?itemName=fengzheng.code-chatgpt-assistant</p>
<h2 id="插件使用">插件使用</h2>
<ol>
<li>点击查看-&gt;命令面板，或者使用快捷键（MacOS: Shift + Command + P，Windows:Shift + Control + P</li>
<li>输入 <code>Chat</code> 并回车。
<img src="https://hexo.moonkite.cn/blog/20230509111926.png" alt=""></li>
<li>如果是首次使用，会弹出提示输入框，在此输入 ChatGPT 的 API。使用的就是原滋原味的 ChatGPT API 接口，官网上都写的很清楚，所以需要使用插件的小伙伴提供自己账号的 API key。下面有介绍如何获取ChatGPT API key。
<img src="https://hexo.moonkite.cn/blog/20230509112123.png" alt=""></li>
<li>之后就可以使用啦
<img src="https://hexo.moonkite.cn/blog/20230509112311.png" alt=""></li>
<li>如果之后想更换 ChatGPT 的 API key，在命令面板中输入 <code>ChatGPT API</code> 即可。</li>
</ol>
<p><strong>使用建议</strong></p>
<p>此插件只有一个 webview 实现，打开之后独占一个 tab，可以设置向左或向右拆分，然后在左侧使用此插件向 ChatGPT 提问，右侧是代码文件，这样就不用来回切换了，而且可以将代码片段一键复制，然后直接运行。</p>
<p><img src="https://hexo.moonkite.cn/blog/chatgpt.gif" alt=""></p>
<p><strong>获取 ChatGPT API key</strong></p>
<ol>
<li>
<p>先准备好科学上网，不要用亚洲节点。</p>
</li>
<li>
<p>之后到 <a href="https://platform.openai.com/">OpenAI 官网</a>注册账号。</p>
</li>
<li>
<p>到<a href="https://platform.openai.com/account/api-keys">个人中心</a> 创建一个 API key。</p>
</li>
</ol>
<p><img src="https://hexo.moonkite.cn/blog/20230509133206.png" alt=""></p>
<h2 id="开发历程">开发历程</h2>
<p>作为一个后端开发，我的前端水平是非常一般的，所以代码中有瑕疵的地方还请见谅。对了，代码已经放到 GitHub  上了。</p>
<p>仓库地址：https://github.com/huzhicheng/vscode-ChatGPT</p>
<p>VSCode 插件开发，官方建议是用 TypeScript 开发，所以项目完全采用了 TS 开发。由于功能比较简单，没有那么多复杂的设置，由于边学边做，太复杂的也没考虑。整个插件的核心其实就是一个 <code>webview</code>，在webview中实现界面布局和样式，难点就在于webview与插件本身来回的数据传递，但也都是常规用法。</p>
<p>整个写代码的过程其实也就几个小时，当然过程中的遇到的一些问题我都是跟 ChatGPT 提问的，包括样式都是直接描述需求，ChatGPT 给我一个大致的框架，我再微调一下就可以了。</p>
<p>所以这样看下来，其实是我和 ChatGPT 合作开发的。</p>
<p>后来发布到应用商店，写 readme 介绍和使用说明花了一些时间。</p>
<h2 id="问题和建议">问题和建议</h2>
<p>目前的版本功能比较简单，没有 ChatGPT 官方的聊天记录列表功能，如果真的有人用的话，后期考虑加上。</p>
<p>由于ChatGPT 官方并未提供上下文的 API 支持，所以只能采用其他方式模仿上下文能力，目前的做法是记录前两轮提问和回答，然后在下次提问的时候，将前两轮的提问和回答告诉 ChatGPT ，并且明确告诉 ChatGPT，例如下面这样。</p>
<p>第一轮问题：你好。</p>
<p>第一轮回答：你好，请问有什么要帮忙的吗？</p>
<p>第二论问题：请帮我写一段 Python 爬虫抓取知乎回答的 demo。</p>
<p>第二轮回答：好的，下面是一段抓取知乎回答的 Python 示例。&hellip;.省略多行代码。</p>
<p>第三轮问题：帮我改成 Java 的。</p>
<p>这时候，我会将实际的 prompt 改成下面这样的。</p>
<blockquote>
<p>下面中括号部分是前两轮的问题和回答，只用作参考。[my question is:&ldquo;你好&rdquo;,your anwser is:&ldquo;你好，请问有什么要帮忙的吗？&quot;.my question is:&ldquo;请帮我写一段 Python 爬虫抓取知乎回答的 demo。&quot;,your anwser is:&ldquo;好的，下面是一段抓取知乎回答的 Python 示例。&hellip;.省略多行代码。&rdquo;.]</p>
<p>下面引号包含的这部分是真正的问题：&ldquo;帮我改成 Java 的。&rdquo;</p>
</blockquote>
<p>采用这种方式，几乎可以模拟上下文的操作，但是偶尔会出现错乱，这块儿还有优化空间，还会继续优化。</p>
<p>如果各位小伙伴使用过程中发现什么问题，或者有什么更好的建议，都可以加我好友直接跟我说。</p>
<p>欢迎捧场，赶紧用一用吧，觉得好用的话，可以推荐给身边的小伙伴也用一下。</p>
<p><img src="https://hexo.moonkite.cn/blog/877shots_so%20(1).png" alt=""></p>
]]></content:encoded></item><item><title>一个简单的 web 版 JVM 监控器</title><link>https://moonkite.cn/category/product/2-JVM-%E7%9B%91%E6%8E%A7/</link><pubDate>Fri, 02 Jun 2023 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/product/2-JVM-%E7%9B%91%E6%8E%A7/</guid><description>以 JMX 技术为基础，差不多实现了一个 web 版的 visualVM</description><content:encoded>&lt;p>以 JMX 技术为基础，差不多实现了一个 web 版的 visualVM，具备以下功能：&lt;/p>
&lt;p>支持连接本地 JVM 和 远程 JVM
展示所有 MBeans，并可查看属性及调用操作
仪表盘功能：
实时系统信息，系统 CPU 使用率、内存占用等
JVM 参数信息
实时 CPU 使用率曲线图、实时 Heap 、MetaSpace 使用量曲线图、实时类加载量曲线图、实时线程数曲线图
垃圾收集器及垃圾收集次数&lt;/p></content:encoded></item><item><title>这次没躲过去，阳了</title><link>https://moonkite.cn/category/notes/%E9%A6%96%E9%98%B3%E5%BF%AB%E5%A5%BD%E4%BA%86/</link><pubDate>Fri, 02 Jun 2023 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/notes/%E9%A6%96%E9%98%B3%E5%BF%AB%E5%A5%BD%E4%BA%86/</guid><description>2023 年 5 月 25 日，阳了</description><content:encoded><![CDATA[<p>上周四（2023 年 5 月 25 日）阳了，是首阳，去年幸运的躲过去了。今年就没这么幸运了，新冠只会迟到，但它不会不来。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20230603205055429.png" alt=""></p>
<p>最近这次疫情主要是查漏补缺，把去年漏掉的那波补上，顺带着让一些人二阳，甚至三阳。</p>
<p>之前公司里，算上我有3个去年没阳的，我是上周四阳的，另外一个是这周一阳的。</p>
<p>还剩最后一个一直没阳，这多少有点儿厉害了，据我们分析可能的原因有这么几个：</p>
<ol>
<li>和我们打的疫苗不一样，只有他打的是北京生物，我们打的都是科兴，而且他打的比较晚，可能是疫苗确实起作用了。</li>
<li>真正的无症状感染者，感染了但是没有感觉。</li>
<li>超级免疫体质，上天眷顾。（基本排除了）</li>
</ol>
<p>除了这个我愿称之为奇迹的存在，其他我听说的去年没阳过的，目前基本已经全军覆没了。终南山说预测 5月底4000万/周，6月底6500万/周，不是盖的。</p>
<p><img src="https://hexo.moonkite.cn/blog/12222.png" alt=""></p>
<h2 id="首阳历程">首阳历程</h2>
<p>有人说这病毒距离去年的又过去半年了，按照病毒传播的理论，这一次是不是比去年的毒株杀伤里要小一点了。</p>
<p>我感觉，并没有，至少在我这儿的痛苦程度，和去年听别人说的感受是一样的。</p>
<p><strong>上周四，第一天</strong></p>
<p>（周三）半夜感觉嗓子有点异物感，以为是白天喝水少了，早晨起来有点冷，以为发烧了，一量体温并没有，36度。路上肩膀有点疼，之前拉伤过，以为晚上压到了。其实病毒已经开始攻击我了，这病毒就像个放大器，你身体哪里有问题，它就给你把问题放大。</p>
<p>中午就开始没食欲了，吃了几口，然后开始腿有点酸疼，肩膀更疼了，还有屁股疼，这你受的了。</p>
<p>能感觉到有点烧了，立马回家了。</p>
<p>到家之后提问马上上来了，头开始疼，随着提问的升高，头疼的越来越厉害，就是那种头痛欲裂的感觉，毫不夸张，就是疼到没心疼刷手机。头疼的感觉盖过了身上的酸疼，其实身上也很疼。</p>
<p>一量体温，38.3，来了一颗布洛芬。接下来就是睡觉，睡眠质量很好。</p>
<p>不得不说，布洛芬真是神药，又止疼又退烧。</p>
<p><strong>上周五，第二天</strong></p>
<p>早晨精神状态良好，甚至还写了不少代码。轻微咳嗽，有点儿流鼻涕。</p>
<p>到了下午，体温又上来了，头不疼了，但是全身酸疼，尤其是后背和腿，疼的厉害。只能躺着。</p>
<p>一直忍到下午5点，一量体温，又是38.3，你说巧不巧。</p>
<p>冷的不行，直起鸡皮疙瘩。又来了一粒布洛芬，但是今天好像效果不明显，感觉体温一直没降下来，至少到夜里一两点都没降下来，一会儿热的出汗，一会儿冷的要命。</p>
<p>这是最难受的一天，睡不好觉，早晨起来一看，手上脚上都是小红点，就是毛细血管爆了的那种小红点。这就是妥妥的烧爆了。</p>
<p><strong>上周六，第三天</strong></p>
<p>第三天开始就不发烧了，咳嗽严重了一点，嗓子难受，后背还是有点疼。</p>
<p>就是那种连续加班好几天的感觉。</p>
<p><strong>上周日，第四天</strong></p>
<p>咳嗽严重，有鼻涕，嗓子疼，重感冒的那种状态。</p>
<p>还有就是胃有点难受，哪里薄弱它就攻击你哪里，我之前有过慢性胃炎，不过已经好长时间没发作了。这不，被这病毒精准的逮到了。</p>
<p><strong>周一，第五天</strong></p>
<p>仍然没去公司，主要是怕传染给同事。</p>
<p>还是重感冒的症状，不过身上几乎没有疼痛的感觉了。感觉马上就好了。</p>
<p><strong>周二到周五</strong></p>
<p>第6- 9天，现在嗓子虽然不疼了，但是总是干，半个小时不喝水就感觉干、痒，然后就咳嗽。</p>
<p>6、7天的时候，爬楼梯还有点累，头时不时懵懵的，不会影响智商吧。</p>
<p>这两天基本上体力恢复了，头也不懵了，就剩下咳嗽了。</p>
<p>我以为5、6天就能好呢，结果现在还是有点咳嗽，尤其到了下午。</p>
<p><strong>昨天</strong></p>
<p>昨天基本痊愈了，几乎不咳嗽了，嗓子也不疼了。</p>
<p>这周，公司里还有2个同事二阳了，认识的朋友也有几个二阳了。</p>
<p>但是大部分的二阳症状都比较轻，基本上都是轻微咳嗽+流鼻涕，还有一部分有低烧的症状。</p>
<p>这病毒绝对不是大号的感冒，这可比感冒难受多了。而且不是有传言说，世界纪录是8阳吗，因为8阳之后人就没了。</p>
<p>对健康的年轻人还好，但是对老年人，尤其是有基础疾病的老年人，每次疫情都是挑战，家里有老年人一定要做好防护措施，能不感染就不感染，至少在6月底前做好防护，少出门，少聚集，勤消毒。</p>
<p>到了6月底，感染的人数多了，也就能形成一定的免疫屏障了，那时候再出来活动，感染的几率会小一些。</p>
<p>我去年就是在感染高峰期的时候在家里没怎么出门，能网购的都网购，快递放在门口，拿快递先用酒精一通喷。当然，也可能只是幸运而已。</p>
<p>我跟朋友这么说的时候，有的朋友说我站着说话不腰疼。不是想在家里呆着就能在家里呆着的，要上班、要工作呀。</p>
<p>去年的时候还有政策，阳了可以居家办公，但是今年呢，新冠已经当做流感来对待了，好多公司要求能上班就上班，不能上班就请假。所以有很多人，即使阳了，哪怕发着烧，只能要坚持，还是会到公司上班的。</p>
<p>这就是生活呀！</p>
<p>你阳了吗，首阳还是二阳，坚持上班了吗？</p>
]]></content:encoded></item><item><title>做了一个 VSCode ChatGPT 插件</title><link>https://moonkite.cn/2023/05/24/%E5%81%9A%E4%BA%86%E4%B8%80%E4%B8%AA-VSCode-ChatGPT-%E6%8F%92%E4%BB%B6/</link><pubDate>Wed, 24 May 2023 12:56:23 +0800</pubDate><guid>https://moonkite.cn/2023/05/24/%E5%81%9A%E4%BA%86%E4%B8%80%E4%B8%AA-VSCode-ChatGPT-%E6%8F%92%E4%BB%B6/</guid><description>其实很早之前就想学学 VSCode 插件开发了，但是又不知道做什么，加上我这半吊子前端水平，迟迟没有动手。 最近 ChatGPT 火的一塌糊涂，我也一直在用，真的非常好用，</description><content:encoded><![CDATA[<p>其实很早之前就想学学 VSCode 插件开发了，但是又不知道做什么，加上我这半吊子前端水平，迟迟没有动手。</p>
<p>最近 ChatGPT 火的一塌糊涂，我也一直在用，真的非常好用，有些问题之前需要 Google 搜索，现在用 ChatGPT 基本上都能直接解决，效率提升了不少。</p>
<p>但是吧，浏览器和 IDE 来回切换又很麻烦，所以我灵机一动，那就开发个 ChatGPT 插件吧，即可以学习学习 VSCode 插件开发，又可以做一个方便的效率工具，岂不是一举两得，美哉美哉。</p>
<p>于是我就动手写了下面这个插件，叫做 <code>mini ChatGPT</code>，现在已经发布到 VSCode 插件市场了。</p>
<p>有条件的同学可以安装一下，试试效果如何。</p>
<p><strong>插件功能特点</strong></p>
<ul>
<li>界面简洁，没有多余的干扰；</li>
<li>像 ChatGPT 官网输出效果一致，打字效果实时输出；</li>
<li>支持两轮上下文（太多了浪费 tokens），大致等于支持上下文；</li>
<li>代码美化+格式化，并且可以一键复制，直接粘贴到 vscode 中；</li>
</ul>
<p><img src="https://hexo.moonkite.cn/blog/image-20230509181750193.png" alt=""></p>
<h2 id="插件安装">插件安装</h2>
<p><strong>当然了，这是需要科学上网的。</strong></p>
<p>你可以直接在 VSCode 的商店直接搜索 <code>mini ChatGPT</code>安装。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20230509183628014.png" alt=""></p>
<p>也可以到应用市场上安装。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20230509183750997.png" alt=""></p>
<p>插件地址：https://marketplace.visualstudio.com/items?itemName=fengzheng.code-chatgpt-assistant</p>
<h2 id="插件使用">插件使用</h2>
<ol>
<li>点击查看-&gt;命令面板，或者使用快捷键（MacOS: Shift + Command + P，Windows:Shift + Control + P</li>
<li>输入 <code>Chat</code> 并回车。
<img src="https://hexo.moonkite.cn/blog/20230509111926.png" alt=""></li>
<li>如果是首次使用，会弹出提示输入框，在此输入 ChatGPT 的 API。使用的就是原滋原味的 ChatGPT API 接口，官网上都写的很清楚，所以需要使用插件的小伙伴提供自己账号的 API key。下面有介绍如何获取ChatGPT API key。
<img src="https://hexo.moonkite.cn/blog/20230509112123.png" alt=""></li>
<li>之后就可以使用啦
<img src="https://hexo.moonkite.cn/blog/20230509112311.png" alt=""></li>
<li>如果之后想更换 ChatGPT 的 API key，在命令面板中输入 <code>ChatGPT API</code> 即可。</li>
</ol>
<p><strong>使用建议</strong></p>
<p>此插件只有一个 webview 实现，打开之后独占一个 tab，可以设置向左或向右拆分，然后在左侧使用此插件向 ChatGPT 提问，右侧是代码文件，这样就不用来回切换了，而且可以将代码片段一键复制，然后直接运行。</p>
<p><img src="https://hexo.moonkite.cn/blog/chatgpt.gif" alt=""></p>
<p><strong>获取 ChatGPT API key</strong></p>
<ol>
<li>
<p>先准备好科学上网，不要用亚洲节点。</p>
</li>
<li>
<p>之后到 <a href="https://platform.openai.com/">OpenAI 官网</a>注册账号。</p>
</li>
<li>
<p>到<a href="https://platform.openai.com/account/api-keys">个人中心</a> 创建一个 API key。</p>
</li>
</ol>
<p><img src="https://hexo.moonkite.cn/blog/20230509133206.png" alt=""></p>
<h2 id="开发历程">开发历程</h2>
<p>作为一个后端开发，我的前端水平是非常一般的，所以代码中有瑕疵的地方还请见谅。对了，代码已经放到 GitHub  上了。</p>
<p>仓库地址：https://github.com/huzhicheng/vscode-ChatGPT</p>
<p>VSCode 插件开发，官方建议是用 TypeScript 开发，所以项目完全采用了 TS 开发。由于功能比较简单，没有那么多复杂的设置，由于边学边做，太复杂的也没考虑。整个插件的核心其实就是一个 <code>webview</code>，在webview中实现界面布局和样式，难点就在于webview与插件本身来回的数据传递，但也都是常规用法。</p>
<p>整个写代码的过程其实也就几个小时，当然过程中的遇到的一些问题我都是跟 ChatGPT 提问的，包括样式都是直接描述需求，ChatGPT 给我一个大致的框架，我再微调一下就可以了。</p>
<p>所以这样看下来，其实是我和 ChatGPT 合作开发的。</p>
<p>后来发布到应用商店，写 readme 介绍和使用说明花了一些时间。</p>
<h2 id="问题和建议">问题和建议</h2>
<p>目前的版本功能比较简单，没有 ChatGPT 官方的聊天记录列表功能，如果真的有人用的话，后期考虑加上。</p>
<p>由于ChatGPT 官方并未提供上下文的 API 支持，所以只能采用其他方式模仿上下文能力，目前的做法是记录前两轮提问和回答，然后在下次提问的时候，将前两轮的提问和回答告诉 ChatGPT ，并且明确告诉 ChatGPT，例如下面这样。</p>
<p>第一轮问题：你好。</p>
<p>第一轮回答：你好，请问有什么要帮忙的吗？</p>
<p>第二论问题：请帮我写一段 Python 爬虫抓取知乎回答的 demo。</p>
<p>第二轮回答：好的，下面是一段抓取知乎回答的 Python 示例。&hellip;.省略多行代码。</p>
<p>第三轮问题：帮我改成 Java 的。</p>
<p>这时候，我会将实际的 prompt 改成下面这样的。</p>
<blockquote>
<p>下面中括号部分是前两轮的问题和回答，只用作参考。[my question is:&ldquo;你好&rdquo;,your anwser is:&ldquo;你好，请问有什么要帮忙的吗？&quot;.my question is:&ldquo;请帮我写一段 Python 爬虫抓取知乎回答的 demo。&quot;,your anwser is:&ldquo;好的，下面是一段抓取知乎回答的 Python 示例。&hellip;.省略多行代码。&rdquo;.]</p>
<p>下面引号包含的这部分是真正的问题：&ldquo;帮我改成 Java 的。&rdquo;</p>
</blockquote>
<p>采用这种方式，几乎可以模拟上下文的操作，但是偶尔会出现错乱，这块儿还有优化空间，还会继续优化。</p>
<p>如果各位小伙伴使用过程中发现什么问题，或者有什么更好的建议，都可以加我好友直接跟我说。</p>
<p>欢迎捧场，赶紧用一用吧，觉得好用的话，可以推荐给身边的小伙伴也用一下。</p>
<p><img src="https://hexo.moonkite.cn/blog/877shots_so%20(1).png" alt=""></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nn">kite.lab.spring.config</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Hacker
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @author fengzheng
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Hacker</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">age</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">language</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">isHide</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getAge</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">age</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setAge</span><span class="o">(</span><span class="n">String</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getLanguage</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">language</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLanguage</span><span class="o">(</span><span class="n">String</span> <span class="n">language</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">language</span> <span class="o">=</span> <span class="n">language</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isHide</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">isHide</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setHide</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">hide</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">isHide</span> <span class="o">=</span> <span class="n">hide</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">StringBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">builder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">&#34;======================\n&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">builder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&#34;hacker&#39;s name is :%s \n&#34;</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">getName</span><span class="o">()));</span>
</span></span><span class="line"><span class="cl">        <span class="n">builder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&#34;hacker&#39;s age is :%s \n&#34;</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">getAge</span><span class="o">()));</span>
</span></span><span class="line"><span class="cl">        <span class="n">builder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&#34;hacker&#39;s language is :%s \n&#34;</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">getLanguage</span><span class="o">()));</span>
</span></span><span class="line"><span class="cl">        <span class="n">builder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&#34;hacker&#39;s status is :%s \n&#34;</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">isHide</span><span class="o">()));</span>
</span></span><span class="line"><span class="cl">        <span class="n">builder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">&#34;======================\n&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">builder</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div>]]></content:encoded></item><item><title>用了这两款插件，同事再也不说我代码写的烂了</title><link>https://moonkite.cn/category/java/%E7%94%A8%E4%BA%86%E8%BF%99%E4%B8%A4%E6%AC%BE%E6%8F%92%E4%BB%B6%E5%90%8C%E4%BA%8B%E5%86%8D%E4%B9%9F%E4%B8%8D%E8%AF%B4%E6%88%91%E4%BB%A3%E7%A0%81%E5%86%99%E7%9A%84%E7%83%82%E4%BA%86/</link><pubDate>Fri, 17 Mar 2023 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/java/%E7%94%A8%E4%BA%86%E8%BF%99%E4%B8%A4%E6%AC%BE%E6%8F%92%E4%BB%B6%E5%90%8C%E4%BA%8B%E5%86%8D%E4%B9%9F%E4%B8%8D%E8%AF%B4%E6%88%91%E4%BB%A3%E7%A0%81%E5%86%99%E7%9A%84%E7%83%82%E4%BA%86/</guid><description>同事：你的代码写的不行啊，不够规范啊。 我：我写的代码怎么可能不规范，不要胡说。 于是同事打开我的 IDEA ，安装了一个插件，然后执行了一下，规范不规范</description><content:encoded><![CDATA[<p>同事：你的代码写的不行啊，不够规范啊。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ec392c83a4f48209391d2a30483f96c~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>我：我写的代码怎么可能不规范，不要胡说。</p>
<p>于是同事打开我的 IDEA ，安装了一个插件，然后执行了一下，规范不规范，看报告吧。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e44e2b26740c4bc88dc6f09cd49dd239~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>这可怎么是好，这玩意竟然给我挑出来这么多问题，到底靠谱不。</p>
<p>同事潇洒的走掉了，只留下我在座位上盯着屏幕惊慌失措。我仔细的查看了这个报告的每一项，越看越觉得这插件指出的问题有道理，果然是我大意了，竟然还给我挑出一个 bug 来。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ed15609b6094e4f823357bdd5aefa11~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>这是什么插件，review 代码无敌了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2079621178645c2872d1ed96e3bb8a0~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>这个插件就是 SonarLint，官网的 Slogan 是 <code>clean code begins in your IDE with {SonarLint}</code>。</p>
<p>作为一个程序员，我们当然希望自己写的代码无懈可击了，但是由于种种原因，有一些问题甚至bug都无法避免，尤其是刚接触开发不久的同学，也有很多有着多年开发经验的程序员同样会有一些不好的代码习惯。</p>
<p>代码质量和代码规范首先肯定是靠程序员自身的水平和素养决定的，但是提高水平的是需要方法的，方法就有很多了，比如参考大厂的规范和代码、比如有大佬带着，剩下的就靠平时的一点点积累了，而一些好用的插件能够时时刻刻提醒我们什么是好的代码规范，什么是好的代码。</p>
<p>SonarLint 就是这样一款好用的插件，它可以实时帮我们 <code>review</code>代码，甚至可以发现代码中潜在的问题并提供解决方案。</p>
<p>SonarLint 使用静态代码分析技术来检测代码中的常见错误和漏洞。例如，它可以检测空指针引用、类型转换错误、重复代码和逻辑错误等。这些都是常见的问题，但是有时候很难发现。使用 SonarLint 插件，可以在编写代码的同时发现这些问题，并及时纠正它们，这有助于避免这些问题影响应用程序的稳定性。</p>
<p>比如下面这段代码没有结束循环的条件设置，SonarLint 就给出提示了，有强迫症的能受的了这红下划线在这儿？</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/070ac5dbb39c4bea9221a74cc20da2a6~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>SonarLint 插件可以帮助我提高代码的可读性。代码应该易于阅读和理解，这有助于其他开发人员更轻松地维护和修改代码。 SonarLint 插件可以检测代码中的代码坏味道，例如不必要的注释、过长的函数和变量名不具有描述性等等。通过使用 SonarLint 插件，可以更好地了解如何编写清晰、简洁和易于理解的代码。</p>
<p>例如下面这个名称为 <code>hello_world</code>的静态 <code>final</code>变量，SonarLint 给出了两项建议。</p>
<ol>
<li>因为变量没有被使用过，建议移除；</li>
<li>静态不可变变量名称不符合规范；</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a32cebfd401a4e5cb0daf7cf004eb87c~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>SonarLint 插件可以帮助我遵循最佳实践和标准。编写符合标准和最佳实践的代码可以确保应用程序的质量和可靠性。 SonarLint 插件可以检测代码中的违反规则的地方，例如不安全的类型转换、未使用的变量和方法、不正确的异常处理等等。通过使用 SonarLint 插件，可以学习如何编写符合最佳实践和标准的代码，并使代码更加健壮和可靠。</p>
<p>例如下面的异常抛出方式，直接抛出了 <code>Exception</code>，然后 SonarLint 建议不要使用 <code>Exception</code>，而是自定义一个异常，自定义的异常可能让人直观的看出这个异常是干什么的，而不是 <code>Exception</code>基本类型导出传递。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de65676ec99e40c3bcac94c16b0fadb8~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="安装-sonarlint">安装 SonarLint</h2>
<p>可以直接打开 IDEA 设置 -&gt; <code>Plugins</code>，在 <code>MarketPlace</code>中搜索<code>SonarLint</code>，直接安装就可以。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57fe0882143c43d6bd8ed539d9e43f6d~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>还可以直接在官网下载，打开页面<code>https://www.sonarsource.com/products/sonarlint/</code>，在页面中可以看到多种语言、多种开发工具的下载图标，点击下方的 <code>EXPLORE</code>即可到下载页面去下载了。虽然我们只是在 IDEA 中使用，但是它不管支持 Java 、不只支持 IDEA ，还支持 Python、PHP等众多语言，以及 Visual Studio 、VS Code 等众多 IDE。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efe12f47ffbf4a63b5a8975ad1d61baa~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="在-idea-中使用">在 IDEA 中使用</h2>
<p>SonarLint 插件安装好之后，默认就开启了实时分析的功能，就跟智能提示的功能一样，随着你噼里啪啦的敲键盘，<code>SonarLint</code>插件就默默的进行分析，一旦发现问题就会以红框、红波浪线、黄波浪线的方式提示。</p>
<p>当然你也可以在某一文件中点击右键，也可在项目根目录点击右键，在弹出菜单中点击<code>Analyze with SonarLint</code>，对当前文件或整个项目进行分析。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/155fe55f0f2f43928fcd0053fe420a8b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>分析结束后，会生成分析报告。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ef39fa8bab84ad6a82a4d72fac1f78c~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>左侧是对各个文件的分析结果，右侧是对这个问题的建议和修改示例。</p>
<p>SonarLint 对问题分成了三种类型</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bug</td>
<td>代码中的 bug，影响程序运行</td>
</tr>
<tr>
<td>Vulnerability</td>
<td>漏洞，可能被作为攻击入口</td>
</tr>
<tr>
<td>Code smell</td>
<td>代码意味，可能影响代码可维护性</td>
</tr>
</tbody>
</table>
<p>问题按照严重程度分为5类</p>
<table>
<thead>
<tr>
<th>严重性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>BLOCKER</td>
<td>已经影响程序正常运行了，不改不行</td>
</tr>
<tr>
<td>CRITICAL</td>
<td>可能会影响程序运行，可能威胁程序安全，一般也是不改不行</td>
</tr>
<tr>
<td>MAJOR</td>
<td>代码质量问题，但是比较严重</td>
</tr>
<tr>
<td>MINOR</td>
<td>同样是代码质量问题，但是严重程度较低</td>
</tr>
<tr>
<td>INFO</td>
<td>一些友好的建议</td>
</tr>
</tbody>
</table>
<h2 id="sonarqube">SonarQube</h2>
<p>SonarLint 是在 IDE 层面进行分析的插件，另外还可以使用 <code>SonarQube</code>功能，它以一个 web 的形式展现，可以为整个开发团队的项目提供一个web可视化的效果。并且可以和 CI\CD 等部署工具集成，在发版前提供代码分析。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23a71ec0e8034ed5a9b121dc759123ed~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p><code>SonarQube</code>是一个 Java 项目，你可以在官网下载项目本地启动，也可以以 docker 的方式启动。之后可以在 IDEA 中配置全局 <code>SonarQube</code>配置。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfb122628ca0458686865c24b057ddfb~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>也可以在 SonarQube web 中单独配置一个项目，创建好项目后，直接将 mvn 命令在待分析的项目中执行，即可生成对应项目的分析报告，然后在  SonarQube web 中查看。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cf6c2de8d4e4bc1869577c13e6f14a7~tplv-k3u1fbpfcp-zoom-1.image" alt="5"></p>
<p>对于绝大多数开发者和开发团队来说，SonarQube 其实是没有必要的，只要我们每个人都解决了 IDE 中 SonarLint 给出的建议，当然最终的代码质量就是符合标准的。</p>
<h2 id="阿里-java-规约插件">阿里 Java 规约插件</h2>
<p>每一个开发团队都有团队内部的代码规范，比如变量命名、注释格式、以及各种类库的使用方式等等。阿里一直在更新 Java 版的阿里巴巴开发者手册，有什么泰山版、终极版，想必各位都听过吧，里面的规约如果开发者都能遵守，那别人恐怕再没办法 diss 你的代码不规范了。</p>
<p>对应这个开发手册的语言层面的规范，阿里也出了一款 IDEA 插件，叫做 Alibaba Java Coding Guidelines，可以在插件商店直接下载。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79ee2e16a1d04bd4b23f16fdfad9e7a6~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>比如前面说的那个 <code>hello_world</code>变量名，插件直接提示「修正为以下划线分隔的大写模式」。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/485b04e0a5e54ec7b165c0a052e8b305~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>再比如一些注释上的提示，不建议使用行尾注释。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90eddf34e86e44fcae92a1a036e56eee~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20230314165107639"></p>
<p>还有，比如对线程池的使用，有根据规范建议的内容，建议自己定义核心线程数和最大线程数等参数，不建议使用 <code>Excutors</code>工具类。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6953c39ed30c40eab564d3d5d8040ae4~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>有了这俩插件，看谁还能说我代码写的不规范了。</p>
]]></content:encoded></item><item><title>Java Stream 高级用法</title><link>https://moonkite.cn/category/java/Java-Stream-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</link><pubDate>Thu, 12 Jan 2023 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/java/Java-Stream-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</guid><description>因为最近做了一个小需求，数据量不大，功能也比较简单，但是计算维度非常多，大部分的计算逻辑其实都可以直接写 SQL 实现，但是那样的话性能就太差了，所</description><content:encoded><![CDATA[<p>因为最近做了一个小需求，数据量不大，功能也比较简单，但是计算维度非常多，大部分的计算逻辑其实都可以直接写 SQL 实现，但是那样的话性能就太差了，所以最终采用了在内存中直接计算，这时候 Stream 就有大用处了。</p>
<p>Java Stream 是 JDK 8 开始提供的一种函数式风格的集合操作方法。我之前写过一篇 <a href="https://mp.weixin.qq.com/s?__biz=MzAxMjA0MDk2OA==&amp;mid=2449469926&amp;idx=1&amp;sn=69167b936c8e42bb3bbdf0c79882553a&amp;chksm=8fbcbf81b8cb369785923acda2bd3f708360ebaf633d9ca0e02e5788e22d8161f5abba2dd3d8&amp;token=723642012&amp;lang=zh_CN#rd"> Java Stream 的文章 - 8000字长文让你彻底了解 Java 8 的 Lambda、函数式接口、Stream 用法和原理</a>，在掘金社区获得了超过 500 个赞，说明大家还是很喜欢用 Stream 的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5607342158c1409585bf1f6504d1ac53~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>上一篇主要介绍了一些基础用法，这一篇主要就介绍三个功能，<strong>排序、分组和 teeing</strong>，teeing 是 JDK 12 才出现的。</p>
<h2 id="排序">排序</h2>
<h3 id="基本数据类型排序">基本数据类型排序</h3>
<p>基本数据类型就是字符串、整型、浮点型这些，也就是要排序的列表中的元素都是这些基本类型的，比如 <code>List&lt;Integer&gt;</code>的。</p>
<p>下面就用一个整型列表举例说明。</p>
<p><strong>正序排序</strong></p>
<p>正序排序，也可以叫做按照自然顺序排序，对于整型来说就是从小到大的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">integerList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">integerList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">collect</span> <span class="o">=</span> <span class="n">integerList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">sorted</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">collect</span><span class="o">);</span>
</span></span></code></pre></div><p>输出结果是 <code>[0, 1, 2, 3, 4]</code>，这很简单没什么好说的。</p>
<p><strong>倒序排序</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">integerList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">integerList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">collect2</span> <span class="o">=</span> <span class="n">integerList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">sorted</span><span class="o">(</span><span class="n">Comparator</span><span class="o">.</span><span class="na">reverseOrder</span><span class="o">())</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">collect2</span><span class="o">);</span>
</span></span></code></pre></div><p>倒序排就是从大到小排序，也很简单在 <code>sorted()</code>方法中添加 <code>Comparator.reverseOrder()</code> 就可以了。</p>
<p><code>sorted()</code> 方法接收的参数是<code>Comparator</code> 函数式接口，在 <a href="https://mp.weixin.qq.com/s?__biz=MzAxMjA0MDk2OA==&amp;mid=2449469926&amp;idx=1&amp;sn=69167b936c8e42bb3bbdf0c79882553a&amp;chksm=8fbcbf81b8cb369785923acda2bd3f708360ebaf633d9ca0e02e5788e22d8161f5abba2dd3d8&amp;token=723642012&amp;lang=zh_CN#rd">8000字长文让你彻底了解 Java 8 的 Lambda、函数式接口、Stream 用法和原理</a> 这篇文章清楚的讲了函数式接口和方法引用，可以翻过去看看。</p>
<h3 id="非基本类型实体排序">非基本类型实体排序</h3>
<p>基本类型的列表排序很简单，但是在实际项目中用到的情况不太多，经常用到的还是我们自定义类型的排序，比如项目中有一个用户实体、一个订单实体、一个产品实体等。</p>
<p>首先定一个<code>Product</code>实体类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">lombok.Data</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @author fengzheng
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Data</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Product</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 唯一标示
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Integer</span> <span class="n">id</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 所属类别
</span></span></span><span class="line"><span class="cl"><span class="cm">      */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Integer</span> <span class="n">type</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 商品名称
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 价格
</span></span></span><span class="line"><span class="cl"><span class="cm">      */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Double</span> <span class="n">price</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h4 id="按某一个字段排序">按某一个字段排序</h4>
<p>对应到我上面定义的这个实体，可以是按照 <code>id</code> 排序，或者按照 <code>price</code>排序。</p>
<p><strong>正序排序</strong></p>
<p>假设按照 <code>price</code>从小到大排序，也就是按照价格由低到高排序。</p>
<p>对应到 SQL 上，可以表示成这样的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">product</span><span class="w"> </span><span class="k">order</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">price</span><span class="w"> </span><span class="k">asc</span><span class="w">
</span></span></span></code></pre></div><p>那用 Stream 实现呢？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">productList</span> <span class="o">=</span> <span class="n">initProductList</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">collect</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">sorted</span><span class="o">(</span><span class="n">Comparator</span><span class="o">.</span><span class="na">comparing</span><span class="o">(</span><span class="n">Product</span><span class="o">::</span><span class="n">getPrice</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></span></code></pre></div><p>等价于</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">collect</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">sorted</span><span class="o">((</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">.</span><span class="na">getPrice</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">y</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()))</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></span></code></pre></div><p>等价于</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">comparator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">Product</span> <span class="n">p1</span><span class="o">,</span> <span class="n">Product</span> <span class="n">p2</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">p1</span><span class="o">.</span><span class="na">getPrice</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">p2</span><span class="o">.</span><span class="na">getPrice</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">collect</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">sorted</span><span class="o">((</span><span class="n">p1</span><span class="o">,</span> <span class="n">p2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">comparator</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">p1</span><span class="o">,</span> <span class="n">p2</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></span></code></pre></div><p>这里面主要由我们提供自定义的就是函数式接口 <code>Comparator</code>，凡是实现了 compare () 方法的都可以。</p>
<p>上面我们自定义的这个 <code>comparator</code>，重载了 <code>compare</code>方法。compare 方法的返回值规则：</p>
<ol>
<li>前者小于后者，返回 -1；</li>
<li>前者大于后者，返回 1；</li>
<li>前者等于后者，返回 0；</li>
</ol>
<p>所以可以理解为，如果 compare 返回的是 1， Stream 就会交换两个实体的位置。所以这样一来，倒序排序就很好整了。</p>
<p><strong>倒序排序</strong></p>
<p>可以这样写，使用 reversed() 方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">collect</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">sorted</span><span class="o">(</span><span class="n">Comparator</span><span class="o">.</span><span class="na">comparing</span><span class="o">(</span><span class="n">Product</span><span class="o">::</span><span class="n">getPrice</span><span class="o">).</span><span class="na">reversed</span><span class="o">())</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></span></code></pre></div><p>或者可以</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">collect</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="na">sorted</span><span class="o">(</span><span class="n">Comparator</span><span class="o">.</span><span class="na">comparing</span><span class="o">(</span><span class="n">Product</span><span class="o">::</span><span class="n">getPrice</span><span class="o">,</span><span class="n">Comparator</span><span class="o">.</span><span class="na">reverseOrder</span><span class="o">()))</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></span></code></pre></div><p>还可以直接直接使用compare ，倒序排序就简单了，稍微改一下就好了。</p>
<p>直接用 <code>Lambda </code>表达式的写法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">collect</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">sorted</span><span class="o">((</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="o">.</span><span class="na">getPrice</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()))</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></span></code></pre></div><p>等价于，抽取出自定义 <code>Comparator</code>的方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">comparator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">Product</span> <span class="n">p1</span><span class="o">,</span> <span class="n">Product</span> <span class="n">p2</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">p2</span><span class="o">.</span><span class="na">getPrice</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">p1</span><span class="o">.</span><span class="na">getPrice</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">collect</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">sorted</span><span class="o">((</span><span class="n">p1</span><span class="o">,</span> <span class="n">p2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">comparator</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">p1</span><span class="o">,</span> <span class="n">p2</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></span></code></pre></div><p>倒序和正序的区别其实就是将 <code>compare()</code>前后两个元素的位置对调一下。</p>
<p>对于大小比较的可以直接用 <code>compare()</code>方法，但是有一些情况可能不止这么简单。没有关系，我们不是可以自定义 Comparator 吗，在 Comparator  重写的 compare 方法中可以加入我们的排序逻辑，不管多么特殊、多么复杂，只要返回一个 int 类型的就可以了。</p>
<h4 id="按照多个字段排序">按照多个字段排序</h4>
<p>还有一些情况要按照两个甚至多个字段排序，一个主排序，一个次要排序。比如我们想要先按 type 升序，再按 price 降序。</p>
<p>对应到 SQL 上就像这样</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">product</span><span class="w"> </span><span class="k">order</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="k">asc</span><span class="p">,</span><span class="n">price</span><span class="w"> </span><span class="k">desc</span><span class="w">
</span></span></span></code></pre></div><p>那用 Stream 来实现是怎么样的呢？用 <code>thenComparing</code>连接多个要排序的属性。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">collect</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">sorted</span><span class="o">(</span><span class="n">Comparator</span><span class="o">.</span><span class="na">comparing</span><span class="o">(</span><span class="n">Product</span><span class="o">::</span><span class="n">getType</span><span class="o">).</span><span class="na">thenComparing</span><span class="o">(</span><span class="n">Product</span><span class="o">::</span><span class="n">getPrice</span><span class="o">,</span> <span class="n">Comparator</span><span class="o">.</span><span class="na">reverseOrder</span><span class="o">())).</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></span></code></pre></div><p>或者还可以定义两个 Comparator</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">typeComparator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">Product</span> <span class="n">p1</span><span class="o">,</span> <span class="n">Product</span> <span class="n">p2</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">p1</span><span class="o">.</span><span class="na">getType</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">p2</span><span class="o">.</span><span class="na">getType</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">priceComparator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">Product</span> <span class="n">p1</span><span class="o">,</span> <span class="n">Product</span> <span class="n">p2</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">p2</span><span class="o">.</span><span class="na">getPrice</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">p1</span><span class="o">.</span><span class="na">getPrice</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">};</span>
</span></span><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">collect</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">sorted</span><span class="o">(</span><span class="n">typeComparator</span><span class="o">.</span><span class="na">thenComparing</span><span class="o">(</span><span class="n">priceComparator</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></span></code></pre></div><p>怎么样，一点难度都没有吧。</p>
<h2 id="分组">分组</h2>
<p>除了排序，还有一个非常有用而且经常会用的功能就是分组功能。分组功能是 <code>collect（）</code>方法提供的功能，返回值是一个字典类型。</p>
<h3 id="根据-type-进行分组">根据 type 进行分组</h3>
<p>对应到 SQL 中就是下面这样</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">product</span><span class="w"> </span><span class="k">group</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">type</span><span class="w">
</span></span></span></code></pre></div><p>用 Stream 来实现呢，就是下面这样子</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span><span class="n">Product</span><span class="o">::</span><span class="n">getType</span><span class="o">));</span>
</span></span></code></pre></div><p>最后生成的对象是一个 Map 类型，key 是用来作为分组依据的字段值，value 是一个列表，也就是同一组的对象集合。在这个例子中，key 就是 product 对象的 type 属性，value 就是 type 相同的 Product 对象的集合。</p>
<p>如果只是求出每一个组所包含的对象个数，可以这样实现，不用遍历 Map 这么麻烦。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span><span class="n">Product</span><span class="o">::</span><span class="n">getType</span><span class="o">,</span> <span class="n">Collectors</span><span class="o">.</span><span class="na">counting</span><span class="o">()));</span>
</span></span></code></pre></div><h3 id="根据两个或多个字段分组">根据两个或多个字段分组</h3>
<p>有时候我们可能会根据不止一个字段进行分组，比如想按照类别相同且价格相同进行分组。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">.</span><span class="na">getType</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34;|&#34;</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()));</span>
</span></span></code></pre></div><p>等价于，将分组依据单独抽取出一个方法，这样就可以加入比较复杂的逻辑了，最终返回的是一个字符串。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">   <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">buildGroupKey</span><span class="o">(</span><span class="n">p</span><span class="o">)));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">buildGroupKey</span><span class="o">(</span><span class="n">Product</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="na">getType</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34;|&#34;</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="na">getPrice</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>为什么两个字段之间要加一个分隔符呢，这是因为有些情况我们还会用到分组依据中的某一个字段，加入分隔符之后方便拆分字符串。当然了，也可以拿到这个分组下的任意一个元素获取。</p>
<h3 id="嵌套分组">嵌套分组</h3>
<p>上面的根据多个字段分组是把多个字段当做同一级别并且的关系处理，还有一些时候呢，我们想要先按一个字段分组，再分组中再按另一个字段分组，这样就形成了一个嵌套关系，比如先按 type 分组，再按 price 分组，这就相当于是一个二维字典（两个层级）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;&gt;&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span><span class="n">Product</span><span class="o">::</span><span class="n">getType</span><span class="o">,</span> <span class="n">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span><span class="n">Product</span><span class="o">::</span><span class="n">getPrice</span><span class="o">)));</span>
</span></span></code></pre></div><p>通过返回值类型就可以看出来是怎么样的一个层级关系。</p>
<h2 id="teeing">teeing()</h2>
<p>这是 JDK 12 才出来的方法，所以要用这个方法，比如在 JDK12 以上才行。它的作用是对两个收集器（Collectors）的结果进行处理。上面的例子中，求出最高价格和最低价格的，并输出为一个字符串，将两个价格用 <code>~</code>符号连接。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">teeing</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">Collectors</span><span class="o">.</span><span class="na">minBy</span><span class="o">(</span><span class="n">Comparator</span><span class="o">.</span><span class="na">comparing</span><span class="o">(</span><span class="n">Product</span><span class="o">::</span><span class="n">getPrice</span><span class="o">)),</span>
</span></span><span class="line"><span class="cl">  <span class="n">Collectors</span><span class="o">.</span><span class="na">maxBy</span><span class="o">(</span><span class="n">Comparator</span><span class="o">.</span><span class="na">comparing</span><span class="o">(</span><span class="n">Product</span><span class="o">::</span><span class="n">getPrice</span><span class="o">)),</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="n">max</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">min</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">getPrice</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34;~&#34;</span> <span class="o">+</span> <span class="n">max</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">getPrice</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">));</span>
</span></span><span class="line"><span class="cl"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
</span></span></code></pre></div><p>最终得到的结果是一个字符串，打印如下，测试数据没有做小数位限制。</p>
<pre tabindex="0"><code>4.347594572793579~89.43160979811124
</code></pre><p>最终的返回类型根据teeing() 方法的最后一个参数的返回结果而定。 min 和 max 这两个参数就是前两个收集器 <code>Collectors.minBy</code>和 <code>Collectors.maxBy</code>的返回结果，因为返回类型是 <code>Optional </code>，所以再取值的时候要加上 <code>get</code>。</p>
<h2 id="总结">总结</h2>
<p>Stream 提供了很丰富的 API ，最大的好处是让我们可以少写很多代码，熟练掌握之后，可以在一些对应的场景快速实现我们想要的逻辑。</p>
<p>有同学说，不行啊，又是 filter 、又是 collect、又是 Collectors ，根本记不住啊。没关系，记不住也正常，它本来就是一个工具，我们其实只要知道它可以实现什么功能，具体的用法可以随用随查吗。这不，我的这两篇文章就可以放进收藏夹里，什么时候用，什么时候打开查一下就好了。</p>
<p>下次碰到类似的场景，记得用 Stream 试一下吧。</p>
]]></content:encoded></item><item><title>用了这么久 IDEA，你竟然不知道 Live Templates ？</title><link>https://moonkite.cn/category/java/%E7%94%A8%E4%BA%86%E8%BF%99%E4%B9%88%E4%B9%85-IDEA%E4%BD%A0%E7%AB%9F%E7%84%B6%E4%B8%8D%E7%9F%A5%E9%81%93-Live-Templates-/</link><pubDate>Mon, 09 Jan 2023 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/java/%E7%94%A8%E4%BA%86%E8%BF%99%E4%B9%88%E4%B9%85-IDEA%E4%BD%A0%E7%AB%9F%E7%84%B6%E4%B8%8D%E7%9F%A5%E9%81%93-Live-Templates-/</guid><description>Live Templates 是什么，听上去感觉挺玄乎的。有的同学用过之后觉得简直太好用了，不能说大大提高了开发效率吧，至少也是小小的提高一下，节省了很多敲重复代码的</description><content:encoded><![CDATA[<p>Live Templates 是什么，听上去感觉挺玄乎的。有的同学用过之后觉得简直太好用了，不能说大大提高了开发效率吧，至少也是小小的提高一下，节省了很多敲重复代码的时间。有的同学用过之后说：没什么用，奇技淫巧罢了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b10eae52495040dcb830c47e74d235bb~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>就算你没听过这个概念，但是或多或少你可能都用到过一点，就算没有用过的话，也可能见到过一些，没吃过猪肉可能也见过猪跑，就像下面这样的操作。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/990a1304105d456d9d533b7f69cb3fce~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>总结一下呢，它就类似于一种快捷指令（神奇代码），只要你在 IDEA 中输入特定的字母组合，IDEA 就会帮你在当前输入的位置插入一段预先定义好的代码，代码可以是固定的，也可以定义一些上下文变量，适用于那些常用的、使用频率较高的声明或重复代码段。</p>
<p>比如声明静态 <code>final</code> 的 <code>String</code>，在不用 Live Tmeplates 的情况下，我们会手动在 IDEA 中依次敲出 &ldquo;public static final String&rdquo; 这一行代码，当然可能借助 IDEA 的只能提示，每个单词只需要敲前两个字母。在使用了 Live Tmeplates 的情况下， 我们只需要敲出 <code>psfs</code>这四个字母，然后按回车键，IDEA 就会帮我们在 <code>psfs</code>这个位置插入 &ldquo;public static final String&rdquo;  这一行。</p>
<p>没用过的同学是不是赶紧打开 IDEA 试一下呢？在设置界面，输入 <code>Live Templates</code>，然后找到右侧的 <code>Java</code>就可以看到内置的模板。不光有 Java 的，对于多种文件类型都有支持，比如 SQL 、JavaScript、JSP 、Kotlin 等。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c9c858aab4746ee91419de2cdb75860~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>下面介绍几个 IDEA 内置的、常用的模板。</p>
<h2 id="常用的-live-templates">常用的 Live Templates</h2>
<p><strong>main 和 psvm</strong></p>
<p>main 方法插入，虽然我们已经可以很熟练的盲打出下面这一段代码，但是只敲四个字母是不是会更快呢。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="变量声明">变量声明</h3>
<p>下面一些是常用的变量声明</p>
<p><strong>psfs</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> 
</span></span></code></pre></div><p><strong>psfi</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> 
</span></span></code></pre></div><p><strong>prsf</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> 
</span></span></code></pre></div><p><strong>St</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">String</span> 
</span></span></code></pre></div><h3 id="控制台输出">控制台输出</h3>
<p>下面是控制台输出，还有一些，不一一列举了。</p>
<p><strong>sout</strong></p>
<p>文本输出，最常用到的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
</span></span></code></pre></div><p><strong>souf</strong></p>
<p>带格式化的文本输出。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">();</span>
</span></span></code></pre></div><h3 id="循环迭代">循环迭代</h3>
<p><strong>fori</strong></p>
<p>输入完，按回车后，光标会在 <code>i&lt;</code>的位置，等待输入临界值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl">    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span></code></pre></div><p><strong>iter</strong></p>
<p>用 forEach 的方式循环，在一个数组或者列表变量下方使用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">array</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><strong>itco</strong></p>
<p>用迭代器的方式迭代，同样是在一个列表变量下方使用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="o">(</span><span class="n">Iterator</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span> <span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">();</span> <span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">String</span> <span class="n">next</span> <span class="o">=</span>  <span class="n">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="surround-templates">Surround Templates</h3>
<p>这种模板是在选中一段代码后，然后使用快捷键 <code>option</code>+<code>command</code>+<code>j</code>调出提示框，然后选择一个模板类型。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f132f6d26154fa3a345a51cf8922e95~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>这个快捷键是 MAC 系统下的，如果你用的是 windows，可以通过点击 <code>code</code>菜单项，找到 <code>Sorround With</code>，看看快捷键是什么。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/603c6f09293847d8a667812821b741ed~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p><strong>C</strong></p>
<p>实现一个 <code>Callable</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Callable</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">callable</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Callable</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">public</span> <span class="n">Object</span> <span class="nf">call</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;hello&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">};</span>
</span></span></code></pre></div><p><strong>RL 和 WL</strong></p>
<p>插入一段读锁或写锁加解锁代码。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 要先声明一个读写锁实例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ReadWriteLock</span> <span class="n">readWriteLock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantReadWriteLock</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">readWriteLock</span><span class="o">.</span><span class="na">readLock</span><span class="o">().</span><span class="na">lock</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="k">try</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;hello&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">readWriteLock</span><span class="o">.</span><span class="na">readLock</span><span class="o">().</span><span class="na">unlock</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="自定义-template">自定义 Template</h2>
<p>有时候我们经常会高频词的使用一段相似的代码， 比如做网络开发的同学，会经常用到 Socket 相关的初始化代码。</p>
<p>对于这种我们自己经常要写的某些类似的代码段，就可以抽取出一个 Template 出来，方便我们使用。</p>
<p>下面我就实现一个自定的 Template，来看一下是不是大大简化了重复性劳动。有的同学可能觉得无所谓的事儿，复制、粘贴也挺省事儿。见仁见智吧，觉得有用的可以尝试一下，觉得鸡肋的也无所谓，反正也不影响最后的功能实现。</p>
<p>比如我最新在做一些系统优化的工作，这个过程中，我会频繁的用 <code>commons-lang3</code>的 <code>StopWatch</code>来看某些方法或者某些代码段的执行时间。比如下面的代码段：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">StopWatch</span> <span class="n">stopWatch</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StopWatch</span><span class="o">(</span><span class="s">&#34;代码段&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">stopWatch</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="k">try</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="n">stopWatch</span><span class="o">.</span><span class="na">stop</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;执行时间 %s%n&#34;</span><span class="o">,</span><span class="n">stopWatch</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
</span></span></code></pre></div><p>由于我比较懒，所以我不想每次都敲重复的内容，连粘贴复制都不想。所以就想到了 Live Template。</p>
<p>1、打开 IDEA 的设置窗口，找到 Editor 下的 <code>Live Templates</code>，在右侧找到 <code>Java</code>，点击最右侧的加号。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0e64b8c32884741bf16863c44589bb3~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20230103224026372"></p>
<p>2、输入这个 Template 的名字，到时候可以在编辑器中通过输入这个名字来插入这个模板。</p>
<p>输入描述，帮助我们记忆。</p>
<p>最后输入模板的内容。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f71f863323a439f86df1b0c5a447309~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20230103224347657"></p>
<p>我给这个模板起名为 <code>watch</code>，模板内容如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">StopWatch</span> <span class="n">stopWatch</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StopWatch</span><span class="o">(</span><span class="s">&#34;$MESSAGE$&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">stopWatch</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">$SELECTION$</span>
</span></span><span class="line"><span class="cl"><span class="n">stopWatch</span><span class="o">.</span><span class="na">stop</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;执行时间 %s%n&#34;</span><span class="o">,</span><span class="n">stopWatch</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
</span></span></code></pre></div><p><code>$SELECTION$</code>表示选中的部分，我们要监控的正好是某个方法或者某个代码段，所以正好可以用 Surround Templates，并且在内容中用了 <code>$SELECTION$</code>，模板就默认为  Surround Templates了。</p>
<p><code>$MESSAGE$</code>就是一个占位符的作用，当我们插入这个模板后，光标会定位到这个占位符，我们就可以在需要定制的地方输入我们想要的内容了。在这里呢，由于我的一个方法中可能用到多个 StopWatch，所以正好在这儿占位，给不同的 StopWatch 赋予不同的名字。</p>
<p>可以通过下面的演示看一下效果。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f603e2288fa4ceab96dbf3ebdab86b3~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="live-template-支持的变量">Live Template 支持的变量</h2>
<p>有一些情况下，我们希望插入的内容不只是固定不变的代码段，而是希望加入一些上下文相关的内容，比如当前方法的入参，比如当前类名，比如当前方法名等。用下面这个例子说明一下。</p>
<p>有一个内置的模板叫做 <code>soutm</code>，它的描述是这样的：Prints current class and method names to System.out，打印当前类和方法名，我们看一下效果，直接将当前类和方法名 <code>Study.main</code>填充到了<code>println</code>参数位置上。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcdb780b64e649ea9963c80610f2cc05~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>模板内容是这样的，其中用到了两个变量是表示当前类名的 <code>$CLASS_NAME$</code>和表示当前方法名的<code>$METHOD_NAME$</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;$CLASS_NAME$.$METHOD_NAME$&#34;</span><span class="o">);</span>
</span></span></code></pre></div><p>更多的可用变量可以到 IDEA 官网查看，看到这些变量后，可能会打开你的思路，更近一步的为你提高开发效率。不过不用这些变量也没关系，上面这写其实差不多也够用了。</p>
<p>官网地址：https://www.jetbrains.com/help/idea/template-variables.html#predefined_functions</p>
]]></content:encoded></item><item><title>新项目为什么决定用 JDK 17了</title><link>https://moonkite.cn/category/java/JDK17/</link><pubDate>Fri, 16 Dec 2022 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/java/JDK17/</guid><description>最近在调研 JDK 17，并且试着将之前的一个小项目升级了一下，在测试环境跑了一段时间。最终，决定了，新项目要采用 JDK 17 了。 JDK 1.8：“不是说好了，他</description><content:encoded><![CDATA[<p>最近在调研 JDK 17，并且试着将之前的一个小项目升级了一下，在测试环境跑了一段时间。<strong>最终，决定了，新项目要采用 JDK 17 了。</strong></p>
<p>JDK 1.8：“不是说好了，他发任他发，你用 Java 8 吗？”</p>
<p>不光是我呀，连 Spring Boot 都开始要拥护 JDK 17了，下面这一段是 Spring Boot 3.0 的更新日志。</p>
<blockquote>
<p>Spring Boot 3.0 requires Java 17 as a minimum version. If you are currently using Java 8 or Java 11, you&rsquo;ll need to upgrade your JDK before you can develop Spring Boot 3.0 applications.</p>
</blockquote>
<p>Spring Boot 3.0 需要 JDK 的最低版本就是 JDK 17，如果你想用 Spring Boot 开发应用，你需要将正在使用的 Java 8 或 Java 11升级到 Java 17。</p>
<p>选用 Java 17，概括起来主要有下面几个主要原因：</p>
<p>1、JDK 17 是 LTS (长期支持版)，可以免费商用到 2029 年。而且将前面几个过渡版（JDK 9-JDK 16）去其糟粕，取其精华的版本；</p>
<p>2、JDK 17 性能提升不少，比如重写了底层 NIO，至少提升 10% 起步；</p>
<p>3、大多数第三方框架和库都已经支持，不会有什么大坑；</p>
<p>4、准备好了，来吧。</p>
<p><strong>拿几个比较好玩儿的特性来说一下 JDK 17 对比 JDK 8 的改进。</strong></p>
<h2 id="密封类">密封类</h2>
<p>密封类应用在接口或类上，对接口或类进行继承或实现的约束，约束哪些类型可以继承、实现。例如我们的项目中有个基础服务包，里面有一个父类，但是介于安全性考虑，值允许项目中的某些微服务模块继承使用，就可以用密封类了。</p>
<p>没有密封类之前呢，可以用 <code>final</code>关键字约束，但是这样一来，被修饰的类就变成完全封闭的状态了，所有类都没办法继承。</p>
<p>密封类用关键字 <code>sealed</code>修饰，并且在声明末尾用 <code>permits</code>表示要开放给哪些类型。</p>
<p>下面声明了一个叫做 <code>SealedPlayer</code>的密封类，然后用关键字 <code>permits</code>将集成权限开放给了 <code>MarryPlayer</code>类。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">sealed</span> <span class="kd">class</span> <span class="nc">SealedPlayer</span> <span class="n">permits</span> <span class="n">MarryPlayer</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">play</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;玩儿吧&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>之后 <code>MarryPlayer</code> 就可以继承 <code>SealedPlayer</code>了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">non</span><span class="o">-</span><span class="n">sealed</span> <span class="kd">class</span> <span class="nc">MarryPlayer</span> <span class="kd">extends</span> <span class="n">SealedPlayer</span><span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">play</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;不想玩儿了&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>继承类也要加上密封限制。比如这个例子中是用的 <code>non-sealed</code>，表示不限制，任何类都可以继承，还可以是 <code>sealed</code>，或者 <code>final</code>。</p>
<p>如果不是 permits 允许的类型，则没办法继承，比如下面这个，编译不过去，会给出提示 &ldquo;java: 类不得扩展密封类：org.jdk17.SealedPlayer（因为它未列在其 &lsquo;permits&rsquo; 子句中）&rdquo;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">non</span><span class="o">-</span><span class="n">sealed</span> <span class="kd">class</span> <span class="nc">TomPlayer</span> <span class="kd">extends</span> <span class="n">SealedPlayer</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">play</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="空指针异常">空指针异常</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="n">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toLowerCase</span><span class="o">();</span>
</span></span></code></pre></div><p>JDK1.8 的版本下运行：</p>
<pre tabindex="0"><code>Exception in thread &#34;main&#34; java.lang.NullPointerException
	at org.jdk8.App.main(App.java:10)
</code></pre><p>JDK17的版本（确切的说是14及以上版本）</p>
<pre tabindex="0"><code>Exception in thread &#34;main&#34; java.lang.NullPointerException: Cannot invoke &#34;String.toLowerCase()&#34; because &#34;s&#34; is null
	at org.jdk17.App.main(App.java:14)
</code></pre><p>出现异常的具体方法和原因都一目了然。如果你的一行代码中有多个方法、多个变量，可以快速定位问题所在，如果是 JDK1.8，有些情况下真的不太容易看出来。</p>
<h2 id="yield关键字">yield关键字</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">calc</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span><span class="n">String</span> <span class="n">operation</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">var</span> <span class="n">result</span> <span class="o">=</span> <span class="k">switch</span> <span class="o">(</span><span class="n">operation</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="s">&#34;+&#34;</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">yield</span> <span class="n">a</span> <span class="o">+</span> <span class="n">a</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="s">&#34;*&#34;</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">yield</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">default</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="换行文本块">换行文本块</h2>
<p>如果你用过 Python，一定知道Python 可以用 <code>'hello world'</code>、<code>&quot;hello world&quot;</code>、<code>''' hello world '''</code>、<code>&quot;&quot;&quot; hello world &quot;&quot;&quot; </code>四种方式表示一个字符串，其中后两种是可以直接支持换行的。</p>
<p>在 JDK 1.8 中，如果想声明一个字符串，如果字符串是带有格式的，比如回车、单引号、双引号，就只能用转义符号，例如下面这样的 JSON 字符串。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">String</span> <span class="n">json</span> <span class="o">=</span> <span class="s">&#34;{\n&#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">        <span class="s">&#34;  \&#34;name\&#34;: \&#34;古时的风筝\&#34;,\n&#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">        <span class="s">&#34;  \&#34;age\&#34;: 18\n&#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">        <span class="s">&#34;}&#34;</span><span class="o">;</span>
</span></span></code></pre></div><p>从 JDK 13开始，也像 Python 那样，支持三引号字符串了，所以再有上面的 JSON 字符串的时候，就可以直接这样声明了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="err">String</span> <span class="err">json</span> <span class="err">=</span> <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">        {
</span></span></span><span class="line"><span class="cl"><span class="s2">          &#34;</span><span class="err">name</span><span class="s2">&#34;: &#34;</span><span class="err">古时的风筝</span><span class="s2">&#34;,
</span></span></span><span class="line"><span class="cl"><span class="s2">          &#34;</span><span class="err">age</span><span class="s2">&#34;: 18
</span></span></span><span class="line"><span class="cl"><span class="s2">        }
</span></span></span><span class="line"><span class="cl"><span class="s2">        &#34;&#34;&#34;</span><span class="err">;</span>
</span></span></code></pre></div><h2 id="record记录类">record记录类</h2>
<p>类似于 Lombok 。</p>
<p>传统的Java应用程序通过创建一个类，通过该类的构造方法实例化类，并通过getter和setter方法访问成员变量或者设置成员变量的值。有了record关键字，你的代码会变得更加简洁。</p>
<p>之前声明一个实体类。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>使用 <code>Record</code>类之后，就像下面这样。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">record</span> <span class="nf">User</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>调用的时候像下面这样</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">RecordUser</span> <span class="n">recordUser</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RecordUser</span><span class="o">(</span><span class="s">&#34;古时的风筝&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">recordUser</span><span class="o">.</span><span class="na">name</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">recordUser</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
</span></span></code></pre></div><p>输出结果</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4cddc522449d49be9ec057f5d63eed41~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>Record 类更像是一个实体类，直接将构造方法加在类上，并且自动给字段加上了 getter 和 setter。如果一直在用 Lombok 或者觉得还是显式的写上 getter 和 setter 更清晰的话，完全可以不用它。</p>
<h2 id="g1-垃圾收集器">G1 垃圾收集器</h2>
<p>JDK8可以启用G1作为垃圾收集器，JDK9到 JDK 17，G1 垃圾收集器是默认的垃圾收集器，G1是兼顾老年代和年轻代的收集器，并且其内存模型和其他垃圾收集器是不一样的。</p>
<p>G1垃圾收集器在大多数场景下，其性能都好于之前的垃圾收集器，比如CMS。</p>
<h2 id="zgc">ZGC</h2>
<p>从 JDk 15 开始正式启用 ZGC，并且在 JDK 16后对 ZGC 进行了增强，控制 stop the world 时间不超过10毫秒。但是默认的垃圾收集器仍然是 G1。</p>
<p>配置下面的参数来启用 ZGC 。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">-XX:+UseZGC
</span></span></code></pre></div><p><strong>可以用下面的方法查看当前所用的垃圾收集器</strong></p>
<p>JDK 1.8 的方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">jmap -heap <span class="m">8877</span>
</span></span></code></pre></div><p>JDK 1.8以上的版本</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">jhsdb jmap --heap --pid <span class="m">8877</span>
</span></span></code></pre></div><p>例如下面的程序采用 ZGC 垃圾收集器。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adef9657c0254619a05a1bdb0b6d07a9~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="其他一些小功能">其他一些小功能</h2>
<p>1、支持 List.of()、Set.of()、Map.of()和Map.ofEntries()等工厂方法实例化对象；</p>
<p>2、Stream API 有一些改进，比如 <code>.collect(Collectors.toList())</code>可以直接写成 <code>.toList()</code>了，还增加了 <code>Collectors.teeing()</code>，这个挺好玩，有兴趣可以看一下；</p>
<p>3、<code>HttpClient</code>重写了，支持 HTTP2.0，不用再因为嫌弃 HttpClient 而使用第三方网络框架了，比如OKHTTP；</p>
<h2 id="升级-jdk-和-idea">升级 JDK 和 IDEA</h2>
<p>安装 JDK 17，这个其实不用说，只是推荐一个网站，这个网站可以下载各种系统、各种版本的 JDK 。地址是 <a href="https://adoptium.net/">https://adoptium.net/</a></p>
<p>还有，如果你想在 IDEA 上使用 JDK 17，可能要升级一下了，只有在 <code>2021.02</code>版本之后才支持 JDK 17。</p>
]]></content:encoded></item><item><title>过两年 JVM 可能就要被GraalVM替代了</title><link>https://moonkite.cn/category/java/Graalvm/</link><pubDate>Tue, 13 Dec 2022 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/java/Graalvm/</guid><description>今天说一说 GraalVM。 GraalVM 是 Oracle 大力发展和想要推广的新一代 JVM ，目前很多框架都已经渐渐支持 GraalVM 了，比如我们在用的 Spring 也已经推出了对 GraalVM 兼容的工具包了</description><content:encoded><![CDATA[<p>今天说一说 GraalVM。</p>
<p>GraalVM 是 Oracle 大力发展和想要推广的新一代 JVM ，目前很多框架都已经渐渐支持 GraalVM 了，比如我们在用的 Spring 也已经推出了对 GraalVM 兼容的工具包了。</p>
<p>既然说的这么厉害，那么它到底是何方神圣呢。</p>
<h2 id="graalvm-和-jvm-的关系">GraalVM 和 JVM 的关系</h2>
<p>既然叫做VM，那肯定和 JVM 有关系的吧。JVM 全称 Java 虚拟机，我们都知道，Java 程序是运行在虚拟机上的，虚拟机提供 Java 运行时，支持解释执行和部分的（JIT）即时编译器，并且负责分配和管理 Java 运行所需的内存，我们所说的各种垃圾收集器都工作在 JVM 中。</p>
<p>比如 Oracle JDK、OpenJDK ，默认的 JVM 是 HotSpot 虚拟机，这是当前应用最广泛的一个虚拟机。我们平时见到的各种将虚拟机的书籍、文章、面试题，基本上都是说的 HotSpot 虚拟机。</p>
<p>除此之外，还有一些商用，或者说小众的虚拟机存在，比如IBM 的J9 JVM，商用的 Zing VM 等。</p>
<p>那 GraalVM 是另一种 Java 虚拟机吗？</p>
<p>是，又不全是。</p>
<p>GraalVM 可以完全取代上面提到的那几种虚拟机，比如 HotSpot。把你之前运行在 HotSpot 上的代码直接平移到 GraalVM 上，不用做任何的改变，甚至都感知不到，项目可以完美的运行。</p>
<p>但是 GraalVM 还有更广泛的用途，不仅支持 Java 语言，还支持其他语言。这些其他语言不仅包括嫡系的 JVM 系语言，例如 Kotlin、Scala，还包括例如 JavaScript、Nodejs、Ruby、Python 等。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85cedb09df80420c9ee6108117fa8adb~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>GraalVM 的野心不止于此，看上面的图，它的目的是搭建一个 Framework，最终的目标是想要支持任何一种语言，无论哪种语言，可以共同跑在 GraalVM 上，不存在跨语言调用的壁垒。</p>
<h2 id="graalvm-和jdk有什么关系">GraalVM 和JDK有什么关系</h2>
<p>Java 虚拟机都是内置在 JDK 中的，比如Orcale JDK、OpenJDK，默认内置的都是 HotSpot 虚拟机。</p>
<p>GraalVM 也是一种 JDK，一种高性能的 JDK。完全可以用它替代 OpenJDK、Orcale JDK。</p>
<h2 id="graalvm-如何运行-java-程序">GraalVM 如何运行 Java 程序</h2>
<p>说了半天，是不是还是不知道 GraalVM 到底是什么。</p>
<ul>
<li>
<p>GraalVM - 还包含 Graal （JIT）即时编译器，可以结合 HotSpot 使用</p>
</li>
<li>
<p>GraalVM – 是一种高性能 JDK，旨在加速 Java 应用程序性能，同时消耗更少的资源。</p>
</li>
<li>
<p>GraalVM - 是一种支持多语言混编的虚拟机程序，不仅可以运行 JVM 系列的语言，也可支持其他语言。</p>
</li>
</ul>
<p>GraalVM 提供了两种方式来运行 Java 程序。</p>
<h3 id="第一种结合-hotspot-使用">第一种：结合 HotSpot 使用</h3>
<p>上面说了，GraalVM 包含 Graal （JIT）即时编译器，自从 JDK 9u 版本之后，Orcale JDK 和 OpenJDK 就集成了 Graal 即时编译器。我们知道 Java 既有解释运行也有即时编译。</p>
<p>当程序运行时，解释器首先发挥作用，代码可以直接执行。随着时间推移，即时编译器逐渐发挥作用，把越来越多的代码编译优化成本地代码，来获取更高的执行效率。即时编译器可以选择性地编译热点代码，省去了很多编译时间，也节省很多的空间。比如多次执行的方法或者循环、递归等。</p>
<p>JDK 默认使用的是 C2 即时编译器，C2是用C++编写的。而使用下面的参数可以用 Graal 替换 C2。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler
</span></span></code></pre></div><p>Graal 编译器是用 Java 实现的，用 Java 实现自己的编译器。Graal 基于一些假设的条件，采取更加激进的方式进行优化。采用 Graal 编译器之后，对性能有会有一定的提升。</p>
<p>但是如果你还是在用 JDK8，那对不起了，GraalVM 的一切都用不了。</p>
<h3 id="第二种aot-编译本地可执行程序">第二种：AOT 编译本地可执行程序</h3>
<p>这是 GraalVM 真正厉害的地方。</p>
<p>AOT 提前编译，是相对于即时编译而言的。AOT在运行过程中耗费 CPU 资源来进行即时编译，而程序也能够在启动的瞬间就达到理想的性能。例如 C 和 C++语言采用的是AOT静态编译，直接将代码转换成机器码执行。而 Java 一直采用的是解释 + 即时编译技术，大多数情况下 Java 即时编译的性能并不比静态编译差，但是还是一直朝着 AOT 编译的方向努力。</p>
<p>但是 Java 对于 AOT 来说有一些难点，比如类的动态加载和反射调用。</p>
<p>GraalVM 显然是已经克服了这些问题，使用 GraalVM 可以直接将 Java 代码编译成本地机器码形态的可执行程序。</p>
<p>我们目前运行 Java 一定要安装 JDK 或者 JRE 对不对，如果将程序直接编译成可执行程序，就不用在服务器上安装 JDK 或 JRE 了。那就是说运行 Java 代码其实也可以不用虚拟机了是吗？</p>
<p>GraalVM 的 AOT 编译实际上是借助了 SubstrateVM 编译框架，可以将 SubstrateVM  理解为一个内嵌精简版的 JVM，包含异常处理，同步，线程管理，内存管理（垃圾回收）和 JNI 等组件。</p>
<p>SubstrateVM 的启动时间非常短，内存开销非常少。用这种方式编译出的 Java 程序的执行时间可与C语言持平。</p>
<p>下图是使用即时编译（JVM运行）与 AOT (原生可执行程序)两种方式的 CPU 和内存使用情况对比，可以看出来，AOT 方式下 CPU 和内存的使用都非常少。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aae8240e7bd040ad96cc4947ad3c548d~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>除了运行时占用的内存少之外，用这种方式最终生成的可执行文件也非常小。这对于云端部署非常友好。目前很多场景下都使用 Docker 容器的方式部署，打一个 Java 程序的镜像包要包含完整的 JVM 环境和编译好的 Jar 包。而AOT 方式可以最大限度的缩小 Docker 镜像的体积。</p>
<p><strong>缺点</strong></p>
<p>好处多多，当然也有一些弊端。对于反射这种纯粹在运行时才能确定的部分，不可能完全通过优化编译器解决，只能通过增加配置的方式解决。麻烦是麻烦了一点，但是是可行的，Spring Boot 2.7的版本已经支持原生镜像了，Spring 这种非常依赖反射的框架都可以支撑，我们用起来也应该没问题。</p>
<h2 id="graalvm-如何支持多语言">GraalVM 如何支持多语言</h2>
<p>要支持多语言，就要说到 GraalVM 中的另一个核心组件 Truffle 了。</p>
<p>Truffle 是一个用 Java 写就的语言实现框架。基于 Truffle 的语言实现仅需用 Java 实现词法分析、语法分析以及针对语法分析所生成的抽象语法树（Abstract Syntax Tree，AST）的解释执行器，便可以享用由 Truffle 提供的各项运行时优化。</p>
<p>就一个完整的 Truffle 语言实现而言，由于实现本身以及其所依赖的 Truffle 框架部分都是用 Java 实现的，因此它可以运行在任何 Java 虚拟机之上。</p>
<p>当然，如果 Truffle 运行在附带了 Graal 编译器的 Java 虚拟机之上，那么它将调用 Graal 编译器所提供的 API，主动触发对 Truffle 语言的即时编译，将对 AST 的解释执行转换为执行即时编译后的机器码。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87d8ead82cc54120b3e91a98465fb12d~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>目前除了 Java， JavaScript、Ruby、Python 和许多其他流行语言都已经可以运行在 GraalVM 之上了。</p>
<p>GraalVM 官方还提供了完整的文档，当有一天你开发了一款新的语言，也可以用 Truffle  让它跑在 GraalVM 上。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f487e72828d4b4d892a4cde51bea8fd~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h3 id="安装和使用">安装和使用</h3>
<p>GraalVm 目前的最新版本是 22.3，分为社区版和企业版，就好像 OpenJDK 和 商用的 Orcale 的 JDK ，企业版会多一些性能分析的功能，用来帮助更大程度的优化性能。</p>
<p>社区版是基于OpenJDK 11.0.17, 17.0.5, 19.0.1，而商业版基于Oracle JDK 8u351, 11.0.17, 17.0.5, 19.0.1，所以，如果你想用免费的，只能将程序升级到 JDK 11 以上了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d5f3f31ebe04241a7b5a466382889aa~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>GraalVM 支持 Windows、Linux、MacOS ，可以用命令安装最新版，或者直接下载对应 Java 版本的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/950626b9458844f7ad06ced978787ee5~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>我是下载的 Java 11 的版本，下载下来的压缩包，直接解压，然后配置环境变量。把解压目录配置到环境变量的 <code>JAVA_HOME</code>就可以了。</p>
<p>解压好其实就相当于安装完毕了，查看一下版本。</p>
<p>进入到解压目录下的<code>bin</code>目录中，运行 <code>java -version</code>。运行结果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97101a8288334db2a9872df728c7b481~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20221130105634757"></p>
<h2 id="运行代码">运行代码</h2>
<h3 id="常用方式运行">常用方式运行</h3>
<p>也就是我们平时一直在用的这种方式，把 GrralVM 当做 OpenJDK 使用，只不过把即时编译器换成了 Graal 。就是前面说的第一种方式。</p>
<p>安装完成后，就可以把它当做正常的 JDK 使用了，比如 <code>javac</code>、<code>jps</code>、<code>jmap</code>等都可以直接用了。大多数人还是用 IDEA 的，所以就直接在 IDEA 中使用就好了。</p>
<p>1、先随意创建一个 Java 项目。</p>
<p>2、创建完成后，打开项目设置。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0dd751cb7d294df781f77552064615f2~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>3、在打开的项目设置弹出框中选择 <code>SDKs</code>，点击加号，选择前面解压的 GraalVM 目录。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3d3f721b00a410e9d490234165ddc41~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>4、然后选择刚刚添加的这个 JDK。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/744a58afa8f9430fb4cc34daee5c0d18~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>5、最后运行一段测试代码。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloWorld</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Hello GraalVM!&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">*</span> <span class="mi">100</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7f797c478b04af8ad606767b6d9458e~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>上面这样的运行方式，其实就相当于前面说的第一种运行方式</p>
<h3 id="native-image-方式运行">native-image 方式运行</h3>
<p>这种方式就是 AOT 编译成机器码，已可执行文件的形式出现。<code>native-image</code> 可以命令行的形式执行，也可以在配合 Maven 执行，我这儿就直接演示用 Maven 形式的了，毕竟IDEA 搭配 Maven 用习惯了。</p>
<p>1、<strong>安装<code>native-image</code> 工具包</strong></p>
<p><code>native-image</code> 是用来进行 AOT 编译打包的工具，先把这个装上，才能进行后面的步骤。</p>
<p>安装好 GraalVM 后，在 <code>bin</code>目录下有一个叫做 <code>gu</code>的工具，用这个工具安装，如果将 <code>bin</code>目录添加到环境中，直接下面的命令安装就行了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">gu install native-image
</span></span></code></pre></div><p>如果没有将 <code>bin</code>目录加到环境变量中，要进入到 <code>bin</code>目录下，执行下面的命令安装。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">./gu install native-image
</span></span></code></pre></div><p>这个过程可能比较慢，因为要去 github 上下载东西，如果一次没成功（比如超时），多试两次就好了。</p>
<p>2、<strong>配置 Maven</strong></p>
<p>配置各种版本</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"> <span class="nt">&lt;properties&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;project.build.sourceEncoding&gt;</span>UTF-8<span class="nt">&lt;/project.build.sourceEncoding&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;maven.compiler.source&gt;</span>${java.specification.version}		<span class="nt">&lt;/maven.compiler.source&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;maven.compiler.target&gt;</span>${java.specification.version}<span class="nt">&lt;/maven.compiler.target&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;native.maven.plugin.version&gt;</span>0.9.12<span class="nt">&lt;/native.maven.plugin.version&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;imageName&gt;</span>graalvm-demo-image<span class="nt">&lt;/imageName&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;mainClass&gt;</span>org.graalvm.HelloWorld<span class="nt">&lt;/mainClass&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;/properties&gt;</span>
</span></span></code></pre></div><p><code>native.maven.plugin.version</code>是要用到的编译为可执行程序的 Maven 插件版本。</p>
<p><code>imageName</code>是生成的可执行程序的名称。</p>
<p><code>mainClass</code>是入口类全名称。</p>
<p>配置 build 插件</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl">  <span class="nt">&lt;build&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;plugins&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;plugin&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;groupId&gt;</span>org.codehaus.mojo<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;artifactId&gt;</span>exec-maven-plugin<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;version&gt;</span>3.0.0<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;executions&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;execution&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;id&gt;</span>java-agent<span class="nt">&lt;/id&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;goals&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;goal&gt;</span>exec<span class="nt">&lt;/goal&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;/goals&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;configuration&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;executable&gt;</span>java<span class="nt">&lt;/executable&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;workingDirectory&gt;</span>${project.build.directory}<span class="nt">&lt;/workingDirectory&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;arguments&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;argument&gt;</span>-classpath<span class="nt">&lt;/argument&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;classpath/&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;argument&gt;</span>${mainClass}<span class="nt">&lt;/argument&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;/arguments&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;/configuration&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;/execution&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;execution&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;id&gt;</span>native<span class="nt">&lt;/id&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;goals&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;goal&gt;</span>exec<span class="nt">&lt;/goal&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;/goals&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;configuration&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;executable&gt;</span>${project.build.directory}/${imageName}<span class="nt">&lt;/executable&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;workingDirectory&gt;</span>${project.build.directory}<span class="nt">&lt;/workingDirectory&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;/configuration&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;/execution&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;/executions&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;/plugin&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;plugin&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;groupId&gt;</span>org.apache.maven.plugins<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;artifactId&gt;</span>maven-compiler-plugin<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;version&gt;</span>3.8.1<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;configuration&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;source&gt;</span>${maven.compiler.source}<span class="nt">&lt;/source&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;target&gt;</span>${maven.compiler.source}<span class="nt">&lt;/target&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;/configuration&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;/plugin&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;plugin&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;groupId&gt;</span>org.apache.maven.plugins<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;artifactId&gt;</span>maven-jar-plugin<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;version&gt;</span>3.2.2<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;configuration&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;archive&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;manifest&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;addClasspath&gt;</span>true<span class="nt">&lt;/addClasspath&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;mainClass&gt;</span>${mainClass}<span class="nt">&lt;/mainClass&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;/manifest&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;/archive&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;/configuration&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;/plugin&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;plugin&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;groupId&gt;</span>org.apache.maven.plugins<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;artifactId&gt;</span>maven-assembly-plugin<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;executions&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;execution&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;phase&gt;</span>package<span class="nt">&lt;/phase&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;goals&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;goal&gt;</span>single<span class="nt">&lt;/goal&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;/goals&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;/execution&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;/executions&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;configuration&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;archive&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;manifest&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;addClasspath&gt;</span>true<span class="nt">&lt;/addClasspath&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;mainClass&gt;</span>${mainClass}<span class="nt">&lt;/mainClass&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;/manifest&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;/archive&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;descriptorRefs&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;descriptorRef&gt;</span>jar-with-dependencies<span class="nt">&lt;/descriptorRef&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;/descriptorRefs&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;/configuration&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;/plugin&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/plugins&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;/build&gt;</span>
</span></span></code></pre></div><p>配置 profiles</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl">  <span class="nt">&lt;profiles&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;profile&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;id&gt;</span>native<span class="nt">&lt;/id&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;build&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;plugins&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;plugin&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;groupId&gt;</span>org.graalvm.buildtools<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;artifactId&gt;</span>native-maven-plugin<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;version&gt;</span>${native.maven.plugin.version}<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;extensions&gt;</span>true<span class="nt">&lt;/extensions&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;executions&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;execution&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;id&gt;</span>build-native<span class="nt">&lt;/id&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;goals&gt;</span>
</span></span><span class="line"><span class="cl">                  <span class="nt">&lt;goal&gt;</span>build<span class="nt">&lt;/goal&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;/goals&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;phase&gt;</span>package<span class="nt">&lt;/phase&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;/execution&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;execution&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;id&gt;</span>test-native<span class="nt">&lt;/id&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;goals&gt;</span>
</span></span><span class="line"><span class="cl">                  <span class="nt">&lt;goal&gt;</span>test<span class="nt">&lt;/goal&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;/goals&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;phase&gt;</span>test<span class="nt">&lt;/phase&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;/execution&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;/executions&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;configuration&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;fallback&gt;</span>false<span class="nt">&lt;/fallback&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;buildArgs&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;arg&gt;</span>-H:DashboardDump=fortune -H:+DashboardAll<span class="nt">&lt;/arg&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;/buildArgs&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;agent&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;enabled&gt;</span>true<span class="nt">&lt;/enabled&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;options&gt;</span>
</span></span><span class="line"><span class="cl">                  <span class="nt">&lt;option&gt;</span>experimental-class-loader-support<span class="nt">&lt;/option&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;/options&gt;</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&lt;/agent&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;/configuration&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&lt;/plugin&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;/plugins&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;/build&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/profile&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;/profiles&gt;</span>
</span></span></code></pre></div><p>3、使用 maven 编译，打包成本地可执行程序。</p>
<p>执行 Maven 命令</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">mvn clean package
</span></span></code></pre></div><p>或者</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">mvn  -Pnative -Dagent package 
</span></span></code></pre></div><p>编译打包的过程比较慢，因为要直接编译成机器码，所以比一般的编译过程要慢一些。看到下面的输入日志，说明打包成功了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/691d3aaf162b4890b0b6160c2a715e50~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>4、运行可执行程序包，打开 target 目录，已经看到了<code>graalvm-demo-image</code>可执行程序包了，大小为 11.58M。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83ae594348264945ad56fc05b6130779~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>然后就可以运行它了，进入到目录下，执行下面的命令运行，可以看到正常输出了。注意了，这时候已经是没有用到本地 JVM 了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">./graalvm-demo-image 
</span></span><span class="line"><span class="cl">Hello GraalVM!
</span></span></code></pre></div><p>这时候，用 <code>jps -l</code>命令已经看不到这个进程了，只能通过 <code>ps</code>看了。</p>
<h2 id="总结">总结</h2>
<p>虽然我们还没有看到有哪个公司说在用 GraalVM 了，但是 <code>Quarkus</code>、<code>Spring Boot</code>、<code>Spring</code>等很多的框架都已经支持 GraalVM 的 Native-image 模式，而且在 Orcale 的大力推广下，相信不久之后就会出现在更多的产品中。赶紧体验一下吧。</p>
]]></content:encoded></item><item><title>JVM 内存溢出的原因及预防</title><link>https://moonkite.cn/category/java/JVM-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E9%A2%84%E9%98%B2/</link><pubDate>Thu, 02 Sep 2021 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/java/JVM-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E9%A2%84%E9%98%B2/</guid><description>我们都知道 Java 程序都是跑在 JVM 上的，一旦 JVM 有什么风吹草动，必然会影响服务的稳定性。幸运的话，服务会发生抖动，可能有部分请求出现延迟或异常。不幸的</description><content:encoded><![CDATA[<p>我们都知道 Java 程序都是跑在 JVM 上的，一旦 JVM 有什么风吹草动，必然会影响服务的稳定性。幸运的话，服务会发生抖动，可能有部分请求出现延迟或异常。不幸的话，JVM 直接崩溃，导致服务完全中断。</p>
<p>这可不是什么好事，与 JVM 一起崩溃的，除了服务，还有我们的心态。</p>
<p>所谓的 JVM 崩溃，一般情况下就是指内存溢出，也就是 OutOfMemoryError 和 StackOverflowError。另外还有一种情况就是堆外内存占用过大，这种情况会导致 JVM 所在机器的内存被撑爆，从而导致机器重启等异常情况发生，我们把这种情况叫做内存泄漏。</p>
<p>那什么情况下会造成 JVM 崩溃呢，有哪几种类型的崩溃呢？俗话说，知己知彼，方能百战不殆。了解了发生崩溃的原因，才能更好的解决 JVM 崩溃问题。</p>
<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccf8e870e83a435e9684be5527ccc7a6~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20201016165948638"></p>
<p>首先还是放出 JVM 内存模型图，JVM 要理解起来是很抽象的，借助下面这张图可以具象化的了解 JVM 内存模型，而发生溢出的几个部分都可以在图中找到。在 JDK 8 中，永久代已经不存在了，取而代之的是元空间（metaspace）。</p>
<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad12b760a3e64e179acff90d4041a911~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20201019183925854"></p>
<p>下面就以 Hotspot JDK 8 为背景，看一下 JVM 内存溢出和内存泄漏的几种情况。</p>
<p>首先设置 JVM 启动参数，限制堆空间大小，堆空间设置为 20M，其中新生代10M，元空间10M，并指定垃圾收集算法采用 CMS 算法。之后的例子都会使用这套参数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">-XX:+UseConcMarkSweepGC
</span></span><span class="line"><span class="cl">-XX:+UseCMSInitiatingOccupancyOnly
</span></span><span class="line"><span class="cl">-XX:CMSInitiatingOccupancyFraction<span class="o">=</span><span class="m">70</span>
</span></span><span class="line"><span class="cl">-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses
</span></span><span class="line"><span class="cl">-XX:+CMSClassUnloadingEnabled
</span></span><span class="line"><span class="cl">-XX:+ParallelRefProcEnabled
</span></span><span class="line"><span class="cl">-XX:+CMSScavengeBeforeRemark
</span></span><span class="line"><span class="cl">-verbose:gc
</span></span><span class="line"><span class="cl">-Xms20M
</span></span><span class="line"><span class="cl">-Xmx20M
</span></span><span class="line"><span class="cl">-Xmn10M
</span></span><span class="line"><span class="cl">-XX:+PrintGCDetails
</span></span><span class="line"><span class="cl">-XX:SurvivorRatio<span class="o">=</span><span class="m">8</span>
</span></span><span class="line"><span class="cl">-XX:+HeapDumpOnOutOfMemoryError
</span></span><span class="line"><span class="cl">-XX:MetaspaceSize<span class="o">=</span>10M
</span></span><span class="line"><span class="cl">-XX:MaxMetaspaceSize<span class="o">=</span>10M
</span></span><span class="line"><span class="cl">-XX:HeapDumpPath<span class="o">=</span>/Users/fengzheng/jvmlog
</span></span></code></pre></div><h2 id="堆溢出">堆溢出</h2>
<p>堆溢出，应该是最常见的一种内存溢出的场景了。JVM 中分配绝大多数对象实例和数组都存在堆上，另外堆内存也是垃圾收集器工作的主要战场。</p>
<p>当我们的 Java 程序启动的时候，会指定堆空间的大小，新建对象和数组的时候会分配到堆上面，当新对象申请空间的时候，如果堆内存不够了，就会发生垃圾收集动作，大多数时候会发生在新生代，叫做 Minor GC。当新生代回收完成，空间仍然不够的话，会发生一次 FullGC。FullGC 后，空间仍然不够，此时就会发生 OOM 错误，也就是堆溢出。</p>
<h3 id="模拟一下这个场景">模拟一下这个场景</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">_1K</span> <span class="o">=</span> <span class="mi">1024</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">List</span><span class="o">&lt;</span><span class="kt">byte</span><span class="o">[]&gt;</span> <span class="n">byteList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">  <span class="n">quietlyWaitingForCrashHeap</span><span class="o">(</span><span class="n">byteList</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">quietlyWaitingForCrashHeap</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="kt">byte</span><span class="o">[]&gt;</span> <span class="n">byteList</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">byteList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">500</span> <span class="o">*</span> <span class="n">_1K</span><span class="o">]);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">//Thread.sleep(1000);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>上面的方法会持续的向<code>List&lt;byte[]&gt;</code>数组中每次添加500k的元素，整个堆只有20M，可想而知，程序一运行起来，马上就会将对空间填满，导致后面的元素加不进去，而又回收不掉，从而导致堆内存溢出。</p>
<p>下面是程序运行之后的结果，经过垃圾回收最终还是没有多余的空间，从而发生 <code>java.lang.OutOfMemoryError: Java heap space</code>异常。</p>
<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3771d9e922c34f38a68e7ecdd1331286~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20201016211017630"></p>
<p>发生堆内存溢出的根本原因就是使用中的对象大小超过了堆内存大小。</p>
<p>堆内存空间设置的太小，要根据预估的实际使用堆大小合理的设置堆空间设置。</p>
<p>程序有漏洞导致，某些静态变量持续的增大，例如缓存数据错误的初始化，导致缓存无止境的增加，最终导致堆内存溢出。针对这种情况，恐怕没什么好方法，除了做好测试之外，就是在问题发生后做好日志分析。</p>
<h2 id="栈溢出">栈溢出</h2>
<p>虚拟机栈是用来存储局部变量表、操作数栈、动态链接、方法出口等信息的，每调用一个 Java 方法就会为此方法在虚拟机栈中生成栈帧。</p>
<p>栈除了包括虚拟机栈之外，还包括本地方法栈，当调用的方法是本地方法（例如 C 语言实现的方法）时，会用到本地方法栈。不过，在 HotSpot 虚拟机中，虚拟机栈和本地方法栈被合二为一了。</p>
<h3 id="模拟栈溢出场景">模拟栈溢出场景</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">stackOverflow</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">* stackoverflow
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">stackOverflow</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">stackOverflow</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在上面的代码中，stackOverflow() 方法的调用是一个无限递归的过程，没有递归出口。前面说了，每调用一个方法就会在虚拟机栈中生成栈帧，无限的递归，必定造成无限的生成栈帧，最后导致栈空间被填满，从而发生溢出。</p>
<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0144fcce3ffb48d480f455788623e403~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20201019122447325"></p>
<p>上面模拟了最常见的一种状况，产生这种状况的原因很可能是由于程序 bug 导致的，一般来说，递归必定会有递归出口，如果由于某些原因导致了程序在执行的过程中无法达到出口条件，那就会造成这种异常。还有就是循环体，循环体的循环次数如果过大，也有可能出现栈溢出。</p>
<p>另外还可能是其他比较不容易出现的原因，比如创建的线程数过多，线程创建要在虚拟机栈中分配空间，如果创建线程过多，可能会出现 <code>OutOfMemoryError</code>异常，但是一般来说，都会用线程池的方法代替手动创建线程的方式，所以，这种情况不容易出现。</p>
<h2 id="元空间溢出">元空间溢出</h2>
<p>用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译(JIT)后的代码等数据，在 JDK 8 中，已经用 metaSpace 代替了永久代的。默认情况下 metaSpace 的大小是没有限制的，也就是所在服务器的实际内存大小，但是，一般情况下，最好还是设置元空间的大小。</p>
<p>一般在产生大量动态生成类的情景中，可能会出现元空间的内存溢出。</p>
<h3 id="模拟元空间溢出">模拟元空间溢出</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">List</span><span class="o">&lt;</span><span class="kt">byte</span><span class="o">[]&gt;</span> <span class="n">byteList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//quietlyWaitingForCrashHeap(byteList);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// stackOverflow();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">methodAreaOverflow</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">methodAreaOverflow</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Enhancer</span> <span class="n">enhancer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Enhancer</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">enhancer</span><span class="o">.</span><span class="na">setUseCache</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">enhancer</span><span class="o">.</span><span class="na">setSuperclass</span><span class="o">(</span><span class="n">MethodOverflow</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">enhancer</span><span class="o">.</span><span class="na">setCallback</span><span class="o">(</span><span class="k">new</span> <span class="n">MethodInterceptor</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">      <span class="kd">public</span> <span class="n">Object</span> <span class="nf">intercept</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">,</span> <span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">objects</span><span class="o">,</span> <span class="n">MethodProxy</span> <span class="n">methodProxy</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">methodProxy</span><span class="o">.</span><span class="na">invokeSuper</span><span class="o">(</span><span class="n">o</span><span class="o">,</span> <span class="n">objects</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">      <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">enhancer</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(++</span><span class="n">i</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>通过 CGLIB 的方式动态的创建很多个动态类，这样一来，类信息就会越来越多的存到元空间，从而导致元空间溢出。</p>
<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e20f0e634ef341ee8a0617e62c2768c0~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20201019163227576"></p>
<p>例如在使用 Spring、 MyBatis 等技术框架的时候会动态创建 Bean 实例类，另外，Spring AOP 也会产生动态代理类。</p>
<h2 id="堆外内存溢出">堆外内存溢出</h2>
<p>大多数情况下，内存都会在 JVM 堆内存中分配，很少情况下需要直接在堆外分配内存空间。使用堆外内存的几个好处是：</p>
<ul>
<li>在进程间可以共享，减少虚拟机间的复制</li>
<li>对垃圾回收停顿的改善：如果应用某些长期存活并大量存在的对象，经常会出发YGC或者FullGC，可以考虑把这些对象放到堆外。过大的堆会影响Java应用的性能。如果使用堆外内存的话，堆外内存是直接受操作系统管理( 而不是虚拟机 )。这样做的结果就是能保持一个较小的堆内内存，以减少垃圾收集对应用的影响。</li>
<li>在某些场景下可以提升程序I/O操纵的性能。少去了将数据从堆内内存拷贝到堆外内存的步骤。</li>
</ul>
<p>通常在需要大量频繁的进行 IO 操作的时候会用到堆外内存，例如 Netty、RocketMQ 等使用到了堆外内存，目的就是为了加快速度。</p>
<p>所以，在出现系统内存占用过大的情况时，排查堆栈无果后，可以看一下堆外内存的使用情况，看看是不是堆外内存溢出了。</p>
<h2 id="总结">总结</h2>
<h3 id="事前做好配置">事前做好配置</h3>
<p>JVM 问题本身就是比较抽象和难以直观发现的，所以在项目上线前除了做好代码逻辑的测试外，还要对 JVM 参数进行合理配置，根据应用程序的体量和特点选择好合适的参数，比如堆栈大小、垃圾收集器种类等等。</p>
<p>另外，垃圾收集日志一定要有保留，还有就是发生内存溢出时要保存 dump 文件。</p>
<h3 id="事中做好监控">事中做好监控</h3>
<p>在程序上线运行的过程中，做好 JVM 的监控工作，比如用 Spring Admin 这种比较轻量的监控工具，或者大型项目用 Cat、SkyWallking 等这些分布式链路监控系统。</p>
<h3 id="事后做好现场保护和分析">事后做好现场保护和分析</h3>
<p>再合理的参数配置和监控平台，也难免不发生异常，这也是很正常的，不出现异常才有问题好吧。在发生异常之后，要及时的保留现场，如果是多实例应用，可以暂时将发生异常的实例做下线处理，然后再进行问题的排查。如果是单实例的服务，那要及时的确认最新的日志和dump已经留存好，确认完成后，再采取错误让服务重启。</p>
]]></content:encoded></item><item><title>手把手教你编译属于自己的 JDK</title><link>https://moonkite.cn/category/java/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E8%87%AA%E5%B7%B1%E7%9A%84-JDK/</link><pubDate>Sat, 03 Apr 2021 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/java/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E8%87%AA%E5%B7%B1%E7%9A%84-JDK/</guid><description>你每天写的 Java 代码都需要 JDK 的支持，都要跑在 JVM 上，难道你就不好奇 JDK 长什么样子吗。好奇，就来编译并实现一个自己的 JDK 吧。 本次编译环境 macOS 10.12，编</description><content:encoded><![CDATA[<p>你每天写的 Java 代码都需要 JDK 的支持，都要跑在 JVM 上，难道你就不好奇 JDK 长什么样子吗。好奇，就来编译并实现一个自己的 JDK 吧。</p>
<p>本次编译环境 macOS 10.12，编译的是 JDK 11 版本。</p>
<h3 id="安装-openjdk-11">安装 OpenJDK 11</h3>
<p>编译 OpenJDK 需要先在机器上安装 OpenJDK 10 或者 OpenJDK 11，作为 Boot JDK。
先安装 openJDK 11 编译需要，可以到 adoptopenjdk 网站去下载。</p>
<p><strong>pkg 格式安装</strong></p>
<p>进入页面 <code>https://adoptopenjdk.net/index.html?variant=openjdk11&amp;jvmVariant=hotspot</code> 直接下载下载，然后双击就可以完成安装了。</p>
<p><strong>tar.gz 格式安装</strong></p>
<p>1、进入页面 <code>https://adoptopenjdk.net/installation.html?variant=openjdk11&amp;jvmVariant=hotspot#x64_mac-jdk</code> 下载 tar.gz 包</p>
<p>2、解压</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">tar -xf OpenJDK11U-jdk_x64_mac_hotspot_11.0.5_10.tar.gz
</span></span></code></pre></div><p>解压后是一个 macOS 包，可通过右键-&gt;显示包内容查看里面的文件。</p>
<p>3、加入环境变量 PATH 中，当然如果你使用其他版本的 JDK 作为开发使用，请忽略这一步。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span><span class="nv">$PWD</span>/jdk-11.0.5+10/Contents/Home/bin:<span class="nv">$PATH</span>
</span></span></code></pre></div><p>4、macOS JDK 默认目录在<code>/Library/Java/JavaVirtualMachines</code>,把第 2 步解压的内容放到此目录下，之后编译的过程中会在这个目录下查找 JDK 10 或 JDK 11。</p>
<p>下面是我本地的目录结构，有 7 、8、11 这三个版本，开发时候还是默认使用 8 的。</p>
<p><img src="https://hexo.moonkite.cn/blog/1.png" alt="1"></p>
<h3 id="安装-xcode">安装 xcode</h3>
<p>实际上我们需要的不是 xcode，而是 LLVM 的编译命令 clang。当然你可以单独安装 LLVM，但限于此篇是写给 Java 开发者的，安装 xcode 是最简单的版本。</p>
<p>我本地是很早之前安装的 xcode 8.1，编译起来是没问题的，如果你用的是比较新的版本，应该也不会出现什么问题，可以亲自试一试。</p>
<h3 id="开始编译">开始编译</h3>
<p><strong>1、下载 OpenJDK 11 源码</strong></p>
<p>OpenJDK 的源码放在了网站 <a href="http://hg.openjdk.java.net/">http://hg.openjdk.java.net/</a> 上，我们要下载的 JDK11 目录在 <a href="http://hg.openjdk.java.net/jdk-updates/jdk11u/">http://hg.openjdk.java.net/jdk-updates/jdk11u/</a>。</p>
<p>进入页面后，先点击左侧的 browse，再选择一种压缩格式下载。</p>
<p><img src="https://hexo.moonkite.cn/blog/2.png" alt="2"></p>
<p>当然还可以用 hg 命令 clone 到本地，使用 hg 需要安装 mercurial，如果网速不好或者不稳定，建议不要使用这种方式。</p>
<pre tabindex="0"><code>hg clone https://hg.openjdk.java.net/jdk/jdk11/
</code></pre><p><strong>2、解压源码包</strong></p>
<p>将你刚刚下载的压缩包解压，请解压到一个全英文目录下，不要使用中文，减少编译时带来的麻烦。</p>
<p><strong>3、configure</strong></p>
<p>进入上一步解压后的目录，执行如下命令。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sh configure --with-target-bits<span class="o">=</span><span class="m">64</span> --enable-ccache --with-jvm-variants<span class="o">=</span>server  --with-boot-jdk-jvmargs<span class="o">=</span><span class="s2">&#34;-Xlint:deprecation -Xlint:unchecked&#34;</span> --disable-warnings-as-errors --with-debug-level<span class="o">=</span>slowdebug 2&gt;<span class="p">&amp;</span><span class="m">1</span> <span class="p">|</span> tee configure_mac_x64.log
</span></span></code></pre></div><p>执行这个命令的前提是我已经将 OpenJDK 11 放到了 <code>/Library/Java/JavaVirtualMachines</code>目录下。</p>
<p>如果不放到这个目录下，也是可以的，需要额外指定参数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">--with-boot-jdk<span class="o">=</span>OpenJDK 目录
</span></span></code></pre></div><p>如果出现如下输出，说明这一步就正常了。</p>
<p><img src="https://hexo.moonkite.cn/blog/3.png" alt="3"></p>
<p><strong>4、make</strong></p>
<p>正式开始编译了，使用 make 命令即可。</p>
<pre tabindex="0"><code>make
</code></pre><p>首次编译会比较慢，我的是 MacBook Pro i5 8G 的那款，大概编译了 10 几分钟吧。当出现如下输出的时候，说明编译成功。</p>
<pre tabindex="0"><code>Finished building target &#39;default (exploded-image)&#39; in configuration &#39;macosx-x86_64-normal-server-slowdebug&#39;
</code></pre><p>编译好之后，会在当前目录出现 build 目录，进去之后，看到有个 <code>macosx-x86_64-normal-server-slowdebug</code> 就是最终的目录。</p>
<h3 id="idea-中配置使用编译好的-jdk">IDEA 中配置使用编译好的 JDK</h3>
<p>1、打开 IDEA ,找到 File-&gt;Project Structure。</p>
<p><img src="https://hexo.moonkite.cn/blog/4.png" alt="4"></p>
<p>2、添加一个 JDK</p>
<p><img src="https://hexo.moonkite.cn/blog/5.png" alt="5"></p>
<p>3、选择上面源码编译好的 jdk</p>
<p><img src="https://hexo.moonkite.cn/blog/6.png" alt="6"></p>
<p>4、最后启动项目的时候指定这个 JDK 就可以了。</p>
<h3 id="用-clion-调试">用 CLion 调试</h3>
<p>1、打开 CLion ,导入项目，选择下载的源码所在位置的 src 目录。</p>
<p><img src="https://hexo.moonkite.cn/blog/7.png" alt="7"></p>
<p>2、配置 Debug Configurations，选择 Executable 为编译好的 java 可执行程序，在 bin 目录下，并且移除 Build 设置。</p>
<p>Program arguments 设置为 -version，也可以设置其他的。设置为 -version 的意思是 java -version。</p>
<p><img src="https://hexo.moonkite.cn/blog/8.png" alt="8"></p>
<p>3、最后在源码中打个断点，比如 jni.cpp 或 thread.cpp 中，然后点击 debug ,就可以调试啦。</p>
<h3 id="打造自己的-jdk">打造自己的 JDK</h3>
<p>标题说的有点儿悬，打造自己的 JDK 哪儿有那么容易，况且还确实没那个实力。这里就是介绍一种思路，比如有些时候，我们调试 Java 代码最后发现走到了 JVM 层，这种情况下，我们就跟不进去了。执行到 JVM 层之后，里面的各种变量是怎么变换的我们就不知道了。这时候，我们找到 JVM 对应的代码稍微改一下，比如加个 printf 输出一下参数值就可以清晰的看出来了。</p>
<p><strong>修改 JDK 代码</strong></p>
<p>我在打开的 CLion 中找到了 java.c 文件的 <code>JavaMain(void * _args)</code> 方法，在里面加了一行打印代码，就勉强算实现了自己的 JDK 吧(微笑脸)。</p>
<p>万里长征第一步嘛，别的不重要，留下脚印儿才是关键。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">printf</span><span class="p">(</span><span class="s">&#34;古时的风筝 JDK </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span></code></pre></div><p><img src="https://hexo.moonkite.cn/blog/9.png" alt="9"></p>
<p><strong>重新编译修改后的源码</strong></p>
<p>修改之后，在终端中进入到源码目录的根目录，然后执行 make 命令。</p>
<p>因为之前已经编译过了，所以再次执行 make 是进行的增量编译，所以速度很快。</p>
<p><strong>好了，见证奇迹的时刻到了</strong></p>
<p>我们之前已经在 IDEA 中添加了编译好的 JDK，并且指定给了一个项目。仅为测试，代码如下。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;hello jvm&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>当我们运行这个项目的时候，如果是平常的 JDK，会在控制台输出 hello jvm ，对不对。</p>
<p>可是，现在指定的不是平常的 JDK ，是被我加持过的 JDK 。</p>
<p>开始运行，输出的结果如下，看到没，刚刚加上的那行代码起作用了。</p>
<p><img src="https://hexo.moonkite.cn/blog/10.png" alt="10"></p>
<h3 id="风筝说">风筝说</h3>
<p>真正能做到 JDK 定制开发的人并不多，我也完全没这个实力。但是每个 Java 开发者都编译一下 JDK 源码，翻一翻代码还是很有必要的。毕竟，我们每天写的代码都需要 JDK 的支持，都要跑在 JVM 上，我们就不好奇它们长成什么模样吗。</p>
<p>另外，这也可能为我们日常解决问题提供一种思路。有人说，最好的老师就是搜索引擎，大多数情况下是没错，但有的时候最好的方式往往就是看一眼源码。</p>
<p>为什么有的人解决问题的速度快，有些看似不能解决的问题放到大牛手里就能很快解决。有时候就是解决问题的维度不一样，人家是在三维的世界里，你却一直在二维的平面里转圈圈，比方说遇到程序问题，只能分析 Java 层面的问题这就是二维，进到 JDK、JVM 源码那就是进到的三维。维度高了，角度变了，解决问题的可能性和方式也就多了。这就好比三体里高等文明利用二向箔进行打击，完全不在一个体量下。</p>
<p>赶紧行动吧，编译一个你自己的 JDK。</p>
]]></content:encoded></item><item><title>Java 字符串常量池漫游指南（图文并茂）</title><link>https://moonkite.cn/category/java/Java-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%97/</link><pubDate>Fri, 02 Apr 2021 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/java/Java-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%97/</guid><description>之前发过这篇文章，但是文中的例子有点错误，都是用的字面量当参数，虽然结论是没有问题的，但是根据例子推导结论其实是有问题的，这里重新把有问题的</description><content:encoded><![CDATA[<p>之前发过这篇文章，但是文中的例子有点错误，都是用的字面量当参数，虽然结论是没有问题的，但是根据例子推导结论其实是有问题的，这里重新把有问题的例子和图都替换了，因为已发送的文章只能修改几个字，所以这里重新发一遍。以免误人子弟。</p>
<blockquote>
<p>字符串问题可谓是 Java 中经久不衰的问题，尤其是字符串常量池经常作为面试题出现。可即便是看似简单而又经常被提起的问题，还是有好多同学一知半解，看上去懂了，仔细分析起来却又发现不太明白。</p>
</blockquote>
<h3 id="背景说明">背景说明</h3>
<p>本文以 JDK 1.8 为讨论版本，虽然现在都已经 JDK 14了，奈何我们还是钟爱 1.8。</p>
<h2 id="一个提问引起的讨论">一个提问引起的讨论</h2>
<p>为什么说到字符串常量呢，源于群里为数不多的一个程序员小姐姐的提问。</p>
<p><img src="https://hexo.moonkite.cn/blog/0.png" alt="0"></p>
<p>这本来和字符串常量没有关系，后来，一个同学说不只是 int ，换成 String 一样可以。</p>
<p><img src="https://hexo.moonkite.cn/blog/1.png" alt="2"></p>
<p>为什么会有&quot;Java开发_北京&quot;这么奇特的字符串乱入呢，因为提出问题的这位小姐姐的群昵称叫这个，所以群里的同学开玩笑说，以为她是某个房地产大佬，要来开发北京。</p>
<p><img src="https://hexo.moonkite.cn/blog/2.jpg" alt="2"></p>
<p><strong>以上是开个玩笑，好了，收。</strong></p>
<p>字符串用 == 比较也是 true，这就有意思了。马上有机灵的小伙伴说这和字符串常量池有关系。没错，就是因为字符串常量池的原因。</p>
<p>第一张图其实没什么好说的，在 JDK 1.8 之后已经不允许 Object 和 int 类型用 == 相比较了，编译直接报错。</p>
<p>第二张图中的代码才是重点要说的，我们可以把它简化成下面这段代码，用 == 符号比较字符串，之后的内容都从这几行代码出发。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">&#34;古时的风筝&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span> <span class="o">==</span> <span class="s">&#34;古时的风筝&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>当然，实际开发中强烈不推荐用 == 符号判断两个字符串是否相等，应该用 equals() 方法。</p>
<h2 id="字符串常量池何许人也">字符串常量池何许人也</h2>
<p>为什么要有字符串常量池呢，像其他对象一样直接存在堆中不行吗，这就要问 Java 语言的设计者了，当然，这么做也并不是拍脑袋想出来的。</p>
<p>这就要从字符串说起。</p>
<p>首先对象的分配要付出时间和空间上的开销，字符串可以说是和 8 个基本类型一样常用的类型，甚至比 8 个基本类型更加常用，故而频繁的创建字符串对象，对性能的影响是非常大的，所以，用常量池的方式可以很大程度上降低对象创建、分配的次数，从而提升性能。</p>
<p>在 JDK 1.7 之后(包括1.7)，字符串常量池已经从方法区移到了堆中。</p>
<h3 id="字面量赋值">字面量赋值</h3>
<p>我们把上面的那个实例代码拿过来</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">&#34;古时的风筝&#34;</span><span class="o">;</span>
</span></span></code></pre></div><p>这是我们平时声明字符串变量的最常用的方式，这种方式叫做字面量声明，也就用把字符串用双引号引起来，然后赋值给一个变量。</p>
<p>这种情况下会直接将字符串放到字符串常量池中，然后返回给变量。</p>
<p><img src="https://hexo.moonkite.cn/blog/3.png" alt="3"></p>
<p>那这是我再声明一个内容相同的字符串，会发现字符串常量池中已经存在了，那直接指向常量池中的地址即可。</p>
<p><img src="https://hexo.moonkite.cn/blog/3-1.png" alt="3-1"></p>
<p>例如上图所示，声明了 s1 和 s2，到最后都是指向同一个常量池的地址，所以 s1== s2 的结果是 true。</p>
<h3 id="new-string-方式">new String() 方式</h3>
<p>与之对应的是用 new String() 的方式，但是基本上不建议这么用，除非有特殊的逻辑需要。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">String</span> <span class="n">a</span> <span class="o">=</span> <span class="s">&#34;古时的&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="n">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="s">&#34;风筝&#34;</span><span class="o">);</span>
</span></span></code></pre></div><p>使用这种方式声明字符串变量的时候，会有两种情况发生。</p>
<h5 id="第一种情况字符串常量池之前已经存在相同字符串">第一种情况，字符串常量池之前已经存在相同字符串</h5>
<p>比如在使用 new 之前，已经用字面量声明的方式声明了一个变量，此时字符串常量池中已经存在了相同内容的字符串常量。</p>
<ol>
<li>首先会在堆中创建一个 s2 变量的对象引用；</li>
<li>然后将这个对象引用指向字符串常量池中的已经存在的常量；</li>
</ol>
<p><img src="https://hexo.moonkite.cn/blog/4.png" alt="4"></p>
<h5 id="第二种情况字符串常量池中不存在相同内容的常量">第二种情况，字符串常量池中不存在相同内容的常量</h5>
<p>之前没有任何地方用到了这个字符串，第一次声明这个字符串就用的是 new String() 的方式，这种情况下会直接在堆中创建一个字符串对象然后返回给变量。</p>
<p><img src="https://hexo.moonkite.cn/blog/5.png" alt="5"></p>
<p><strong>我看到好多地方说，如果字符串常量池中不存在的话，就先把字符串先放进去，然后再引用字符串常量池的这个常量对象，这种说法是有问题的，只是 new String() 的话，如果池中没有也不会放一份进去。</strong></p>
<p>基于 new String() 的这种特性，我们可以得出一个结论：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">&#34;古时的风筝&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="n">String</span> <span class="n">a</span> <span class="o">=</span> <span class="s">&#34;古时的&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="n">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="s">&#34;风筝&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="s">&#34;风筝&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">==</span><span class="n">s2</span><span class="o">);</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">==</span><span class="n">s3</span><span class="o">);</span>  <span class="c1">// false 
</span></span></span></code></pre></div><p>以上代码，肯定输出的都是 false，因为 new String() 不管你常量池中有没有，我都会在堆中新建一个对象，新建出来的对象，当然不会和其他对象相等。</p>
<h3 id="intern-池化">intern() 池化</h3>
<p>那什么时候会放到字符串常量池呢，就是在使用 intern() 方法之后。</p>
<p>intern() 的定义：如果当前字符串内容存在于字符串常量池，存在的条件是使用 equas() 方法为ture，也就是内容是一样的，那直接返回此字符串在常量池的引用；如果之前不在字符串常量池中，那么在常量池创建一个引用并且指向堆中已存在的字符串，然后返回常量池中的地址。</p>
<h5 id="第一种情况准备池化的字符串与字符串常量池中的字符串有相同equas判断">第一种情况，准备池化的字符串与字符串常量池中的字符串有相同(equas()判断)</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">&#34;古时的风筝&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="n">String</span> <span class="n">a</span> <span class="o">=</span> <span class="s">&#34;古时的&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="n">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="s">&#34;风筝&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">s2</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="na">intern</span><span class="o">();</span>
</span></span></code></pre></div><p>这时，这个字符串常量已经在常量池存在了，这时，再 new 了一个新的对象 s2，并在堆中创建了一个相同字符串内容的对象。</p>
<p><img src="https://hexo.moonkite.cn/blog/5-1.png" alt="5-1"></p>
<p>这时，s1 == s2 会返回 fasle。然后我们调用 s2 = s2.intern()，将池化操作返回的结果赋值给 s2，就会发生如下的变化。</p>
<p><img src="https://hexo.moonkite.cn/blog/5-2.png" alt="5-2"></p>
<p>此时，再次判断 s1 == s2 ，就会返回 true，因为它们都指向了字符串常量池的同一个字符串。</p>
<h5 id="第二种情况字符串常量池中不存在相同内容的字符串">第二种情况，字符串常量池中不存在相同内容的字符串</h5>
<p>使用 new String() 在堆中创建了一个字符串对象</p>
<p><img src="https://hexo.moonkite.cn/blog/5.png" alt="5"></p>
<p>使用了 intern() 之后发生了什么呢，在常量池新增了一个对象，但是 <strong>并没有</strong> 将字符串复制一份到常量池，而是直接指向了之前已经存在于堆中的字符串对象。因为在 JDK 1.7 之后，字符串常量池不一定就是存字符串对象的，还有可能存储的是一个指向堆中地址的引用，现在说的就是这种情况，注意了，下图是只调用了 <code>s2.intern()</code>，并没有返回给一个变量。其中字符串常量池（0x88）指向堆中字符串对象（0x99）就是intern() 的过程。</p>
<p><img src="https://hexo.moonkite.cn/blog/6.png" alt="6"></p>
<p>只有当我们把 s2.intern() 的结果返回给 s2 时，s2 才真正的指向字符串常量池。</p>
<p><img src="https://hexo.moonkite.cn/blog/7.png" alt="7"></p>
<h3 id="我明白了">我明白了</h3>
<p>通过以上的介绍，我们来看下面的一段代码返回的结果是什么</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">&#34;古时的风筝&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">&#34;古时的风筝&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">a</span> <span class="o">=</span> <span class="s">&#34;古时的&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">      
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="s">&#34;风筝&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">s4</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="s">&#34;风筝&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span> <span class="o">==</span> <span class="n">s2</span><span class="o">);</span> <span class="c1">// 【1】 true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span> <span class="o">==</span> <span class="n">s3</span><span class="o">);</span> <span class="c1">// 【2】 false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s3</span> <span class="o">==</span> <span class="n">s4</span><span class="o">);</span> <span class="c1">// 【3】 false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">s3</span><span class="o">.</span><span class="na">intern</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span> <span class="o">==</span> <span class="n">s3</span><span class="o">);</span> <span class="c1">// 【4】 false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">s3</span> <span class="o">=</span> <span class="n">s3</span><span class="o">.</span><span class="na">intern</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span> <span class="o">==</span> <span class="n">s3</span><span class="o">);</span> <span class="c1">// 【5】 true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">s4</span> <span class="o">=</span> <span class="n">s4</span><span class="o">.</span><span class="na">intern</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s3</span> <span class="o">==</span> <span class="n">s4</span><span class="o">);</span> <span class="c1">// 【6】 true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>【1】：s1 == s2 返回 ture，因为都是字面量声明，全都指向字符串常量池中同一字符串。</p>
<p>【2】: s2 == s3 返回 false，因为 new String() 是在堆中新建对象，所以和常量池的常量不相同。</p>
<p>【3】: s3 == s4 返回 false，都是在堆中新建对象，所以是两个对象，肯定不相同。</p>
<p>【4】: s2 == s3 返回 false，前面虽然调用了 intern() ，但是没有返回，不起作用。</p>
<p>【5】: s2 == s3 返回 ture，前面调用了 intern() ，并且返回给了 s3 ，此时 s2、s3 都直接指向常量池的同一个字符串。</p>
<p>【6】: s3 == s4 返回 true，和 s3 相同，都指向了常量池同一个字符串。</p>
<h2 id="为啥我字符串就不可变">为啥我字符串就不可变</h2>
<p>字符串常量池的基础就是字符串的不可变性，如果字符串是可变的，那想一想，常量池就没必要存在了。假设多个变量都指向字符串常量池的同一个字符串，然后呢，突然来了一行代码，不管三七二十一，直接把字符串给变了，那岂不是 jvm 世界大乱。</p>
<p>字符串不可变的根本原因应该是处于安全性考虑。</p>
<p>我们知道 jvm 类型加载的时候会用到类名，比如加载 java.lang.String 类型，如果字符串可变的话，那我替换成其他的字符，那岂不是很危险。</p>
<p>项目中会用到比如数据库连接串、账号、密码等字符串，只有不可变的连接串、用户名和密码才能保证安全性。</p>
<p>字符串在 Java 中的使用频率可谓高之又高，那在高并发的情况下不可变性也使得对字符串的读写操作不用考虑多线程竞争的情况。</p>
<p>还有就是 HashCode，HashCode 是判断两个对象是否完全相等的核心条件，另外，像 Set、Map 结构中的 key 值也需要用到 HashCode 来保证唯一性和一致性，因此不可变的 HashCode 才是安全可靠的。</p>
<p>最后一点就是上面提到的，字符串对象的频繁创建会带来性能上的开销，所以，利用不可变性才有了字符串常量池，使得性能得以保障。</p>
]]></content:encoded></item><item><title>synchronized 到底该不该用？</title><link>https://moonkite.cn/category/java/Synchronized/</link><pubDate>Thu, 11 Feb 2021 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/java/Synchronized/</guid><description>在多线程环境中，锁的使用是避免不了的，使用锁时候有多种锁供我们选择，比如 ReentrantLock、CountDownLatch等等，但是作</description><content:encoded><![CDATA[<p>在多线程环境中，锁的使用是避免不了的，使用锁时候有多种锁供我们选择，比如 <code>ReentrantLock</code>、<code>CountDownLatch</code>等等，但是作为 Java 开发者来说，刚刚接触多线程的时候，最早接触和使用的恐怕非 <code>synchronized</code>莫属了。那你真的了解<code>synchronized</code>吗，今天我们就从以下几个方面彻底搞懂  <code>synchronized</code>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/092f3df261ec4777a60a1fad596f25ec~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>首先有一点要说明一下，各位可能或多或少都听过这样的说法：“synchronized 的性能不行，比显式锁差很多，开发中还是要慎用。”</p>
<p>大可不必有这样的顾虑，要说在 JDK 1.6 之前，synchronized 的性能确实有点差，但是 JDK 1.6 之后，JDK 开发团队已经持续对 synchronized 做了性能优化，其性能已经与其他显式锁基本没有差距了。所以，在考虑是不是使用 <code>synchronized</code>的时候，只需要根据场景是否合适来决定，性能问题不用作为衡量标准。</p>
<h2 id="使用方法">使用方法</h2>
<p>synchronized 是一个关键字，它的一个明显特点就是使用简单，一个关键字搞定。它可以在一个方法上使用，也可以在一个方法中的某些代码块上使用，非常方便。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SyncLock</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  	<span class="kd">private</span> <span class="n">Object</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 直接在方法上加关键字
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">methodLock</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 在代码块上加关键字，锁住当前实例
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">codeBlockLock</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  	<span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 在代码块上加关键字,锁住一个变量
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">codeBlockLock2</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lock</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>具体的使用可以参考我之前写的这篇文章：<a href="https://juejin.im/post/6844904116590755853">类锁和对象锁到底有什么区别</a></p>
<p>依靠 JVM 中的 monitorenter 和 monitorexit 指令控制。通过 <code>javap -v</code>命令可以看到前面的实例代码中对 synchronized 关键字在字节码层面的处理，对于在代码块上加 synchronized 关键字的情况，会通过 <code>monitorenter</code>和<code>monitorexit</code>指令来表示同步的开始和退出标识。而在方法上加关键字的情况，会用 <code>ACC_SYNCHRONIZED</code>作为方法标识，这是一种隐式形式，底层原理都是一样的。</p>
<pre tabindex="0"><code class="language-idl" data-lang="idl"> public synchronized void methodLock();
    descriptor: ()V
    flags: ACC_PUBLIC, ACC_SYNCHRONIZED
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: invokestatic  #3                  // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;
         6: invokevirtual #4                  // Method java/lang/Thread.getName:()Ljava/lang/String;
         9: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        12: return
      LineNumberTable:
        line 12: 0
        line 13: 12

  public void codeBlockLock();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=1
         0: aload_0
         1: dup
         2: astore_1
         3: monitorenter     #
         4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
         7: invokestatic  #3                  // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;
        10: invokevirtual #4                  // Method java/lang/Thread.getName:()Ljava/lang/String;
        13: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        16: aload_1
        17: monitorexit
        18: goto          26
        21: astore_2
        22: aload_1
        23: monitorexit
        24: aload_2
        25: athrow
        26: return
</code></pre><h2 id="对象布局">对象布局</h2>
<p>为什么介绍 synchronized 要说到对象头呢，这和它的锁升级过程有关系，具体的锁升级过程稍后会讲到，作为锁升级过程的数据支撑，必须要掌握对象头的结构才能了解锁升级的完整过程。</p>
<p>在 Java 中，任何的对象实例的内存布局都分为对象头、对象实例数据和对齐填充数据三个部分，其中对象头又包括 MarkWord 和 类型指针。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee2b5be003b2478ba6df316c71dae0f0~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>**对象实例数据：**这部分就是对象的实际数据。</p>
<p>**对齐填充：**因为 HotSpot 虚拟机内存管理要求对象的大小必须是8字节的整数倍，而对象头正好是8个字节的整数倍，但是实例数据不一定，所以需要对齐填充补全。</p>
<p><strong>对象头：</strong></p>
<p>*Klass 指针：*对象头中的 Klass 指针是用来指向对象所属类型的，一个类实例究竟属于哪个类，需要有地方记录，就在这里记。</p>
<p>*MarkWord:*还有一部分就是和 synchronized 紧密相关的 MarkWord 了，主要用来存储对象自身的运行时数据，如hashcode、gc 分代年龄等信息。 MarkWord 的位长度为 JVM 的一个 Word 大小，32位 JVM 的大小为32位，64位JVM的大小为64位。</p>
<p>下图是 64 位虚拟机下的 MarkWord 结构说明，根据对象锁状态不同，某些比特位代表的含义会动态的变化，之所以要这么设计，是因为不想让对象头占用过大的空间，如果为每一个标示都分配固定的空间，那对象头占用的空间将会比较大。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97faedd0871345e6b227136510bda1b6~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>*数组长度：*要说明一下，如果是数组对象的话， 由于数组无法通过本身内容求得自身长度，所以需要在对象头中记录数组的长度。</p>
<h3 id="源码中的定义">源码中的定义</h3>
<p>追根溯源，对象在 JVM 中是怎么定义的呢？打开 JVM 源码，找到其中对象的定义文件，可以看到关于前面说的对象头的定义。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">oopDesc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">friend</span> <span class="k">class</span> <span class="nc">VMStructs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">friend</span> <span class="k">class</span> <span class="nc">JVMCIVMStructs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">volatile</span> <span class="n">markOop</span> <span class="n">_mark</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">union</span> <span class="nc">_metadata</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Klass</span><span class="o">*</span>      <span class="n">_klass</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">narrowKlass</span> <span class="n">_compressed_klass</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="n">_metadata</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>oop 是对象的基础类定义，也就是或 Java 中的 Object 类的定义其实就是用的 oop，而任何类都由 Object 继承而来。oopDesc 只是 oop 的一个别名而已。</p>
<p>可以看到里面有关于 Klass 的声明，还有 markOop 的声明，这个 markOop 就是对应上面说到的 MarkWord。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">markOopDesc</span><span class="o">:</span> <span class="k">public</span> <span class="n">oopDesc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Conversion
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">uintptr_t</span> <span class="n">value</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">uintptr_t</span><span class="p">)</span> <span class="k">this</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Constants
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">enum</span> <span class="p">{</span> <span class="n">age_bits</span>                 <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="c1">//分代年龄
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="n">lock_bits</span>                <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="c1">//锁标志位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="n">biased_lock_bits</span>         <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">//偏向锁标记  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="n">max_hash_bits</span>            <span class="o">=</span> <span class="n">BitsPerWord</span> <span class="o">-</span> <span class="n">age_bits</span> <span class="o">-</span> <span class="n">lock_bits</span> <span class="o">-</span> <span class="n">biased_lock_bits</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="n">hash_bits</span>                <span class="o">=</span> <span class="n">max_hash_bits</span> <span class="o">&gt;</span> <span class="mi">31</span> <span class="o">?</span> <span class="mi">31</span> <span class="o">:</span> <span class="n">max_hash_bits</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="n">cms_bits</span>                 <span class="o">=</span> <span class="n">LP64_ONLY</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="n">NOT_LP64</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">         <span class="n">epoch_bits</span>               <span class="o">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>以上代码只是截取了其中一部分，可以看到其中有关于分代年龄、锁标志位、偏向锁的定义。</p>
<p>虽然源码咱也看不太懂，但是当我看到它们的时候，恍惚之间，内心会感叹到，原来如此。有种宇宙之间，已尽在我掌控之中的感觉。过两天才发现，原来只是一种心理安慰。但是，已经不重要了。</p>
<h5 id="提示">提示</h5>
<p>如果你有兴趣翻源码看看，这部分的定义在 <code>/src/hotspot/share/oops</code>目录下，能告诉你的就这么多了。</p>
<h2 id="锁升级">锁升级</h2>
<p>JDK 1.6 之后，对 synchronized 做了优化，主要就是 CAS 自旋、锁消除、锁膨胀、轻量级锁、偏向锁等，这些技术都是为了在线程之间更高效地共享数据及解决竞争问题，从而提高程序的执行效率，进而产生了一套锁升级的规则。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55f99fe47ee24cb8b8f1b199fdd1227d~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>synchronized 的锁升级过程是通过动态改变对象 MarkWord 各个标志位来表示当前的锁状态的，那修改的是哪个对象的 MarkWord 呢，看上面的代码中，synchronized 关键字是加在 lock 变量上的，那就会控制 lock 的 MarkWord。如果是 <code>synchronized(this)</code>或者在方法上加关键字，那控制的就是当前实例对象的 MarkWord。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41c21d10f8cc4060a6eca371abd5665d~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>synchronized 的核心准则概括起来大概是这个样子。</p>
<blockquote>
<ol>
<li>能不加锁就不加锁。</li>
<li>能偏向就尽量偏向。</li>
<li>能加轻量级锁就不用重量级锁。</li>
</ol>
</blockquote>
<h3 id="无锁转向偏向锁">无锁转向偏向锁</h3>
<p>偏向锁的意思是说，这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a1a80865207415793b23d311dcbdb92~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>当线程尝试获取锁对象的时候，先检查 MarkWord 中的线程ID 是否为空。如果为空，则虚拟机会将 MarkWord 中的偏向标记设置为 1，锁标记位为 01。同时，使用 CAS 操作尝试将线程ID记录到 MarkWord 中，如果 CAS 操作成功，那之后这个持有偏向锁的线程再次进入相关同步块的时候，将不需要再进行任何的同步操作。</p>
<p>如果检查线程ID不为空，并且不为当前线程ID，或者进行 CAS 操作设置线程ID失败的情况下，都要撤销偏向状态，这时候就要升级为偏向锁了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ac0b7b979654fa48964ce54ee849827~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h3 id="偏向锁升级到轻量级锁">偏向锁升级到轻量级锁</h3>
<p>当多个线程竞争锁时，偏向锁会向轻量级锁状态升级。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/511451a5100c4322a950f44a2b709def~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>首先，线程尝试获取锁的时候，先检查锁标志为是否为 01 状态，也就是未锁定状态。</p>
<p>如果是未锁定状态，那就在当前线程的栈帧中建立一个锁记录（Lock Record）区域，这个区域存储 MarkWord 的拷贝。</p>
<p>之后，尝试用 CAS 操作将 MarkWord 更新为指向锁记录的指针（就是上一步在线程栈帧中的 MarkWord 拷贝），如果 CAS 更新成功了，那偏向锁正式升级为轻量级锁，锁标志为变为 00。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6bd791f6550405c8a9ff593ab1a5cfa~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>如果 CAS 更新失败了，那检查 MarkWord 是否已经指向了当前线程的锁记录，如果已经指向自己，那表示已经获取了锁，否则，轻量级锁要膨胀为重量级锁。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5dde0d41b19f4598b5f33d0754ade4c8~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h3 id="轻量级锁升级到重量级锁">轻量级锁升级到重量级锁</h3>
<p>上面的图中已经有了关于轻量级锁膨胀为重量级锁的逻辑。当锁已经是轻量级锁的状态，再有其他线程来竞争锁，此时轻量级锁就会膨胀为重量级锁。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61e3f97077c24412a9a3d9269a3fcf58~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h3 id="重量级锁的实现原理">重量级锁的实现原理</h3>
<p>为什么叫重量级锁呢？在重量级锁中没有竞争到锁的对象会 park 被挂起，退出同步块时 unpark 唤醒后续线程。唤醒操作涉及到操作系统调度会有额外的开销，这就是它被称为重量级锁的原因。</p>
<p>当锁升级为重量级锁的时候，MarkWord 会指向重量级锁的指针 monitor，monitor 也称为管程或监视器锁， 每个对象都存在着一个 monitor 与之关联 ，对象与其 monitor 之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。</p>
<p>ObjectMonitor中有两个队列，_WaitSet 和 _EntryList，用来保存 ObjectWaiter 对象列表( 每个等待锁的线程都会被封装成 ObjectWaiter对象)，_owner 指向持有 ObjectMonitor 对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把 monitor 中的 owner 变量设置为当前线程同时 monitor 中的计数器 count 加1，若线程调用 wait() 方法，将释放当前持有的 monitor，owner 变量恢复为 null，count 自减1，同时该线程进入 WaitSet 集合中等待被唤醒。若当前线程执行完毕也将释放 monitor(锁)并复位变量的值，以便其他线程进入获取 monitor(锁)</p>
<p>monitor 对象存在于每个 Java 对象的对象头中(存储的指针的指向)，synchronized 锁便是通过这种方式获取锁的，也是为什么 Java 中任意对象可以作为锁的原因，同时也是notify/notifyAll/wait等方法存在于顶级对象Object中的原因。</p>
<h3 id="适用场景">适用场景</h3>
<h4 id="偏向锁">偏向锁</h4>
<p><strong>优点：</strong> 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</p>
<p><strong>缺点：</strong> 如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</p>
<p><strong>适用场景：</strong> 适用于只有一个线程访问同步块场景。</p>
<p>有的同学可能会有疑惑，适用于只有一个线程的场景是什么鬼，一个线程还加什么锁。</p>
<p>要知道，有些锁不是你想不加就不加的。比方说你在使用一个第三方库，调用它里面的一个 API，你虽然知道是在单线程下使用，并不需要加锁，但是第三方库不知道啊，你调用的这个 API 正好是用 synchronized 做了同步的。这种情况下，使用偏向锁可以达到最高的性能。</p>
<h4 id="轻量级锁">轻量级锁</h4>
<p><strong>优点：</strong> 竞争的线程不会阻塞，提高了程序的响应速度。</p>
<p><strong>缺点：</strong> 如果始终得不到锁竞争的线程使用自旋会消耗CPU。</p>
<p><strong>适用场景：</strong> 追求响应时间。同步块执行速度非常快。</p>
<h4 id="重量级锁">重量级锁</h4>
<p><strong>优点：</strong> 线程竞争不使用自旋，不会消耗CPU。</p>
<p><strong>缺点：</strong> 线程阻塞，响应时间缓慢。</p>
<p><strong>适用场景：</strong> 追求吞吐量。同步块执行速度较长。</p>
<h2 id="总结">总结</h2>
<p>1、synchronized 是可重入锁，是一个非公平的可重入锁，所以如果场景比较复杂的情况，还是要考虑其他的显式锁，比如 <code>Reentrantlock</code>、<code>CountDownLatch</code>等。</p>
<p>2、synchronized 有锁升级的过程，当有线程竞争的情况下，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在有竞争的情况下，synchronized 会有一定的性能损耗。</p>
]]></content:encoded></item><item><title>线上Java程序占用 CPU 过高，请说一下排查方法？</title><link>https://moonkite.cn/category/java/%E7%BA%BF%E4%B8%8AJava%E7%A8%8B%E5%BA%8F%E5%8D%A0%E7%94%A8-CPU-%E8%BF%87%E9%AB%98%E8%AF%B7%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95/</link><pubDate>Fri, 06 Nov 2020 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/java/%E7%BA%BF%E4%B8%8AJava%E7%A8%8B%E5%BA%8F%E5%8D%A0%E7%94%A8-CPU-%E8%BF%87%E9%AB%98%E8%AF%B7%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95/</guid><description>我是风筝，公众号「古时的风筝」，一个兼具深度与广度的程序员鼓励师，一个本打算写诗却写起了代码的田园码农！文章会收录在 JavaNewBee 中，更有 Java 后端知识图谱</description><content:encoded><![CDATA[<blockquote>
<p>我是风筝，公众号「古时的风筝」，一个兼具深度与广度的程序员鼓励师，一个本打算写诗却写起了代码的田园码农！文章会收录在 <a href="https://github.com/huzhicheng/JavaNewBee">JavaNewBee</a> 中，更有 Java 后端知识图谱，从小白到大牛要走的路都在里面。</p>
</blockquote>
<p>这个问题可以说是 Java 面试的高频面试题了，有很多面试官都喜欢问这个问题，问题可能是下面这样的。</p>
<blockquote>
<p>线上一台服务器 CPU 使用率100% 了，如果你碰到这样的情况，如何排查并找到问题原因？</p>
</blockquote>
<p>这就是一个套路题，所谓套路题就是有标准的套路解法的，掌握了套路，不仅能解决面试官，还能解决问题。不然真的就掉进套路里了。</p>
<p>当我们真碰到这个问题的时候应该怎么排查呢？</p>
<h2 id="模拟一个高-cpu-场景">模拟一个高 CPU 场景</h2>
<p>先用一段程序创建几个线程，将其中一个线程设置成高 CPU 使用率的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>  <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">      <span class="k">try</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">30</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">1000</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">      <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">      <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">thread</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&#34;thread-&#34;</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Thread</span> <span class="n">highCpuThread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">i</span><span class="o">++;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">});</span>
</span></span><span class="line"><span class="cl">  <span class="n">highCpuThread</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&#34;HighCpu&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">highCpuThread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>运行这段程序后，前面 10 个线程都处于休眠状态，只有最后一个线程会持续的占用 CPU 。</p>
<p>运行这段程序，然后就可以开始一些列的操作来发现问题原因了。</p>
<h2 id="排查步骤">排查步骤</h2>
<h3 id="第一步使用-top-找到占用-cpu-最高的-java-进程">第一步，使用 top 找到占用 CPU 最高的 Java 进程</h3>
<p>在真实环境中，首先要确认是不是 Java 程序造成的，如果有系统监控工具，可能会直接在预警信息里告诉你是有哪个进程造成的，但也有可能不知道，需要我们手动排查。</p>
<p>如果是在面试场景中，这个问题可能不需要确认，毕竟 Java 面试，面试官可能直接就告诉你是 Java 占用的 CPU 过高。</p>
<p>这一步也非常简单，就是一个 <code>top</code>命令而已，基本上所有同学都用过这个命令吧。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9cc87c9786040f984f1ad5cf386f327~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>使用 <code>top</code>命令发现占用 CPU 99.7% 的线程是 Java 进程，进程 PID 为 <code>13731</code>。</p>
<h3 id="第二步用-top--hp-命令查看占用-cpu-最高的线程">第二步，用 <code>top -Hp</code> 命令查看占用 CPU 最高的线程</h3>
<p>上一步用 <code>top</code>命令找到了那个 Java 进程。那一个进程中有那么多线程，不可能所有线程都一直占着 CPU 不放，这一步要做的就是揪出这个罪魁祸首，当然有可能不止一个。</p>
<p>执行<code>top -Hp pid</code>命令，pid 就是前面的 Java 进程，我这个例子中就是 <code>13731</code> ，完整命令为：</p>
<p><code>top -Hp 13731</code>，执行之后的效果如下</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82ccd03de2ac4f249738a7c10b49718b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>可以看到占用 CPU 最高的那个线程 PID 为 <code>13756</code>。</p>
<p>然后将 <code>13756</code>转换为 16 进制的，后面会用到，可以用在线进制转换的网站直接转换，转换结果为 <code>0x35bc</code></p>
<h3 id="第三步保存线程栈信息">第三步，保存线程栈信息</h3>
<p>当前 Java 程序的所有线程信息都可以通过 <code>jstack</code>命令查看，我们用<code>jstack</code>命令将第一步找到的 Java 进程的线程栈保存下来。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">jstack <span class="m">13731</span> &gt; thread_stack.log
</span></span></code></pre></div><h3 id="第四步在线程栈中查找最贵祸首的线程">第四步，在线程栈中查找最贵祸首的线程</h3>
<p>第二步已经找到了这个罪魁祸首的线程 PID，并把它转换成了 16 进制的，第三步保存下来的线程栈中有所有线程的 PID 16 进制信息，我们在线程栈中查找这个16进制的线程 id （<code>0x35bc</code>）。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae0894f5f21548d0ad3926468ff946a9~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>怎么样，现在一目了然了，线程名称、线程状态、以及哪行代码消耗了最多的 CPU 都很清楚了。</p>
]]></content:encoded></item><item><title>『JWT』，你必须了解的认证登录方案</title><link>https://moonkite.cn/category/java/JWT%E6%98%AF%E4%BB%80%E4%B9%88/</link><pubDate>Wed, 19 Aug 2020 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/java/JWT%E6%98%AF%E4%BB%80%E4%B9%88/</guid><description>JWT 全称是 JSON Web Token，是目前非常流行的跨域认证解决方案，在单点登录场景中经常使用到。 有些人觉得它非常好用，用了它之后就不用在服务端借助 redis 实</description><content:encoded><![CDATA[<p>JWT 全称是 JSON Web Token，是目前非常流行的跨域认证解决方案，在单点登录场景中经常使用到。</p>
<p>有些人觉得它非常好用，用了它之后就不用在服务端借助 redis 实现认证过程了，但是，还有一部分人认为它生来就有缺陷，根本不能用。</p>
<p>这是为什么呢？</p>
<h2 id="传统的认证方式">传统的认证方式</h2>
<h3 id="从一个登录场景说起">从一个登录场景说起</h3>
<p>你平时用过那么多网站和 APP，其中有很多都是需要登录的吧，那咱们就选一个场景出来说说。</p>
<p>以一个电商系统为例，如果你想要下单，首先需要注册一个账号，拥有了账号之后，需要输入用户名（比如手机号或邮箱）、密码完成登录过程。之后你在一段时间内再次进入系统，是不需要输入用户名和密码的，只有在连续长时间不登录的情况下（例如一个月没登录过）访问系统，才需要再次输入用户名和密码。</p>
<p>对于那些使用频率很高的网站或应用，通常是很长时间都不需要输入密码的，以至于你在换了一台电脑或者一部手机之后，一些经常使用的网站或 APP 的密码都不记得了。</p>
<h3 id="早期的-cookie-session-认证方式">早期的 Cookie-Session 认证方式</h3>
<p>早期互联网以 web 为主，客户端是浏览器 ，所以 Cookie-Session 方式是早期最常用的认证方式，直到现在，一些 web 网站依然用这种方式做认证。</p>
<p><strong>认证过程大致如下：</strong></p>
<ol>
<li>用户输入用户名、密码或者用短信验证码方式登录系统；</li>
<li>服务端验证后，创建一个 Session 信息，并且将 SessionID 存到 cookie，发送回浏览器；</li>
<li>下次客户端再发起请求，自动带上 cookie 信息，服务端通过 cookie 获取 Session 信息进行校验；</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gghdtc2wo5j317s0bwju5.jpg" alt="image-20200706173031724"></p>
<p>但是为什么说它是传统的认证方式，因为现在人手一部智能手机，很多人都不用电脑，平时都是使用手机上的各种 APP，比如淘宝、拼多多等。
在这种潮流之下，传统的 Cookie-Session 就遇到了一些问题：
1、首先，Cookie-Session 只能在 web 场景下使用，如果是 APP 呢，APP 可没有地方存 cookie。
现在的产品基本上都同时提供 web 端和 APP 两种使用方式，有点产品甚至只有 APP。</p>
<p>2、退一万步说，你做的产品只支持 web，也要考虑跨域问题， 但Cookie 是不能跨域的。
拿天猫商城来说，当你进入天猫商城后，会看到顶部有天猫超市、天猫国际、天猫会员这些菜单。而点击这些菜单都会进入不同的域名，不同的域名下的 cookie 都是不一样的，你在 A 域名下是没办法拿到 B 域名的 cookie 的，即使是子域也不行。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gghe2txpyuj31ks09amyu.jpg" alt="image-20200706173939291"></p>
<p>3、如果是分布式服务，需要考虑 Session 同步问题。
现在的互联网网站和 APP 基本上都是分布式部署，也就是服务端不止一台机器。当某个用户在页面上进行登录操作后，这个登录动作必定是请求到了其中某一台服务器上。你的身份信息得保存下来吧，传统方式就是存 Session。</p>
<p>接下来，问题来了。你访问了几个页面，这时，有个请求经过负载均衡，路由到了另外一台服务器（不是你登录的那台）。当后台接到请求后，要检查用户身份信息和权限，于是接口开始从从 Session 中获取用户信息。但是，这台服务器不是当时登录的那台，并没存你的 Session ，这样后台服务就认为你是一个非登录的用户，也就不能给你返回数据了。</p>
<p>所以，为了避免这种情况的发生，就要做 Session 同步。一台服务器接收到登录请求后，在当前服务器保存 Session 后，也要向其他几个服务器同步。</p>
<p>4、cookie 存在 CSRF（跨站请求伪造）的风险。 跨站请求伪造，是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。CSRF 利用的是网站对用户网页浏览器的信任。简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（比如购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户发起的操作。
比如说我是一个黑客，我发现你经常访问的一个技术网站存在 CSRF 漏洞。发布文章支持 html 格式，进而我在 html 中加入一些危险内容，例如</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"> <span class="p">&lt;</span><span class="nt">img</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman&#34;</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>假设 src 指向的地址是一个你平时用的购物网站的付款地址（当然只是举例，真正的攻击可没这么简单），如果你之前登录过并且标识你身份信息的 cookie 已经保存下来了。当你刷到我发布的这篇文章的时候，img 标签一加载，这个 CSRF 攻击就会起作用，在你不知情的情况下向这个网站付款了。</p>
<h3 id="cookie-session-改造版">Cookie-Session 改造版</h3>
<p>由于传统的 Cookie-Session 认证存在诸多问题，那可以把上面的方案改造一下。
1、改造 Cookie 既然 Cookie 不能在 APP 等非浏览器中使用，那就不用 cookie 做客户端存储，改用其他方式。
改成什么呢？
web 中可以使用 local storage，APP 中使用客户端数据库，这样既能这样就实现了跨域，并且避免了 CSRF 。</p>
<p>2、服务端也不存 Session 了，把 Session 信息拿出来存到 Redis 等内存数据库中，这样即提高了速度，又避免了 Session 同步问题；</p>
<p>经过改造之后变成了如下的认证过程：</p>
<ol>
<li>用户输入用户名、密码或者用短信验证码方式登录系统；</li>
<li>服务端经过验证，将认证信息构造好的数据结构存储到 Redis 中，并将 key 值返回给客户端；</li>
<li>客户端拿到返回的 key，存储到  local storage 或本地数据库；</li>
<li>下次客户端再次请求，把 key 值附加到 header 或者 请求体中；</li>
<li>服务端根据获取的 key，到 Redis 中获取认证信息；</li>
</ol>
<p>下面两张图分别演示了首次登录和非首次登录的过程。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggjdjjq9xej30u00von3l.jpg" alt="首次登录"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggjdlwhxocj314r0u0qar.jpg" alt="非首次登录"></p>
<p>经过一顿猛如虎的改造，解决了传统 Cookie-Session 方式存在的问题。这种改造需要开发者在项目中自行完成。改造起来肯定是费时费力的，而且还有可能存在漏洞。</p>
<h2 id="jwt-出场">JWT 出场</h2>
<p>这时，JWT 就可以上场了，JWT 就是一种Cookie-Session改造版的具体实现，让你省去自己造轮子的时间，JWT 还有个好处，那就是你可以不用在服务端存储认证信息（比如 token），完全由客户端提供，服务端只要根据 JWT 自身提供的解密算法就可以验证用户合法性，而且这个过程是安全的。</p>
<p>如果你是刚接触 JWT，最有疑问的一点可能就是： JWT 为什么可以完全依靠客户端(比如浏览器端)就能实现认证功能，认证信息全都存在客户端，怎么保证安全性？</p>
<h2 id="jwt-数据结构">JWT 数据结构</h2>
<p>JWT 最后的形式就是个字符串，它由<strong>头部</strong>、<strong>载荷</strong>与<strong>签名</strong>这三部分组成，中间以「<strong>.</strong>」分隔。像下面这样：</p>
<p><img src="https://hexo.moonkite.cn/blog/997EDE1C-5689-4C3F-98E8-25C25BBEC3FC.png" alt="997EDE1C-5689-4C3F-98E8-25C25BBEC3FC"></p>
<h3 id="头部">头部</h3>
<p>头部以 JSON 格式表示，用于指明令牌类型和加密算法。形式如下，表示使用 JWT 格式，加密算法采用 HS256，这是最常用的算法，除此之外还有很多其他的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;alg&#34;</span><span class="p">:</span> <span class="s2">&#34;HS256&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;typ&#34;</span><span class="p">:</span> <span class="s2">&#34;JWT&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>对应上图的红色 header 部分，需要 Base64 编码。</p>
<h3 id="载荷">载荷</h3>
<p>用来存储服务器需要的数据，比如用户信息，例如姓名、性别、年龄等，要注意的是重要的机密信息最好不要放到这里，比如密码等。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;古时的风筝&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;introduce&#34;</span><span class="p">:</span> <span class="s2">&#34;英俊潇洒&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>另外，JWT 还规定了 7 个字段供开发者选用。</p>
<ul>
<li>iss (issuer)：签发人</li>
<li>exp (expiration time)：过期时间</li>
<li>sub (subject)：主题</li>
<li>aud (audience)：受众</li>
<li>nbf (Not Before)：生效时间</li>
<li>iat (Issued At)：签发时间</li>
<li>jti (JWT ID)：编号</li>
</ul>
<p>这部分信息也是要用 Base64 编码的。</p>
<h3 id="签名">签名</h3>
<p>签名有一个计算公式。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">HMACSHA256</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">base64UrlEncode</span><span class="o">(</span><span class="n">header</span><span class="o">)</span> <span class="o">+</span> <span class="s">&#34;.&#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">  <span class="n">base64UrlEncode</span><span class="o">(</span><span class="n">payload</span><span class="o">),</span>
</span></span><span class="line"><span class="cl">  <span class="n">Secret</span>
</span></span><span class="line"><span class="cl"><span class="o">)</span>
</span></span></code></pre></div><p>使用<code>HMACSHA256</code>算法计算得出，这个方法有两个参数，前一个参数是 （base64 编码的头部 + base64 编码的载荷）用点号相连，后一个参数是自定义的字符串密钥，密钥不要暴露在客户端，近应该服务器知道。</p>
<h2 id="使用方式">使用方式</h2>
<p>了解了 JWT 的结构和算法后，那怎么使用呢？假设我这儿有个网站。</p>
<p>1、在用户登录网站的时候，需要输入用户名、密码或者短信验证的方式登录，登录请求到达服务端的时候，服务端对账号、密码进行验证，然后计算出 JWT 字符串，返回给客户端。</p>
<p>2、客户端拿到这个 JWT 字符串后，存储到 cookie 或者 浏览器的 LocalStorage 中。</p>
<p>3、再次发送请求，比如请求用户设置页面的时候，在 HTTP 请求头中加入 JWT 字符串，或者直接放到请求主体中。</p>
<p>4、服务端拿到这串 JWT 字符串后，使用 base64的头部和 base64 的载荷部分，通过<code>HMACSHA256</code>算法计算签名部分，比较计算结果和传来的签名部分是否一致，如果一致，说明此次请求没有问题，如果不一致，说明请求过期或者是非法请求。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20200817102931783.png" alt=""></p>
<p><img src="https://hexo.moonkite.cn/blog/image-20200817102958727.png" alt=""></p>
<h2 id="怎么保证安全性的">怎么保证安全性的</h2>
<p>保证安全性的关键就是 <code>HMACSHA256</code> 或者与它同类型的加密算法，因为加密过程是不可逆的，所以不能根据传到前端的 JWT 传反解到密钥信息。</p>
<p>另外，不同的头部和载荷加密之后得到的签名都是不同的，所以，如果有人改了载荷部分的信息，那最后加密出的结果肯定就和改之前的不一样的，所以，最后验证的结果就是不合法的请求。</p>
<h2 id="别人拿到完整-jwt-还安全吗">别人拿到完整 JWT 还安全吗</h2>
<p>假设载荷部分存储了权限级别相关的字段，强盗拿到 JWT 串后想要修改为更高权限的级别，上面刚说了，这种情况下是肯定不会得逞的，因为加密出来的签名会不一样，服务器可能很容易的判别出来。</p>
<p>那如果强盗拿到后不做更改，直接用呢，那就没有办法了，为了更大程度上防止被强盗盗取，应该使用 HTTPS 协议而不是 HTTP 协议，这样可以有效的防止一些中间劫持攻击行为。</p>
<p>有同学就要说了，这一点也不安全啊，拿到 JWT 串就可以轻松模拟请求了。确实是这样，但是前提是你怎么样能拿到，除了上面说的中间劫持外，还有什么办法吗？</p>
<p>除非强盗直接拿了你的电脑，那这样的话，对不起，不光 JWT 不安全了，其他任何网站，任何认证方式都不安全。</p>
<p><img src="https://hexo.moonkite.cn/blog/3wdAlLTwZRoLC1bB3mGFTOe0MCW_nYTQ16TKbmH1UuDpzXARmpjyCfcmKkeeA14tFP0TlWGk5Dvkre-DV6XEfiZ6vGsDbk1Nb-6mVv2AK1DumkdDIe_GaQ.jpeg" alt=""></p>
<p>虽然这样的情况很少，但是在使用 JWT 的时候仍然要注意合理的设置过期时间，不要太长。</p>
<h2 id="一个问题">一个问题</h2>
<p>JWT 有个问题，导致很多开发团队放弃使用它，那就是一旦颁发一个 JWT 令牌，服务端就没办法废弃掉它，除非等到它自身过期。有很多应用默认只允许最新登录的一个客户端正常使用，不允许多端登录，JWT 就没办法做到，因为颁发了新令牌，但是老的令牌在过期前仍然可用。这种情况下，就需要服务端增加相应的逻辑。</p>
<h2 id="常用的-jwt-库">常用的 JWT 库</h2>
<p>JWT 官网列出了各种语言对应的库，其中 Java 的如下几个。</p>
<p><img src="https://hexo.moonkite.cn/blog/image-20200817112359199.png" alt="image-20200817112359199"></p>
<p>以 <code>java-jwt</code>为例。</p>
<p>1、引入对应的 Maven 包。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>com.auth0<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>java-jwt<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;version&gt;</span>3.10.3<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>2、在登录时，调用 <code>create</code> 方法得到一个令牌，并返回给前端。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">create</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Algorithm</span> <span class="n">algorithm</span> <span class="o">=</span> <span class="n">Algorithm</span><span class="o">.</span><span class="na">HMAC256</span><span class="o">(</span><span class="s">&#34;secret&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">String</span> <span class="n">token</span> <span class="o">=</span> <span class="n">JWT</span><span class="o">.</span><span class="na">create</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">      <span class="o">.</span><span class="na">withIssuer</span><span class="o">(</span><span class="s">&#34;auth0&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">.</span><span class="na">withSubject</span><span class="o">(</span><span class="s">&#34;subject&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">.</span><span class="na">withClaim</span><span class="o">(</span><span class="s">&#34;name&#34;</span><span class="o">,</span><span class="s">&#34;古时的风筝&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">.</span><span class="na">withClaim</span><span class="o">(</span><span class="s">&#34;introduce&#34;</span><span class="o">,</span><span class="s">&#34;英俊潇洒&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">.</span><span class="na">sign</span><span class="o">(</span><span class="n">algorithm</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">token</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">token</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">JWTCreationException</span> <span class="n">exception</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//Invalid Signing configuration / Couldn&#39;t convert Claims.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">throw</span> <span class="n">exception</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>3、登录成功后，再次发起请求的时候将 token 放到 header 或者请求体中，服务端对 token 进行验证。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="n">Boolean</span> <span class="nf">verify</span><span class="o">(</span><span class="n">String</span> <span class="n">token</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Algorithm</span> <span class="n">algorithm</span> <span class="o">=</span> <span class="n">Algorithm</span><span class="o">.</span><span class="na">HMAC256</span><span class="o">(</span><span class="s">&#34;secret&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">JWTVerifier</span> <span class="n">verifier</span> <span class="o">=</span> <span class="n">JWT</span><span class="o">.</span><span class="na">require</span><span class="o">(</span><span class="n">algorithm</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">.</span><span class="na">withIssuer</span><span class="o">(</span><span class="s">&#34;auth0&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">.</span><span class="na">build</span><span class="o">();</span> <span class="c1">//Reusable verifier instance
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">DecodedJWT</span> <span class="n">jwt</span> <span class="o">=</span> <span class="n">verifier</span><span class="o">.</span><span class="na">verify</span><span class="o">(</span><span class="n">token</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">String</span> <span class="n">payload</span> <span class="o">=</span> <span class="n">jwt</span><span class="o">.</span><span class="na">getPayload</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">jwt</span><span class="o">.</span><span class="na">getClaim</span><span class="o">(</span><span class="s">&#34;name&#34;</span><span class="o">).</span><span class="na">asString</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">String</span> <span class="n">introduce</span> <span class="o">=</span> <span class="n">jwt</span><span class="o">.</span><span class="na">getClaim</span><span class="o">(</span><span class="s">&#34;introduce&#34;</span><span class="o">).</span><span class="na">asString</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">payload</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">introduce</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">JWTVerificationException</span> <span class="n">exception</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//Invalid signature/claims
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>4、用 create 方法生成 token，并用 verify 方法验证一下。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">String</span> <span class="n">token</span> <span class="o">=</span> <span class="n">create</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">Boolean</span> <span class="n">result</span> <span class="o">=</span> <span class="n">verify</span><span class="o">(</span><span class="n">token</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>得到下面的结果</p>
<pre tabindex="0"><code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJzdWJqZWN0IiwiaW50cm9kdWNlIjoi6Iux5L-K5r2H5rSSIiwiaXNzIjoiYXV0aDAiLCJuYW1lIjoi5Y-k5pe255qE6aOO562dIn0.ooQ1K_XyljjHf34Nv5iJvg1MQgVe6jlphxv4eeFt8pA
eyJzdWIiOiJzdWJqZWN0IiwiaW50cm9kdWNlIjoi6Iux5L-K5r2H5rSSIiwiaXNzIjoiYXV0aDAiLCJuYW1lIjoi5Y-k5pe255qE6aOO562dIn0
古时的风筝
英俊潇洒
true
</code></pre><p>使用 create 方法创建的 JWT 串可以通过验证。</p>
<p>而如果我将 JWT 串中的载荷部分，两个点号中间的部分修改一下，然后再调用 verify 方法验证，会出现 <code>JWTVerificationException</code> 异常，不能通过验证。</p>
]]></content:encoded></item><item><title>类锁和对象锁到底有什么区别</title><link>https://moonkite.cn/category/java/%E7%B1%BB%E9%94%81%E5%92%8C%E5%AF%B9%E8%B1%A1%E9%94%81%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</link><pubDate>Thu, 13 Aug 2020 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/java/%E7%B1%BB%E9%94%81%E5%92%8C%E5%AF%B9%E8%B1%A1%E9%94%81%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</guid><description>有锁才有自由 生活中不存在绝对的自由，绝对的自由通常对应的无序和混沌，只有在道德、法律、伦理的约束下的相对自由，才能使人感受到自由。 而在多线程</description><content:encoded><![CDATA[<h2 id="有锁才有自由">有锁才有自由</h2>
<p>生活中不存在绝对的自由，绝对的自由通常对应的无序和混沌，只有在道德、法律、伦理的约束下的相对自由，才能使人感受到自由。</p>
<p>而在多线程编程中，锁是至关重要的，锁就是道德，就是法律约束，没有锁的多线程环境将会是混乱的，所有线程都在争夺资源，最后的结果就是导致系统崩溃，而有了锁之后，多线程环境才能稳定高效的工作。</p>
<h2 id="synchronized-关键字">synchronized 关键字</h2>
<p>synchronized 是我们所说的重量级锁，所说的重量级是相对于那些自旋锁(AQS)而言的，比如可重入锁ReentrantLock。很多人谈 synchronized 色变，说它性能差、太重，貌似言之凿凿。放在多年前确实如此，但是 Java 1.7、1.8 已经对 synchronized 做了很大优化，其性能和那些轻量级锁几乎没有差距。</p>
<p>所以，我们再程序中其实可以放心的使用它，即使没有用过，也肯定在一些源码里见过，比如 Netty 中就有很多地方用到了它。</p>
<p>下面开始进入今天的主题，类锁和实例锁。看名字就已经很明显了，类锁就是所在类上的锁，实例就是锁在类实例上的锁。</p>
<h2 id="实例锁">实例锁</h2>
<p>类声明后，我们可以 new 出来很多的实例对象。这时候，每个实例在 JVM 中都有自己的引用地址和堆内存空间，这时候，我们就认为这些实例都是独立的个体，很显然，在实例上加的锁和其他的实例就没有关系，互不影响了。</p>
<p>通常我们使用实例锁的方式有下面三种：</p>
<p><strong>1、 锁住实体里的非静态变量</strong></p>
<p>非静态变量是实例自身变量，不会与其他实例共享，所以锁住实体内声明的非静态变量可以实现对象锁。锁住同一个变量的方法块共享同一把锁。</p>
<p><img src="https://hexo.moonkite.cn/blog/0.png" alt="0"></p>
<p><strong>2、锁住 this 对象</strong></p>
<p>this 指的是当前对象实例本身，所以，所有使用 <code>synchronized(this) </code>方式的方法都共享同一把锁。</p>
<p><img src="https://hexo.moonkite.cn/blog/1.png" alt="1"></p>
<p><strong>3、直接锁非静态方法</strong></p>
<p>最简单、最直观的一种方式，直接加在方法返回类型前。</p>
<p><img src="https://hexo.moonkite.cn/blog/2.png" alt="2"></p>
<blockquote>
<p><strong>使用对象锁的情况，只有使用同一实例的线程才会受锁的影响，多个实例调用同一方法也不会受影响。</strong></p>
</blockquote>
<p>下面来做个测试，开启 5 个线程，每个线程都 new 一个新的实例来分别调用上面三种方式的方法，方法完成的动作就是输出线程名称，然后休眠 10 秒钟。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ObjectLock</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Object</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 锁住非静态变量
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @throws InterruptedException
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">lockObjectField</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lock</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10</span><span class="o">*</span><span class="mi">1000</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 锁住 this 对象 this 就是当前对象实例
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @throws InterruptedException
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">lockThis</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10</span><span class="o">*</span><span class="mi">1000</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 直接锁住非静态方法
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @throws InterruptedException
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">methodLock</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10</span><span class="o">*</span><span class="mi">1000</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">Thread</span> <span class="n">worker</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="k">new</span> <span class="n">ObjectLockWorker</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">            <span class="n">worker</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&#34;kite-&#34;</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">worker</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ObjectLockWorker</span> <span class="kd">implements</span> <span class="n">Runnable</span><span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">try</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">ObjectLock</span> <span class="n">objectLock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ObjectLock</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 方式 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">objectLock</span><span class="o">.</span><span class="na">lockObjectField</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 方式 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">//objectLock.lockThis();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 方式 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">//objectLock.methodLock();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>==我们预测的结果就是每个线程都会立刻输出线程名称，然后各自休眠 10 秒==</p>
<p>分别调用方式1、2、3，效果都是一样的，我们看到输出结果和我们预测的是一样的，5 个线程都立即输出线程名，然后等待 10 秒，整个程序退出。</p>
<h2 id="类锁">类锁</h2>
<p>类锁是加载类上的，而类信息是存在 JVM 方法区的，并且整个 JVM 只有一份，方法区又是所有线程共享的，所以类锁是所有线程共享的。</p>
<p>使用类锁的方式有如下方式：
<strong>1、锁住类中的静态变量</strong></p>
<p>因为静态变量和类信息一样也是存在方法区的并且整个 JVM 只有一份，所以加在静态变量上可以达到类锁的目的。
<img src="https://hexo.moonkite.cn/blog/3.png" alt="3"></p>
<p><strong>2、直接在静态方法上加 synchronized</strong></p>
<p>因为静态方法同样也是存在方法区的并且整个 JVM 只有一份，所以加在静态方法上可以达到类锁的目的。</p>
<p><img src="https://hexo.moonkite.cn/blog/4.png" alt="4"></p>
<p><strong>3、锁住 xxx.class</strong></p>
<p>对当前类的 <code>.class</code> 属性加锁，可以实现类锁。</p>
<p><img src="https://hexo.moonkite.cn/blog/5.png" alt="5"></p>
<blockquote>
<p><strong>类锁是所有线程共享的锁，所以同一时刻，只能有一个线程使用加了锁的方法或方法体，不管是不是同一个实例。</strong></p>
</blockquote>
<p>下面同样来做个测试，开启 5 个线程，除了调用静态方法的方式，其他两种方式中每个线程都 new 一个新的实例来分别调用，方法内完成的动作就是输出线程名称，然后休眠 10 秒钟。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ClassLock</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Object</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 锁住静态变量
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @throws InterruptedException
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">lockStaticObjectField</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lock</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10</span><span class="o">*</span><span class="mi">1000</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 锁住静态方法
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @throws InterruptedException
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">methodLock</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10</span><span class="o">*</span><span class="mi">1000</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 锁住 xxx.class
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @throws InterruptedException
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">lockClass</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">ClassLock</span><span class="o">.</span><span class="na">class</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10</span><span class="o">*</span><span class="mi">1000</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">Thread</span> <span class="n">worker</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="k">new</span> <span class="n">ClassLockWorker</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">            <span class="n">worker</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&#34;kite-&#34;</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">worker</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ClassLockWorker</span> <span class="kd">implements</span> <span class="n">Runnable</span><span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">try</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">ClassLock</span> <span class="n">classLock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ClassLock</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 方式 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">classLock</span><span class="o">.</span><span class="na">lockStaticObjectField</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 方式 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">//ClassLock.methodLock();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// 方式 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">//classLock.lockClass();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>==我们预测的结果就是刚开始只有1个线程抢到锁，然后输出线程名，之后等待 10 秒中，之后是下一个抢到锁的线程，输出线程名，然后等待 10 秒。直到最后一个抢到锁的线程，整个过程历时大约 50 秒。==</p>
<p>分别调用方式1、2、3，观察执行结果，和我们预测的是一致的。</p>
]]></content:encoded></item><item><title>7000 字说清楚 HashMap，面试点都在里面了</title><link>https://moonkite.cn/category/java/HashMap/</link><pubDate>Sun, 21 Jun 2020 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/java/HashMap/</guid><description>这是上篇文章有趣的图说 HashMap，普通人也能看懂的文字版，其实是这篇先写完，然后画了不少图片，所以就写了一篇图片版的。图片版虽然读起来比</description><content:encoded><![CDATA[<p>这是上篇文章<a href="https://www.moonkite.cn/category/java/HashMap%E6%BC%AB%E7%94%BB%E7%89%88/">有趣的图说 HashMap，普通人也能看懂</a>的文字版，其实是这篇先写完，然后画了不少图片，所以就写了一篇图片版的。图片版虽然读起来比较轻松，但是没有文字版的详细，本篇 7000 多字，建议三连。</p>
<p>在 Java 中，最常用的数据类型是 8 中基本类型以及他们的包装类型以及字符串类型，其次应该就是 <code>ArrayList</code>和<code>HashMap</code>了吧。<code>HashMap</code>存的是键值对类型的数据，其存储和获取的速度快、性能高，是非常好用的一个数据结构，每一个 Java 开发者都肯定用过它。</p>
<p>而且 <code>HashMap</code>的设计巧妙，其结构和原理也经常被拿去当做面试题。其中有很多巧妙的算法和设计，比如 Hash 算法、拉链法、红黑树设计等，值得每一个开发者借鉴学习。</p>
<p>想了老半天，怎么才能简单易懂的把 <code>HashMap</code>说明白呢，那就从我理解它的思路和过程去说吧。要理解一个事物最好的方式就是先了解整体结构，再去追究细节。所以，我们先从结构谈起。</p>
<h2 id="先从结构说起">先从结构说起</h2>
<p>拿我自身的一个体会来说吧，风筝我作为一个专业路痴，对于迷路这件事儿绝不含糊，虽然在北京混迹多年，但是只在中关村能分清南北，其他地方，哪怕是我每天住的小区、每天工作的公司也分不太清方向，回家只能认一条路，要是打车换条路回家，也得迷糊一阵，这么说吧，在小区前面能回家，小区后面找不到家。去个新地方，得盯着地图看半天。这时，我就在想啊，要是我能在城市上空俯瞰下面的街道，那我就再也不怕找不到回家的路了。这不就是三体里的降维打击吗，站在高维的立场，理解低维的事物，那就简单多了。</p>
<p>理解数据结构也是一个道理，大多数时候，我们都是停留在会用的层面上，理解一些原理也只是支离破碎的，困在数据机构的迷宫里跌跌撞撞，迫切的需要一张地图或者一架直升机。</p>
<p>先来看一下整个 <code>Map</code>家族的集成关系图，一看东西还不少，但其他的可能都没怎么用过，只有 <code>HashMap</code>最熟悉。</p>
<p><img src="https://hexo.moonkite.cn/blog/640.jpeg" alt=""></p>
<p>以下描述可能不够专业，只为简单的描述 <code>HashMap</code>的结构，请结合下图进行理解。</p>
<p><img src="https://hexo.moonkite.cn/blog/640-20230607151814343.jpeg" alt=""></p>
<p><code>HashMap</code>主体上就是一个数组结构，每一个索引位置英文叫做一个 bin，我们这里先管它叫做桶，比如你定义一个长度为 8 的 <code>HashMap</code>，那就可以说这是一个由 8 个桶组成的数组。当我们像数组中插入数据的时候，大多数时候存的都是一个一个 Node 类型的元素，Node 是 <code>HashMap</code>中定义的静态内部类。</p>
<p>当插入数据（也就是调用 put 方法）的时候，并不是按顺序一个一个向后存储的，<code>HashMap</code>中定义了一套专门的索引选择算法，叫做散列计算，但散列计算存在一种情况，叫哈希碰撞，也就是两个不一样的 key 散列计算出来的 hash 值是一致的，这种情况怎么办呢，采用拉链法进行扩展，比如图中蓝色的链表部分，这样一来，具有相同 hash 值的不同 key 即可以落到相同的桶中，又保证不会覆盖之前的内容。</p>
<p>但随着插入的元素越来越多，发生碰撞的概率就越大，某个桶中的链表就会越来越长，直到达到一个阈值，<code>HashMap</code>就受不了了，为了提升性能，会将超过阈值的链表转换形态，转换成红黑树的结构，这个阈值是 8 。也就是单个桶内的链表节点数大于 8 ，就会将链表变身为红黑树。</p>
<p>以上概括性的描述就是 <code>HashMap</code>的整体结构，也是我们进一步研究细节的蓝图。我们将从中抽取出几个关键点一一解释，从整体到细节，降维打击 <code>HashMap</code>。</p>
<p>接下来就是说明为什么会设计成这样的结构以及从单纯数组到桶内链表产生，接着把链表转换成红黑树的详细过程。</p>
<h2 id="认清几个关键概念">认清几个关键概念</h2>
<h3 id="存储容器">存储容器</h3>
<p>因为<code>HashMap</code>内部是用一个数组来保存内容的，数组定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">transient</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">table</span><span class="o">;</span>
</span></span></code></pre></div><h3 id="node-类型">Node 类型</h3>
<p>table 是一个 <code>Node</code>类型的数组，<code>Node</code>是其中定义的静态内部类，主要包括 hash、key、value 和 next 的属性。比如之后我们使用 put 方法像其中加键值对的时候，就会转换成 Node 类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">final</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">final</span> <span class="n">K</span> <span class="n">key</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">V</span> <span class="n">value</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="treenode">TreeNode</h3>
<p>前面说了，当桶内链表到达 8 的时候，会将链表转换成红黑树，就是 <code>TreeNode</code>类型，它也是 <code>HashMap</code>中定义的静态内部类。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">LinkedHashMap</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">parent</span><span class="o">;</span>  <span class="c1">// red-black tree links
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">left</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">right</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">prev</span><span class="o">;</span>    <span class="c1">// needed to unlink next upon deletion
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">boolean</span> <span class="n">red</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="容量和默认容量">容量和默认容量</h3>
<p>容量就是 table 数组的长度，也就是我们所说的桶的个数。其定义如下</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">threshold</span><span class="o">;</span>
</span></span></code></pre></div><p>默认是 16，如果我们在初始化的时候没有指定大小，那就是 16。当然我们也可以自己指定初始大小，而 <code>HashMap</code> 要求初始大小必须是 2 的 幂次方。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="c1">// aka 16
</span></span></span></code></pre></div><h3 id="元素个数">元素个数</h3>
<p>容量是指定了桶的个数，而 size 是说 <code>HashMap</code>中实际存了多少个键值对。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">transient</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
</span></span></code></pre></div><h3 id="最大容量">最大容量</h3>
<p>table 的长度也是有限制的，不能无限大，<code>HashMap</code>规定最大长度为 2 的30次方。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="o">;</span>
</span></span></code></pre></div><h3 id="负载因子">负载因子</h3>
<p>这是一个系数，它和 threshold 结合起作用，默认是 0.75。一般情况下不要改。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">final</span> <span class="kt">float</span> <span class="n">loadFactor</span><span class="o">;</span>
</span></span></code></pre></div><h3 id="扩容阈值">扩容阈值</h3>
<p><code>阈值 = 容量 x 负载因子</code>，假设当前 <code>HashMap</code>的容量是 16，负载因子是默认值 0.75，那么当 size 到达 <code>16 x 0.75=</code> 12 的时候，就会触发扩容。</p>
<h2 id="初始化-hashmap">初始化 HashMap</h2>
<p>使用 <code>HashMap</code>肯定要初始化吧，很多情况下都是用无参构造方法创建。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
</span></span></code></pre></div><p>这种情况下所有属性都是默认值，比如容量是 16，负载因子是 0.75。</p>
<p>另外推荐的一种初始化方式，就是给定一个默认容量，比如指定默认容量是 32。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;(</span><span class="mi">32</span><span class="o">);</span>
</span></span></code></pre></div><p>但是 <code>HashMap</code> 要求初始大小必须是 2 的 n 次方，但是又不能要求每个开发人员指定初始容量的时候都按要求来，比如我们指定初始大小为为 7、18 这种会怎么样呢？</p>
<p>没关系，<code>HashMap</code>中有个方法专门负责将传过来的参数值转换为最接近、且大于等于指定参数的 2 的 n 次方的值，比如指定大小为 7 的话，最后实际的容量就是 8 ，如果指定大小为 18的话，那最后实际的容量就是 32 。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="nf">HashMap</span><span class="o">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">,</span> <span class="kt">float</span> <span class="n">loadFactor</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&#34;Illegal initial capacity: &#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                                       <span class="n">initialCapacity</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&gt;</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">initialCapacity</span> <span class="o">=</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="o">(</span><span class="n">loadFactor</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">Float</span><span class="o">.</span><span class="na">isNaN</span><span class="o">(</span><span class="n">loadFactor</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&#34;Illegal load factor: &#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                                       <span class="n">loadFactor</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="o">.</span><span class="na">loadFactor</span> <span class="o">=</span> <span class="n">loadFactor</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="o">.</span><span class="na">threshold</span> <span class="o">=</span> <span class="n">tableSizeFor</span><span class="o">(</span><span class="n">initialCapacity</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>执行这个转换动作的就是 <code>tableSizeFor</code>方法，经过转换后，将最终的结果赋值给 <code>threshold</code>变量，也就是初始容量，也就是本篇中所说的桶个数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">tableSizeFor</span><span class="o">(</span><span class="kt">int</span> <span class="n">cap</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">cap</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">2</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">4</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">8</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">16</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">)</span> <span class="o">?</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">:</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>tableSizeFor</code>这个方法就有意思了，先把初始参数减 1，然后连着做<code>或等于</code>和<code>无符号右移</code>操作，最后算出一个接近的 2 的幂次方，下图演示了初始参数为 18 时的一系列操作，最后得出的初始大小为 32。</p>
<p><img src="https://hexo.moonkite.cn/blog/640-20230607151924028.jpeg" alt=""></p>
<p>这个算法很有意思了，比如你给的初始大小是 63，那得到的结果就是 64，如果初始大小给定 65 ，那得到的结果就是 128，总是能得出<strong>不小于给定初始大小，并且最接近的2的n次方</strong>的最终值。</p>
<h2 id="从-put-方法解密核心原理">从 put 方法解密核心原理</h2>
<p><code>put</code>方法是增加键值对最常用的方法，也是最复杂的过程，增加键值对的过程涉及了 <code>HashMap</code>最核心的原理，主要包括以下几点：</p>
<ol>
<li>什么情况下会扩容，扩容的规则是什么？</li>
<li>插入键值对的时候如何确定索引，<code>HashMap</code>可不是按顺序插入的，那样不就真成了数组了吗。</li>
<li>如何确保 key 的唯一性？</li>
<li>发生哈希碰撞怎么处理？</li>
<li>拉链法是什么？</li>
<li>单桶内的链表如何转变成红黑树？</li>
</ol>
<p>以下是 put 方法的源码，我在其中做了注释。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">V</span> <span class="nf">put</span><span class="o">(</span><span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">putVal</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">final</span> <span class="n">V</span> <span class="nf">putVal</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">onlyIfAbsent</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">               <span class="kt">boolean</span> <span class="n">evict</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">HashMap</span><span class="o">.</span><span class="na">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span> <span class="c1">// 声明 Node 数组 tab
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">HashMap</span><span class="o">.</span><span class="na">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">;</span>    <span class="c1">// 声明一个 Node 变量 p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">i</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">  * table 定义 transient Node&lt;K,V&gt;[] table; 用来存储 Node 节点
</span></span></span><span class="line"><span class="cl"><span class="cm">  * 如果 当前table为空，则调用resize() 方法分配数组空间
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="o">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">n</span> <span class="o">=</span> <span class="o">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">resize</span><span class="o">()).</span><span class="na">length</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// n 总是为 2 的幂次方，(n-1) &amp; hash 可确定 tab.length （也就是table数组长度）内的索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 然后 创建一个 Node 节点赋给当前索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="o">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">])</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//如果当前索引位置已经有值了，怎么办
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 拉链法出场
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">HashMap</span><span class="o">.</span><span class="na">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">K</span> <span class="n">k</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 判断 key 值唯一性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// p 是当前待插入索引处的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 哈希值一致并且（当前位置的 key == 待插入的key(注意 == 符号)，或者key 不为null 并且 key.equals(k)）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span> <span class="c1">//如果当前节点只有一个元素，且和待插入key一样 则覆盖
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// 将 p（当前索引）节点临时赋予 e
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="k">instanceof</span> <span class="n">HashMap</span><span class="o">.</span><span class="na">TreeNode</span><span class="o">)</span> <span class="c1">// 如果当前索引节点是一颗树节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">//插入节点树中 并返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">e</span> <span class="o">=</span> <span class="o">((</span><span class="n">HashMap</span><span class="o">.</span><span class="na">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;)</span><span class="n">p</span><span class="o">).</span><span class="na">putTreeVal</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 当前索引节点即不是只有一个节点，也不是一颗树，说明是一个链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">binCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">;</span> <span class="o">++</span><span class="n">binCount</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//找到没有 next 的节点，也就是最后一个
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="c1">// 创建一个 node 赋给 p.next
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// 如果当前位置+1之后大于 TREEIFY_THRESHOLD 则要进行树化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="k">if</span> <span class="o">(</span><span class="n">binCount</span> <span class="o">&gt;=</span> <span class="n">TREEIFY_THRESHOLD</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="c1">// -1 for 1st
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//执行树化操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">treeifyBin</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">          <span class="k">break</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//如果又发生key冲突则停止 后续这个节点会被相同的key覆盖
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">            <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
</span></span><span class="line"><span class="cl">          <span class="k">break</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">p</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">      <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// existing mapping for key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">V</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="o">(!</span><span class="n">onlyIfAbsent</span> <span class="o">||</span> <span class="n">oldValue</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">e</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">afterNodeAccess</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">oldValue</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 当实际长度大于 threshold 时 resize
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="o">(++</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">resize</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">afterNodeInsertion</span><span class="o">(</span><span class="n">evict</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="首次初始化数组和扩容">首次初始化数组和扩容</h3>
<p>在执行 <code>put</code>方法时，第一步要检查 table 数组是否为空或者长度是否为 0，如果是这样的，说明这是首次插入键值对，需要执行 table 数组初始化操作。</p>
<p>另外，随之键值对添加的越来越多，<code>HashMap</code>的 size 越来越大，注意 size 前面说了，是实际的键值对数量，那么 size 到了多少就要扩容了呢，并不是等 size 和 threshold（容量）一样大了才扩容，而是到了阈值就开始扩容，阈值上面也说了，是<code>容量 x 负载因子</code>。</p>
<p>为什么放在一起说呢，因为首次初始化和扩容都是用的同一个方法，叫做 <code>resize()</code>。以下是我注释的 <code>resize()</code>方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">final</span> <span class="n">HashMap</span><span class="o">.</span><span class="na">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="nf">resize</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 保存 table 副本，接下来 copy 到新数组用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">HashMap</span><span class="o">.</span><span class="na">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">oldTab</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 当前 table 的容量，是 length 而不是 size
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">oldCap</span> <span class="o">=</span> <span class="o">(</span><span class="n">oldTab</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">oldTab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 当前桶大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">oldThr</span> <span class="o">=</span> <span class="n">threshold</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">newCap</span><span class="o">,</span> <span class="n">newThr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="o">(</span><span class="n">oldCap</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//如果当前容量大于 0，也就是非第一次初始化的情况（扩容场景下）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">oldCap</span> <span class="o">&gt;=</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//不能超过最大允许容量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">threshold</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">oldTab</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">newCap</span> <span class="o">=</span> <span class="n">oldCap</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">             <span class="n">oldCap</span> <span class="o">&gt;=</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="o">)</span> <span class="c1">// 双倍扩容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">newThr</span> <span class="o">=</span> <span class="n">oldThr</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// double threshold
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">oldThr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="c1">// 初始化的场景（给定默认容量），比如 new HashMap(32)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">newCap</span> <span class="o">=</span> <span class="n">oldThr</span><span class="o">;</span> <span class="c1">//将容量设置为 threshold 的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">else</span> <span class="o">{</span>               <span class="c1">// 无参数初始化场景，new HashMap()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 容量设置为 DEFAULT_INITIAL_CAPACITY
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">newCap</span> <span class="o">=</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 阈值 超过阈值会触发扩容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">newThr</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">DEFAULT_LOAD_FACTOR</span> <span class="o">*</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="o">(</span><span class="n">newThr</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//给定默认容量的初始化情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">ft</span> <span class="o">=</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span><span class="n">newCap</span> <span class="o">*</span> <span class="n">loadFactor</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">newThr</span> <span class="o">=</span> <span class="o">(</span><span class="n">newCap</span> <span class="o">&lt;</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">&amp;&amp;</span> <span class="n">ft</span> <span class="o">&lt;</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span><span class="n">MAXIMUM_CAPACITY</span> <span class="o">?</span>
</span></span><span class="line"><span class="cl">              <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">ft</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 保存新的阈值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">threshold</span> <span class="o">=</span> <span class="n">newThr</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 创建新的扩容后数组，然后将旧的元素复制过去
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nd">@SuppressWarnings</span><span class="o">({</span><span class="s">&#34;rawtypes&#34;</span><span class="o">,</span><span class="s">&#34;unchecked&#34;</span><span class="o">})</span>
</span></span><span class="line"><span class="cl">  <span class="n">HashMap</span><span class="o">.</span><span class="na">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">newTab</span> <span class="o">=</span> <span class="o">(</span><span class="n">HashMap</span><span class="o">.</span><span class="na">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[])</span><span class="k">new</span> <span class="n">HashMap</span><span class="o">.</span><span class="na">Node</span><span class="o">[</span><span class="n">newCap</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">  <span class="n">table</span> <span class="o">=</span> <span class="n">newTab</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="o">(</span><span class="n">oldTab</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">oldCap</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">HashMap</span><span class="o">.</span><span class="na">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">      <span class="c1">//遍历 获得得到元素 赋给 e
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">oldTab</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//如果当前桶不为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">oldTab</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// 置空回收
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="c1">//节点 next为空的话 重新寻找落点 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">newTab</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">newCap</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="k">instanceof</span> <span class="n">HashMap</span><span class="o">.</span><span class="na">TreeNode</span><span class="o">)</span> <span class="c1">//如果是树节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="c1">//红黑树节点单独处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="o">((</span><span class="n">HashMap</span><span class="o">.</span><span class="na">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;)</span><span class="n">e</span><span class="o">).</span><span class="na">split</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">newTab</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">oldCap</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="o">{</span> <span class="c1">// 保持原顺序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">HashMap</span><span class="o">.</span><span class="na">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">loHead</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">loTail</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">          <span class="n">HashMap</span><span class="o">.</span><span class="na">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">hiHead</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">hiTail</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">          <span class="n">HashMap</span><span class="o">.</span><span class="na">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">          <span class="k">do</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">((</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">&amp;</span> <span class="n">oldCap</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">              <span class="k">if</span> <span class="o">(</span><span class="n">loTail</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">loHead</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">              <span class="k">else</span>
</span></span><span class="line"><span class="cl">                <span class="n">loTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">              <span class="n">loTail</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">              <span class="k">if</span> <span class="o">(</span><span class="n">hiTail</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">hiHead</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">              <span class="k">else</span>
</span></span><span class="line"><span class="cl">                <span class="n">hiTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">              <span class="n">hiTail</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">          <span class="o">}</span> <span class="k">while</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="o">(</span><span class="n">loTail</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">loTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">newTab</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">loHead</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">          <span class="o">}</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="o">(</span><span class="n">hiTail</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">hiTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">newTab</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">oldCap</span><span class="o">]</span> <span class="o">=</span> <span class="n">hiHead</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">          <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">      <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">newTab</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><strong>首次初始化</strong></p>
<p><code>put</code>方法中先检查 table 数组是否为空，如果为空就初始化。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="k">if</span> <span class="o">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">n</span> <span class="o">=</span> <span class="o">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">resize</span><span class="o">()).</span><span class="na">length</span><span class="o">;</span>
</span></span></code></pre></div><p>首次初始化分为无参初始化和有参初始化两种情况，前面在讲 <code>HashMap</code>初始化的时候说了，无参情况默认就是 16，也就是 table 的长度为 16。有参初始化的时候，首先使用 <code>tableSizeFor()</code>方法确定实际容量，最后 new 一个 Node 数组出来。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">HashMap</span><span class="o">.</span><span class="na">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">newTab</span> <span class="o">=</span> <span class="o">(</span><span class="n">HashMap</span><span class="o">.</span><span class="na">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[])</span><span class="k">new</span> <span class="n">HashMap</span><span class="o">.</span><span class="na">Node</span><span class="o">[</span><span class="n">newCap</span><span class="o">];</span>
</span></span></code></pre></div><p>其中 <code>newCap</code>就是容量，默认16或者自定义的。</p>
<p>而这个过程中还有很重要的一步，就是维护<code>扩容阈值</code>。</p>
<p><strong>扩容</strong></p>
<p><code>put</code>方法中，判断当 size（实际键值对个数）到达 <code>threshold</code> （阈值）时，触发扩容操作。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 当实际长度大于 threshold 时 resize
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="o">(++</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">resize</span><span class="o">();</span>
</span></span></code></pre></div><p><code>HashMap</code>遵循两倍扩容规则，每次扩容之后的大小是扩容前的两倍。另外，说到底，底层的存储还是一个数组，Java 中没有真正的动态数组这一说，数组初始化的时候是多大，那它就一直是这么大，那扩容是怎么来的呢，答案就是创建一个新数组，然后将老数组的数据拷贝过去。</p>
<p>拷贝的时候可能会有如下几种情况：</p>
<ol>
<li>如果节点 next 属性为空，说明这是一个最正常的节点，不是桶内链表，也不是红黑树，这样的节点会重新计算索引位置，然后插入。</li>
<li>如果是一颗红黑树，则使用 <code>split</code>方法处理，原理就是将红黑树拆分成两个 TreeNode 链表，然后判断每个链表的长度是否小于等于 6，如果是就将 TreeNode 转换成桶内链表，否则再转换成红黑树。</li>
<li>如果是桶内链表，则判断 (e.hash &amp; oldCap) 的值，如果是0，就放到原索引位置，如果是1，就放到原索引+扩容前长度的索引位置(j + oldCap)，而链表的顺序仍然保持不变，这样的结果和「扰动函数」中 (n - 1) &amp; hash 的计算结果是一样的。</li>
</ol>
<h3 id="确定插入点">确定插入点</h3>
<p>当我们调用 <code>put</code>方法时，第一步是对 key 进行 hash 计算，计算这个值是为了之后寻找落点，也就是究竟要插入到 table 数组的哪个桶中。</p>
<p>hash 算法是这样的，拿到 key 的 hashCode，将 hashCode 做一次16位右位移，然后将右移的结果和 hashCode 做异或运算，这段代码叫做「<strong>扰动函数</strong>」，之所以不直接拿 hashCode 是为了增加随机性，减少哈希碰撞次数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">* 用来计算 key 的 hash 值
</span></span></span><span class="line"><span class="cl"><span class="cm">**/</span>
</span></span><span class="line"><span class="cl"><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">hash</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">h</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">(</span><span class="n">h</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">())</span> <span class="o">^</span> <span class="o">(</span><span class="n">h</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">16</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>拿到这个 hash 值之后，会进行这样的运算 <code>i = (n - 1) &amp; hash</code>，其中 <code>i</code>就是最终计算出来的索引位置。</p>
<p>有两个场景用到了这个索引计算公式，第一个场景就是 <code>put</code>方法插入键值对的时候。第二个场景是在 resize 扩容的时候，new 出来新数组之后，将已经存在的节点移动到新数组的时候，如果节点不是链表，也不是红黑树，而是一个普通的 Node 节点，会重新计算，找到在新数组中的索引位置。</p>
<p>接着看图，还是图说的清楚。</p>
<p><code>HashMap</code> 要求容量必须是 2 的 n 次方，2的 n 次方的二进制表示大家肯定都很清楚，2的6次方，就是从右向左 6 个 0，然后第 7 位是 1，下图展示了 2 的 6 次方的二进制表示。</p>
<p><img src="https://hexo.moonkite.cn/blog/640-20230607151955196.jpeg" alt=""></p>
<p>然后这个 <code>n-1</code>的操作就厉害了，减一之后，后面之前二进制表示中 1 后面的 0 全都变成了 1，1 所在的位变为 0。比如 64-1 变为 63，其二进制表示是下面这样的。</p>
<p><img src="https://hexo.moonkite.cn/blog/640-20230607152013884.jpeg" alt=""></p>
<p>下图中，前面 4 行分别列出了当 map 的容量为 8、16、32、64的时候，假设容量为 n，则对应的 <code>n-1</code> 的二进制表示是下面这样的，尾部一片红，都是 1 ，能预感到将要有什么骚操作。</p>
<p>没错，将这样的二进制表示代入这个公式 <code>(n - 1) &amp; hash</code>中，最终就能确定待插入的索引位了。接着看图最下面的三行，演示了假设当前 <code>HashMap</code>的容量为 64 ，而待插入的一个 key 经过 hash 计算后得到的结果是 99 时，代入公式计算 index 的值，也就是 <code>（64-1）&amp; 99</code>，最终的计算结果是 35，也就是这个 key 会落到 table[35] 这个位置。</p>
<p>为什么 <code>HashMap</code>一定要保证容量是 2 的幂次方呢，通过二进制表示可以看出，如果有多位是 1 ，那与 hash 值进行<code>与运算</code>的时候，更能保证最后散列的结果均匀，这样很大程度上由 hash 的值来决定。</p>
<p><img src="https://hexo.moonkite.cn/blog/640-20230607152028529.jpeg" alt=""></p>
<h3 id="如何确保-key-的唯一性">如何确保 key 的唯一性</h3>
<p><code>HashMap</code>中不允许存在相同的 key 的，那怎么保证 key 的唯一性呢，判断的代码如下。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
</span></span></code></pre></div><p>首先通过 hash 算法算出的值必须相等，算出的结果是 int，所以可以用 == 符号判断。只是这个条件可不行，要知道哈希碰撞是什么意思，有可能两个不一样的 key 最后产生的 hash 值是相同的。</p>
<p>并且待插入的 key == 当前索引已存在的 key，或者 待插入的 key.equals(当前索引已存在的key)，注意<code>==</code> 和 equals 是或的关系。== 符号意味着这是同一个对象， equals 用来确定两个对象内容相同。</p>
<p>如果 key 是基本数据类型，比如 int，那相同的值肯定是相等的，并且产生的 hashCode 也是一致的。</p>
<p><code>String</code> 类型算是最常用的 key 类型了，我们都知道相同的字符串产生的 hashCode 也是一样的，并且字符串可以用 equals 判断相等。</p>
<p>但是如果用引用类型当做 key 呢，比如我定义了一个 <code>MoonKey</code> 作为 key 值类型</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MoonKey</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">keyTile</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getKeyTile</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">keyTile</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setKeyTile</span><span class="o">(</span><span class="n">String</span> <span class="n">keyTile</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">keyTile</span> <span class="o">=</span> <span class="n">keyTile</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">o</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">getClass</span><span class="o">()</span> <span class="o">!=</span> <span class="n">o</span><span class="o">.</span><span class="na">getClass</span><span class="o">())</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">MoonKey</span> <span class="n">moonKey</span> <span class="o">=</span> <span class="o">(</span><span class="n">MoonKey</span><span class="o">)</span> <span class="n">o</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">keyTile</span><span class="o">,</span> <span class="n">moonKey</span><span class="o">.</span><span class="na">keyTile</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>然后用下面的代码进行两次添加，你说 size 的长度是 1 还是 2 呢？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Map</span><span class="o">&lt;</span><span class="n">MoonKey</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl"><span class="n">MoonKey</span> <span class="n">moonKey</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MoonKey</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">moonKey</span><span class="o">.</span><span class="na">setKeyTile</span><span class="o">(</span><span class="s">&#34;1&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">MoonKey</span> <span class="n">moonKey1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MoonKey</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">moonKey1</span><span class="o">.</span><span class="na">setKeyTile</span><span class="o">(</span><span class="s">&#34;1&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">m</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">moonKey</span><span class="o">,</span> <span class="s">&#34;1&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">m</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">moonKey1</span><span class="o">,</span> <span class="s">&#34;2&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">moonKey</span><span class="o">));</span>
</span></span><span class="line"><span class="cl"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">moonKey1</span><span class="o">));</span>
</span></span><span class="line"><span class="cl"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
</span></span></code></pre></div><p>答案是 2 ，为什么呢，因为 <code>MoonKey</code> 没有重写 <code>hashCode</code> 方法，导致 moonkey 和 moonKey1 的 hash 值不可能一样，当不重写 <code>hashCode</code> 方法时，默认继承自 <code>Object</code>的 hashCode 方法，而每个 <code>Object</code>对象的 hash 值都是独一无二的。</p>
<p><strong>划重点</strong>，正确的做法应该是加上 <code>hashCode</code>的重写。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Override</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">Objects</span><span class="o">.</span><span class="na">hash</span><span class="o">(</span><span class="n">keyTile</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>这也是为什么要求重写 <code>equals</code> 方法的同时，也必须重写 <code>hashCode</code>方法的原因之一。 如果两个对象通过调用equals方法是相等的，那么这两个对象调用hashCode方法必须返回相同的整数。有了这个基础才能保证 <code>HashMap</code>或者<code>HashSet</code>的 key 唯一。</p>
<h3 id="发生哈希碰撞怎么办">发生哈希碰撞怎么办</h3>
<p>前面刚说了相等的对象产生的 hashCode 也要相等，但是不相等的对象使用 <code>hash</code>方法计算之后也有可能产生相同的值，这就叫做哈希碰撞。虽然通过算法已经很大程度上避免碰撞的发生，但是却无法避免。</p>
<p>产生碰撞之后，自然得出的在 table 数组的索引（也就是桶）也是一样的，这时，怎么办呢，一个桶里怎么放多个键值对？</p>
<p><strong>拉链法</strong></p>
<p>文章刚开头就提到了，<code>HashMap</code>可不是简单的数组而已。当碰撞发生就坦然接收。有一种方法叫做拉链法，不是衣服上那种拉链。而是，当碰撞发生了，就在当前桶上拉一条链表出来，这样解释就合理了。</p>
<p>前面介绍关键概念的时候提到了 <code>Node</code>类型，里面有个属性叫做 <code>next</code>，它就是为了这种链表设计的，如下图所示。node1、node2、node3都落在了同一个桶中，这时候就得用链表的方式处理了，node1.next = node2，node2.next = node3，这样将链表串起来。而 node3.next = null，则说明这是链表的尾巴。</p>
<p>当有新元素准备插入到链表的时候，采用的是尾插法，而不是头插法了，JDK 1.7 的版本采用的是头插法，但是头插法有个问题，就是在两个线程执行 resize() 扩容的时候，很可能造成环形链表，导致 get 方法出现死循环。</p>
<p><img src="https://hexo.moonkite.cn/blog/640-20230607152049455.jpeg" alt="图片"></p>
<p><strong>链表转换成树</strong></p>
<p>链表不是碰撞处理的终极结构，终极结构是红黑树，当链表长度到达 8 之后，再有新元素进来，那就要开始由链表到红黑树的转换了。方法 <code>treeifyBin</code>是完成这个过程的。</p>
<p>使用红黑树是出于性能方面的考虑，红黑树的查找速度要优于链表。那为什么不是一开始就直接生成红黑树，而是链表长度大于 8 之后才升级成树呢？</p>
<p>首先来说，哈希碰撞的概率还是很小的，大部分情况下都是一个桶装一个 <code>Node</code>，即便发生碰撞，都碰撞到一个桶的概率那就更是少之又少了，所以链表长度很少有机会能到 8 ，如果链表长度到 8 了，那说明当前 <code>HashMap</code>中的元素数量已经非常大了，那这时候用红黑树来提高性能是可取的。而反过来，如果 <code>HashMap</code>总的元素很少，即便用红黑树对性能的提升也不大，况且红黑树对空间的使用要比链表大很多。</p>
<h2 id="get-方法">get 方法</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">T</span> <span class="n">value</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span></span></code></pre></div><p>例如通过上面的语句通过 key 获取 value 值，是我们最常用到的方法了。</p>
<p><img src="https://hexo.moonkite.cn/blog/640-20230607152049455-20230607152100936.jpeg" alt=""></p>
<p>看图理解，当调用 <code>get</code>方法后，第一步还是要确定索引位置，也就是我们所说的桶的位置，方法和 <code>put</code>方法时一样，都是先使用 <code>hash</code>这个<strong>扰动函数</strong>确定 hash 值，然后用 <code>(n-1) &amp; hash</code>获取索引。这不废话吗，当然得和 <code>put</code>的时候一样了，不一样还怎么找到正确的位置。</p>
<p>确定桶的位置后，会出现三种情况：</p>
<p>**单节点类型：**也就是这个桶内只有一个键值对，这也在 <code>HashMap</code>中存在最多的类型，只要不发生哈希碰撞都是这种类型。其实 <code>HashMap</code>最理想的情况就是这样，全都是这种类型就完美了。</p>
<p>**链表类型：**如果发现 get 的 key 所在的是一个链表结构，就需要遍历链表，知道找到 key 相等的 Node。</p>
<p>**红黑树类型：**当链表长度超过 8 就转变成红黑树，如果发现找到的桶是一颗红黑树，就使用红黑树专有的快速查找法查找。</p>
<p>另外，<code>Map.containsKey</code>方法其实用的就是 <code>get</code>方法。</p>
<h2 id="remove-方法">remove 方法</h2>
<p><code>remove</code>与<code>put</code>、<code>get</code>方法类似，都是先求出 key 的 hash 值，然后 <code>(n-1) &amp; hash</code>获取索引位置，之后根据节点的类型采取不同的措施。</p>
<p>**单节点类型：**直接将当前桶元素替换为被删除 node.next ，其实就是 null。</p>
<p><strong>链表类型：</strong> 如果是链表类型，就将被删除 node 的前一个节点的 next 属性设置为 node.next。</p>
<p>**红黑树类型：**如果是一棵红黑树，就调用红黑树节点删除法，这里，如果节点数在 2~6之间，就将树结构简化为链表结构。</p>
<h2 id="非线程安全">非线程安全</h2>
<p><code>HashMap</code>没有做并发控制，如果想在多线程高并发环境下使用，请用 <code>ConcurrentHashMap</code>。同一时刻如果有多个线程同时执行 put 操作，如果计算出来的索引（桶）位置是相同的，那会造成前一个 key 被后一个 key 覆盖。</p>
<p>比如下图线程 A 和 线程 B 同时执行 put 操作，很巧的是计算出的索引都是 2，而此时，线程A 和 线程B都判断出索引为 2 的桶是空的，然后就是插入值了，线程A先 put 进去了 key1 = 1的键值对，但是，紧接着线程B 又 put 进去了 key2 = 2，线程A 表示痛哭流涕，白忙活一场。最后索引为2的桶内的值是 key2=2，也就是线程A的存进去的值被覆盖了。</p>
<p><img src="https://hexo.moonkite.cn/blog/640-20230607152049455-20230607152100936-20230607152114731.jpeg" alt=""></p>
<h2 id="总结">总结</h2>
<p>前面没说，<code>HashMap</code>搞的这么复杂不是白搞的，它的最大优点就是快，尤其是 <code>get</code>数据，是 O(1)级别的，直接定位索引位置。</p>
<p><code>HashMap</code>不是单纯的数组结构，当发生哈希碰撞时，会采用拉链法生成链表，当链表大于 8 的时候会转换成红黑树，红黑树可以很大程度上提高性能。</p>
<p><code>HashMap</code>容量必须是 2 的 n 次方，这样设计是为了保证寻找索引的散列计算更加均匀，计算索引的公式为 <code>(n - 1) &amp; hash</code>。</p>
<p><code>HashMap</code>在键值对数量达到扩容阈值「<code>容量 x 负载因子</code>」的时候进行扩容，每次扩容为之前的两倍。扩容的过程中会对单节点类型元素进行重新计算索引位置，如果是红黑树节点则使用 <code>split</code>方法重新考量，是否将红黑树变为链表。</p>
]]></content:encoded></item><item><title>有趣的条漫版 HashMap，25岁大爷都能看懂</title><link>https://moonkite.cn/category/java/HashMap%E6%BC%AB%E7%94%BB%E7%89%88/</link><pubDate>Sat, 20 Jun 2020 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/java/HashMap%E6%BC%AB%E7%94%BB%E7%89%88/</guid><description>因为写文章的过程中画了不少的图，所以，我想，能不能用长图的形式展现一次呢，结果图片熬夜做了半天，最后出来的效果不是很好，哎，审美缺失吧。之后</description><content:encoded><![CDATA[<p>因为写文章的过程中画了不少的图，所以，我想，能不能用长图的形式展现一次呢，结果图片熬夜做了半天，最后出来的效果不是很好，哎，审美缺失吧。之后会有详细的文字源码解析版放出，敬请各位看官关注。</p>
<p>在 Java 中，最常用的数据类型是 8 中基本类型以及他们的包装类型以及字符串类型，其次应该就是 ArrayList和HashMap了吧。HashMap存的是键值对类型的数据，其存储和获取的速度快、性能高，是非常好用的一个数据结构，每一个 Java 开发者都肯定用过它。</p>
<p>而且 HashMap的设计巧妙，其结构和原理也经常被拿去当做面试题。其中有很多巧妙的算法和设计，比如 Hash 算法、拉链法、红黑树设计等，值得每一个开发者借鉴学习。</p>
<p>先来看一下整个 Map家族的集成关系图，一看东西还不少，但其他的可能都没怎么用过，只有 HashMap 最熟悉。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfz54hdxodj30u00g6abd.jpg" alt=""></p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/22/172d9d701fa0c39f~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt=""></p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/22/172d9d8ba92ab33b~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt=""></p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/22/172d9d939cd9bc18~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt=""></p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/22/172d9d9527f00228~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt=""></p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/22/172d9d9780ad4abe~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt=""></p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/22/172d9d995b5ea90a~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt=""></p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/22/172d9d9c11b174fa~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt=""></p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/22/172d9d9f2f9c5ea5~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt=""></p>
]]></content:encoded></item><item><title>8000字长文让你彻底了解 Java 8 的 Lambda、函数式接口、Stream 用法和原理</title><link>https://moonkite.cn/category/java/Java-Stream/</link><pubDate>Wed, 10 Jun 2020 08:56:23 +0800</pubDate><guid>https://moonkite.cn/category/java/Java-Stream/</guid><description>就在今年 Java 25周岁了，可能比在座的各位中的一些少年年龄还大，但令人遗憾的是，竟然没有我大，不禁感叹，Java 还是太小了。（难道我会说是因为我</description><content:encoded><![CDATA[<p>就在今年 Java 25周岁了，可能比在座的各位中的一些少年年龄还大，但令人遗憾的是，竟然没有我大，不禁感叹，Java 还是太小了。（难道我会说是因为我老了？）</p>
<p><img src="https://hexo.moonkite.cn/blog/1729bd280f103deb~tplv-t2oaga2asx-image.image" alt=""></p>
<p>而就在上个月，Java 15 的试验版悄悄发布了，但是在 Java 界一直有个神秘现象，那就是「你发你发任你发，我的最爱 Java 8」.</p>
<p>据 Snyk 和 The Java Magazine 联合推出发布的 2020 JVM 生态调查报告显示，在所有的 Java 版本中，仍然有 64% 的开发者使用 Java 8。另外一些开发者可能已经开始用 Java 9、Java 11、Java 13 了，当然还有一些神仙开发者还在坚持使用 JDK 1.6 和 1.7。</p>
<p>尽管 Java 8 发布多年，使用者众多，可神奇的是竟然有很多同学没有用过 Java 8 的新特性，比如 <strong>Lambda</strong>表达式、比如<strong>方法引用</strong>，再比如今天要说的 <strong>Stream</strong>。其实 Stream 就是以 Lambda 和方法引用为基础，封装的简单易用、函数式风格的 API。</p>
<p>Java 8 是在 2014 年发布的，实话说，风筝我也是在 Java 8 发布后很长一段时间才用的 Stream，因为 Java 8 发布的时候我还在 C# 的世界中挣扎，而使用 Lambda 表达式却很早了，因为 Python 中用 Lambda 很方便，没错，我写 Python 的时间要比 Java 的时间还长。</p>
<p><img src="https://hexo.moonkite.cn/blog/1729bd280f725e46~tplv-t2oaga2asx-image.image" alt="img"></p>
<p>要讲 Stream ，那就不得不先说一下它的左膀右臂 Lambda 和方法引用，你用的 Stream API 其实就是函数式的编程风格，其中的「函数」就是方法引用，「式」就是 Lambda 表达式。</p>
<p><img src="https://hexo.moonkite.cn/blog/1729bd28103cd64e~tplv-t2oaga2asx-image.image" alt="img"></p>
<h2 id="lambda-表达式">Lambda 表达式</h2>
<blockquote>
<p>Lambda 表达式是一个<a href="https://baike.baidu.com/item/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/4337265">匿名函数</a>，Lambda表达式基于数学中的<a href="https://baike.baidu.com/item/%CE%BB%E6%BC%94%E7%AE%97">λ演算</a>得名，直接对应于其中的lambda抽象，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包。</p>
</blockquote>
<p>在 Java 中，Lambda 表达式的格式是像下面这样</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 无参数，无返回值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">()</span> <span class="o">-&gt;</span> <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;Lambda&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">// 有参数，有返回值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span> <span class="o">}</span>
</span></span></code></pre></div><p>其等价于</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;Lambda&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="kt">int</span> <span class="nf">plus</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">  	<span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>最常见的一个例子就是新建线程，有时候为了省事，会用下面的方法创建并启动一个线程，这是匿名内部类的写法，<code>new Thread</code>需要一个 implements 自<code>Runnable</code>类型的对象实例作为参数，比较好的方式是创建一个新类，这个类 <code>implements Runnable</code>，然后 new 出这个新类的实例作为参数传给 Thread。而匿名内部类不用找对象接收，直接当做参数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="k">new</span> <span class="n">Runnable</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;快速新建并启动一个线程&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}).</span><span class="na">run</span><span class="o">();</span>
</span></span></code></pre></div><p>但是这样写是不是感觉看上去很乱、很土，而这时候，换上 Lambda 表达式就是另外一种感觉了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>
</span></span><span class="line"><span class="cl">    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;快速新建并启动一个线程&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}).</span><span class="na">run</span><span class="o">();</span>
</span></span></code></pre></div><p>怎么样，这样一改，瞬间感觉清新脱俗了不少，简洁优雅了不少。</p>
<p>Lambda 表达式简化了匿名内部类的形式，可以达到同样的效果，但是 Lambda 要优雅的多。虽然最终达到的目的是一样的，但其实内部的实现原理却不相同。</p>
<p>匿名内部类在编译之后会创建一个新的匿名内部类出来，而 Lambda 是调用 JVM <code>invokedynamic</code>指令实现的，并不会产生新类。</p>
<h2 id="方法引用">方法引用</h2>
<p>方法引用的出现，使得我们可以将一个方法赋给一个变量或者作为参数传递给另外一个方法。<code>::</code>双冒号作为方法引用的符号，比如下面这两行语句，引用 <code>Integer</code>类的 <code>parseInt</code>方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Function</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">::</span><span class="n">parseInt</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Integer</span> <span class="n">i</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="s">&#34;10&#34;</span><span class="o">);</span>
</span></span></code></pre></div><p>或者下面这两行，引用 <code>Integer</code>类的 <code>compare</code>方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">comparator</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">::</span><span class="n">compare</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">comparator</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span><span class="mi">10</span><span class="o">);</span>
</span></span></code></pre></div><p>再比如，下面这两行代码，同样是引用 <code>Integer</code>类的 <code>compare</code>方法，但是返回类型却不一样，但却都能正常执行，并正确返回。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">IntBinaryOperator</span> <span class="n">intBinaryOperator</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">::</span><span class="n">compare</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">intBinaryOperator</span><span class="o">.</span><span class="na">applyAsInt</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span><span class="mi">100</span><span class="o">);</span>
</span></span></code></pre></div><p>相信有的同学看到这里恐怕是下面这个状态，完全不可理喻吗，也太随便了吧，返回给谁都能接盘。</p>
<p><img src="https://hexo.moonkite.cn/blog/1729bd28113e1081~tplv-t2oaga2asx-image.image" alt="img"></p>
<p>先别激动，来来来，现在咱们就来解惑，解除蒙圈脸。</p>
<p><strong>Q：什么样的方法可以被引用？</strong></p>
<p>A：这么说吧，任何你有办法访问到的方法都可以被引用。</p>
<p><strong>Q：返回值到底是什么类型？</strong></p>
<p>A：这就问到点儿上了，上面又是 <code>Function</code>、又是<code>Comparator</code>、又是 <code>IntBinaryOperator</code>的，看上去好像没有规律，其实不然。</p>
<p>返回的类型是 Java 8 专门定义的函数式接口，这类接口用 <code>@FunctionalInterface</code> 注解。</p>
<p>比如 <code>Function</code>这个函数式接口的定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@FunctionalInterface</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">R</span> <span class="nf">apply</span><span class="o">(</span><span class="n">T</span> <span class="n">t</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>还有很关键的一点，你的引用方法的参数个数、类型，返回值类型要和函数式接口中的方法声明一一对应才行。</p>
<p>比如 <code>Integer.parseInt</code>方法定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">parseInt</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">NumberFormatException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">parseInt</span><span class="o">(</span><span class="n">s</span><span class="o">,</span><span class="mi">10</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>首先<code>parseInt</code>方法的参数个数是 1 个，而 <code>Function</code>中的 <code>apply</code>方法参数个数也是 1 个，参数个数对应上了，再来，<code>apply</code>方法的参数类型和返回类型是泛型类型，所以肯定能和 <code>parseInt</code>方法对应上。</p>
<p>这样一来，就可以正确的接收<code>Integer::parseInt</code>的方法引用，并可以调用<code>Funciton</code>的<code>apply</code>方法，这时候，调用到的其实就是对应的 <code>Integer.parseInt</code>方法了。</p>
<p>用这套标准套到 <code>Integer::compare</code>方法上，就不难理解为什么即可以用 <code>Comparator&lt;Integer&gt;</code>接收，又可以用 <code>IntBinaryOperator</code>接收了，而且调用它们各自的方法都能正确的返回结果。</p>
<p><code>Integer.compare</code>方法定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">)</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="o">((</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="o">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>返回值类型 <code>int</code>，两个参数，并且参数类型都是 <code>int</code>。</p>
<p>然后来看<code>Comparator</code>和<code>IntBinaryOperator</code>它们两个的函数式接口定义和其中对应的方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@FunctionalInterface</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">T</span> <span class="n">o1</span><span class="o">,</span> <span class="n">T</span> <span class="n">o2</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@FunctionalInterface</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">IntBinaryOperator</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">applyAsInt</span><span class="o">(</span><span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>对不对，都能正确的匹配上，所以前面示例中用这两个函数式接口都能正常接收。其实不止这两个，只要是在某个函数式接口中声明了这样的方法：两个参数，参数类型是 <code>int</code>或者泛型，并且返回值是 <code>int</code>或者泛型的，都可以完美接收。</p>
<p>JDK 中定义了很多函数式接口，主要在 <code>java.util.function</code>包下，还有 <code>java.util.Comparator</code> 专门用作定制比较器。另外，前面说的 <code>Runnable</code>也是一个函数式接口。</p>
<p><img src="https://hexo.moonkite.cn/blog/1729bd28111998c3~tplv-t2oaga2asx-image.image" alt="functionInterface 引用"></p>
<h2 id="自己动手实现一个例子">自己动手实现一个例子</h2>
<p><strong>1. 定义一个函数式接口，并添加一个方法</strong></p>
<p>定义了名称为 KiteFunction 的函数式接口，使用 <code>@FunctionalInterface</code>注解，然后声明了具有两个参数的方法 <code>run</code>，都是泛型类型，返回结果也是泛型。</p>
<p>还有一点很重要，函数式接口中只能声明一个可被实现的方法，你不能声明了一个 <code>run</code>方法，又声明一个 <code>start</code>方法，到时候编译器就不知道用哪个接收了。而用<code>default</code> 关键字修饰的方法则没有影响。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@FunctionalInterface</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">KiteFunction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">R</span><span class="o">,</span> <span class="n">S</span><span class="o">&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 定义一个双参数的方法
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param t
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param s
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @return
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="n">R</span> <span class="nf">run</span><span class="o">(</span><span class="n">T</span> <span class="n">t</span><span class="o">,</span><span class="n">S</span> <span class="n">s</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><strong>2. 定义一个与 KiteFunction 中 run 方法对应的方法</strong></p>
<p>在 FunctionTest 类中定义了方法 <code>DateFormat</code>，一个将 <code>LocalDateTime</code>类型格式化为字符串类型的方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FunctionTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">DateFormat</span><span class="o">(</span><span class="n">LocalDateTime</span> <span class="n">dateTime</span><span class="o">,</span> <span class="n">String</span> <span class="n">partten</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">DateTimeFormatter</span> <span class="n">dateTimeFormatter</span> <span class="o">=</span> <span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">ofPattern</span><span class="o">(</span><span class="n">partten</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">dateTime</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">dateTimeFormatter</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><strong>3.用方法引用的方式调用</strong></p>
<p>正常情况下我们直接使用 <code>FunctionTest.DateFormat()</code>就可以了。</p>
<p>而用函数式方式，是这样的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">KiteFunction</span><span class="o">&lt;</span><span class="n">LocalDateTime</span><span class="o">,</span><span class="n">String</span><span class="o">,</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">functionDateFormat</span> <span class="o">=</span> <span class="n">FunctionTest</span><span class="o">::</span><span class="n">DateFormat</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="n">String</span> <span class="n">dateString</span> <span class="o">=</span> <span class="n">functionDateFormat</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="n">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">(),</span><span class="s">&#34;yyyy-MM-dd HH:mm:ss&#34;</span><span class="o">);</span>
</span></span></code></pre></div><p>而其实我可以不专门在外面定义 <code>DateFormat</code>这个方法，而是像下面这样，使用匿名内部类。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    <span class="n">String</span> <span class="n">dateString</span> <span class="o">=</span> <span class="k">new</span> <span class="n">KiteFunction</span><span class="o">&lt;</span><span class="n">LocalDateTime</span><span class="o">,</span> <span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">String</span> <span class="nf">run</span><span class="o">(</span><span class="n">LocalDateTime</span> <span class="n">localDateTime</span><span class="o">,</span> <span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">DateTimeFormatter</span> <span class="n">dateTimeFormatter</span> <span class="o">=</span> <span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">ofPattern</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">localDateTime</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">dateTimeFormatter</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}.</span><span class="na">run</span><span class="o">(</span><span class="n">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">(),</span> <span class="s">&#34;yyyy-MM-dd HH:mm:ss&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dateString</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>前面第一个 <code>Runnable</code>的例子也提到了，这样的匿名内部类可以用 Lambda 表达式的形式简写，简写后的代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">KiteFunction</span><span class="o">&lt;</span><span class="n">LocalDateTime</span><span class="o">,</span> <span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">functionDateFormat</span> <span class="o">=</span> <span class="o">(</span><span class="n">LocalDateTime</span> <span class="n">dateTime</span><span class="o">,</span> <span class="n">String</span> <span class="n">partten</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">DateTimeFormatter</span> <span class="n">dateTimeFormatter</span> <span class="o">=</span> <span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">ofPattern</span><span class="o">(</span><span class="n">partten</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">dateTime</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">dateTimeFormatter</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">};</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">dateString</span> <span class="o">=</span> <span class="n">functionDateFormat</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="n">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">(),</span> <span class="s">&#34;yyyy-MM-dd HH:mm:ss&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dateString</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>使用（LocalDateTime dateTime, String partten) -&gt; { } 这样的 Lambda 表达式直接返回方法引用。</p>
<h2 id="stream-api">Stream API</h2>
<p>为了说一下 Stream API 的使用，可以说是大费周章啊，知其然，也要知其所以然吗，追求技术的态度和姿势要正确。</p>
<p>当然 Stream 也不只是 Lambda 表达式就厉害了，真正厉害的还是它的功能，Stream 是 Java 8 中集合数据处理的利器，很多本来复杂、需要写很多代码的方法，比如过滤、分组等操作，往往使用 Stream 就可以在一行代码搞定，当然也因为 Stream 都是链式操作，一行代码可能会调用好几个方法。</p>
<p><code>Collection</code>接口提供了 <code>stream()</code>方法，让我们可以在一个集合方便的使用 Stream API 来进行各种操作。值得注意的是，我们执行的任何操作都不会对源集合造成影响，你可以同时在一个集合上提取出多个 stream 进行操作。</p>
<p>我们看 Stream 接口的定义，继承自 <code>BaseStream</code>，几乎所有的接口声明都是接收方法引用类型的参数，比如 <code>filter</code>方法，接收了一个 <code>Predicate</code>类型的参数，它就是一个函数式接口，常用来作为条件比较、筛选、过滤用，<code>JPA</code>中也使用了这个函数式接口用来做查询条件拼接。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">BaseStream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">filter</span><span class="o">(</span><span class="n">Predicate</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">predicate</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">// 其他接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>  
</span></span></code></pre></div><p>下面就来看看 Stream 常用 API。</p>
<p><img src="https://hexo.moonkite.cn/blog/1729bd28128ee5d8~tplv-t2oaga2asx-image.image" alt="img"></p>
<h3 id="of">of</h3>
<p>可接收一个泛型对象或可变成泛型集合，构造一个 Stream 对象。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">createStream</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">stringStream</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span><span class="s">&#34;b&#34;</span><span class="o">,</span><span class="s">&#34;c&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="empty">empty</h3>
<p>创建一个空的  Stream 对象。</p>
<h3 id="concat">concat</h3>
<p>连接两个 Stream ，不改变其中任何一个 Steam 对象，返回一个新的 Stream 对象。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">concatStream</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span><span class="s">&#34;b&#34;</span><span class="o">,</span><span class="s">&#34;c&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;d&#34;</span><span class="o">,</span><span class="s">&#34;e&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">concat</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="max">max</h3>
<p>一般用于求数字集合中的最大值，或者按实体中数字类型的属性比较，拥有最大值的那个实体。它接收一个 <code>Comparator&lt;T&gt;</code>，上面也举到这个例子了，它是一个函数式接口类型，专门用作定义两个对象之间的比较，例如下面这个方法使用了 <code>Integer::compareTo</code>这个方法引用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">max</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">Stream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">integerStream</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">100</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Integer</span> <span class="n">max</span> <span class="o">=</span> <span class="n">integerStream</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">Integer</span><span class="o">::</span><span class="n">compareTo</span><span class="o">).</span><span class="na">get</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">max</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>当然，我们也可以自己定制一个 <code>Comparator</code>，顺便复习一下 Lambda 表达式形式的方法引用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">max</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">Stream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">integerStream</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">100</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">comparator</span> <span class="o">=</span>  <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">intValue</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">.</span><span class="na">intValue</span><span class="o">())</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="o">((</span><span class="n">x</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">y</span><span class="o">))</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Integer</span> <span class="n">max</span> <span class="o">=</span> <span class="n">integerStream</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">comparator</span><span class="o">).</span><span class="na">get</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">max</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="min">min</h3>
<p>与 max 用法一样，只不过是求最小值。</p>
<h3 id="findfirst">findFirst</h3>
<p>获取 Stream 中的第一个元素。</p>
<h3 id="findany">findAny</h3>
<p>获取 Stream 中的某个元素，如果是串行情况下，一般都会返回第一个元素，并行情况下就不一定了。</p>
<h3 id="count">count</h3>
<p>返回元素个数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="s">&#34;b&#34;</span><span class="o">,</span> <span class="s">&#34;c&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">long</span> <span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">count</span><span class="o">();</span>
</span></span></code></pre></div><h3 id="peek">peek</h3>
<p>建立一个通道，在这个通道中对 Stream 的每个元素执行对应的操作，对应 <code>Consumer&lt;T&gt;</code>的函数式接口，这是一个消费者函数式接口，顾名思义，它是用来消费 Stream 元素的，比如下面这个方法，把每个元素转换成对应的大写字母并输出。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">peek</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="s">&#34;b&#34;</span><span class="o">,</span> <span class="s">&#34;c&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">peek</span><span class="o">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">toUpperCase</span><span class="o">())).</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="foreach">forEach</h3>
<p>和 peek 方法类似，都接收一个消费者函数式接口，可以对每个元素进行对应的操作，但是和 peek 不同的是，<code>forEach</code> 执行之后，这个 Stream 就真的被消费掉了，之后这个 Stream 流就没有了，不可以再对它进行后续操作了，而 <code>peek</code>操作完之后，还是一个可操作的 Stream 对象。</p>
<p>正好借着这个说一下，我们在使用 Stream API 的时候，都是一串链式操作，这是因为很多方法，比如接下来要说到的 <code>filter</code>方法等，返回值还是这个 Stream 类型的，也就是被当前方法处理过的 Stream 对象，所以 Stream API 仍然可以使用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">forEach</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="s">&#34;b&#34;</span><span class="o">,</span> <span class="s">&#34;c&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">toUpperCase</span><span class="o">()));</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="foreachordered">forEachOrdered</h3>
<p>功能与 <code>forEach</code>是一样的，不同的是，<code>forEachOrdered</code>是有顺序保证的，也就是对 Stream 中元素按插入时的顺序进行消费。为什么这么说呢，当开启并行的时候，<code>forEach</code>和 <code>forEachOrdered</code>的效果就不一样了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="s">&#34;b&#34;</span><span class="o">,</span> <span class="s">&#34;c&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="o">.</span><span class="na">parallel</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">toUpperCase</span><span class="o">()));</span>
</span></span></code></pre></div><p>当使用上面的代码时，输出的结果可能是 B、A、C 或者 A、C、B或者A、B、C，而使用下面的代码，则每次都是 A、 B、C</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="s">&#34;b&#34;</span><span class="o">,</span> <span class="s">&#34;c&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="o">.</span><span class="na">parallel</span><span class="o">().</span><span class="na">forEachOrdered</span><span class="o">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">toUpperCase</span><span class="o">()));</span>
</span></span></code></pre></div><h3 id="limit">limit</h3>
<p>获取前 n 条数据，类似于 MySQL 的limit，只不过只能接收一个参数，就是数据条数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">limit</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="s">&#34;b&#34;</span><span class="o">,</span> <span class="s">&#34;c&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">.</span><span class="na">limit</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">));</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>上述代码打印的结果是 a、b。</p>
<h3 id="skip">skip</h3>
<p>跳过前 n 条数据，例如下面代码，返回结果是 c。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">skip</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="s">&#34;b&#34;</span><span class="o">,</span> <span class="s">&#34;c&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">.</span><span class="na">skip</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">));</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="distinct">distinct</h3>
<p>元素去重，例如下面方法返回元素是 a、b、c，将重复的 b 只保留了一个。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">distinct</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="s">&#34;b&#34;</span><span class="o">,</span> <span class="s">&#34;c&#34;</span><span class="o">,</span><span class="s">&#34;b&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">.</span><span class="na">distinct</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">));</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="sorted">sorted</h3>
<p>有两个重载，一个无参数，另外一个有个 <code>Comparator</code>类型的参数。</p>
<p>无参类型的按照自然顺序进行排序，只适合比较单纯的元素，比如数字、字母等。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sorted</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="s">&#34;c&#34;</span><span class="o">,</span> <span class="s">&#34;b&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">.</span><span class="na">sorted</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">));</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>有参数的需要自定义排序规则，例如下面这个方法，按照第二个字母的大小顺序排序，最后输出的结果是 a1、b3、c6。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sortedWithComparator</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;a1&#34;</span><span class="o">,</span> <span class="s">&#34;c6&#34;</span><span class="o">,</span> <span class="s">&#34;b3&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">.</span><span class="na">sorted</span><span class="o">((</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)-&gt;</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">1</span><span class="o">))&gt;</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">y</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">1</span><span class="o">))?</span><span class="mi">1</span><span class="o">:-</span><span class="mi">1</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">));</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><strong>为了更好的说明接下来的几个 API ，我模拟了几条项目中经常用到的类似数据，10条用户信息。</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="nf">getUserData</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Random</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Random</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">List</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">users</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">User</span> <span class="n">user</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">user</span><span class="o">.</span><span class="na">setUserId</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">user</span><span class="o">.</span><span class="na">setUserName</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&#34;古时的风筝 %s 号&#34;</span><span class="o">,</span> <span class="n">i</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">user</span><span class="o">.</span><span class="na">setAge</span><span class="o">(</span><span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">100</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">user</span><span class="o">.</span><span class="na">setGender</span><span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">user</span><span class="o">.</span><span class="na">setPhone</span><span class="o">(</span><span class="s">&#34;18812021111&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">user</span><span class="o">.</span><span class="na">setAddress</span><span class="o">(</span><span class="s">&#34;无&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">users</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">users</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="filter">filter</h3>
<p>用于条件筛选过滤，筛选出符合条件的数据。例如下面这个方法，筛选出性别为 0，年龄大于 50 的记录。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">filter</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">List</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">users</span> <span class="o">=</span> <span class="n">getUserData</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">Stream</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="na">stream</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">stream</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">user</span> <span class="o">-&gt;</span> <span class="n">user</span><span class="o">.</span><span class="na">getGender</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">user</span><span class="o">.</span><span class="na">getAge</span><span class="o">()&gt;</span><span class="mi">50</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     *等同于下面这种形式 匿名内部类
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl"><span class="c1">//    stream.filter(new Predicate&lt;User&gt;() {
</span></span></span><span class="line"><span class="cl"><span class="c1">//        @Override
</span></span></span><span class="line"><span class="cl"><span class="c1">//        public boolean test(User user) {
</span></span></span><span class="line"><span class="cl"><span class="c1">//            return user.getGender().equals(0) &amp;&amp; user.getAge()&gt;50;
</span></span></span><span class="line"><span class="cl"><span class="c1">//        }
</span></span></span><span class="line"><span class="cl"><span class="c1">//    }).forEach(e-&gt;System.out.println(e));
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></div><h3 id="map">map</h3>
<p><code>map</code>方法的接口方法声明如下，接受一个 <code>Function</code>函数式接口，把它翻译成映射最合适了，通过原始数据元素，映射出新的类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="nf">map</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">mapper</span><span class="o">);</span>
</span></span></code></pre></div><p>而 <code>Function</code>的声明是这样的，观察 <code>apply</code>方法，接受一个 T 型参数，返回一个 R 型参数。用于将一个类型转换成另外一个类型正合适，这也是 <code>map</code>的初衷所在，用于改变当前元素的类型，例如将 <code>Integer</code> 转为 <code>String</code>类型，将 DAO 实体类型，转换为 DTO 实例类型。</p>
<p>当然了，T 和 R 的类型也可以一样，这样的话，就和 <code>peek</code>方法没什么不同了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@FunctionalInterface</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * Applies this function to the given argument.
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param t the function argument
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @return the function result
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="n">R</span> <span class="nf">apply</span><span class="o">(</span><span class="n">T</span> <span class="n">t</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>例如下面这个方法，应该是业务系统的常用需求，将 User 转换为 API 输出的数据格式。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">map</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">List</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">users</span> <span class="o">=</span> <span class="n">getUserData</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">Stream</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="na">stream</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">List</span><span class="o">&lt;</span><span class="n">UserDto</span><span class="o">&gt;</span> <span class="n">userDtos</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">user</span> <span class="o">-&gt;</span> <span class="n">dao2Dto</span><span class="o">(</span><span class="n">user</span><span class="o">)).</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="n">UserDto</span> <span class="nf">dao2Dto</span><span class="o">(</span><span class="n">User</span> <span class="n">user</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">UserDto</span> <span class="n">dto</span> <span class="o">=</span> <span class="k">new</span> <span class="n">UserDto</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">BeanUtils</span><span class="o">.</span><span class="na">copyProperties</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">dto</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//其他额外处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">dto</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="maptoint">mapToInt</h3>
<p>将元素转换成 int 类型，在 <code>map</code>方法的基础上进行封装。</p>
<h3 id="maptolong">mapToLong</h3>
<p>将元素转换成 Long 类型，在 <code>map</code>方法的基础上进行封装。</p>
<h3 id="maptodouble">mapToDouble</h3>
<p>将元素转换成 Double 类型，在 <code>map</code>方法的基础上进行封装。</p>
<h3 id="flatmap">flatMap</h3>
<p>这是用在一些比较特别的场景下，当你的 Stream 是以下这几种结构的时候，需要用到 <code>flatMap</code>方法，用于将原有二维结构扁平化。</p>
<ol>
<li><code>Stream&lt;String[]&gt;</code></li>
<li><code>Stream&lt;Set&lt;String&gt;&gt;</code></li>
<li><code>Stream&lt;List&lt;String&gt;&gt;</code></li>
</ol>
<p>以上这三类结构，通过 <code>flatMap</code>方法，可以将结果转化为 <code>Stream&lt;String&gt;</code>这种形式，方便之后的其他操作。</p>
<p>比如下面这个方法，将<code>List&lt;List&lt;User&gt;&gt;</code>扁平处理，然后再使用 <code>map</code>或其他方法进行操作。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">flatMap</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">List</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">users</span> <span class="o">=</span> <span class="n">getUserData</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">List</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">users1</span> <span class="o">=</span> <span class="n">getUserData</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;&gt;</span> <span class="n">userList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">    <span class="n">userList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">users</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">userList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">users1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Stream</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;&gt;</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">userList</span><span class="o">.</span><span class="na">stream</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">List</span><span class="o">&lt;</span><span class="n">UserDto</span><span class="o">&gt;</span> <span class="n">userDtos</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="n">subUserList</span><span class="o">-&gt;</span><span class="n">subUserList</span><span class="o">.</span><span class="na">stream</span><span class="o">()).</span><span class="na">map</span><span class="o">(</span><span class="n">user</span> <span class="o">-&gt;</span> <span class="n">dao2Dto</span><span class="o">(</span><span class="n">user</span><span class="o">)).</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="flatmaptoint">flatMapToInt</h3>
<p>用法参考 <code>flatMap</code>，将元素扁平为 int 类型，在 <code>flatMap</code>方法的基础上进行封装。</p>
<h3 id="flatmaptolong">flatMapToLong</h3>
<p>用法参考 <code>flatMap</code>，将元素扁平为 Long 类型，在 <code>flatMap</code>方法的基础上进行封装。</p>
<h3 id="flatmaptodouble">flatMapToDouble</h3>
<p>用法参考 <code>flatMap</code>，将元素扁平为 Double 类型，在 <code>flatMap</code>方法的基础上进行封装。</p>
<h3 id="collection">collection</h3>
<p>在进行了一系列操作之后，我们最终的结果大多数时候并不是为了获取 Stream 类型的数据，而是要把结果变为 List、Map 这样的常用数据结构，而 <code>collection</code>就是为了实现这个目的。</p>
<p>就拿 map 方法的那个例子说明，将对象类型进行转换后，最终我们需要的结果集是一个 <code>List&lt;UserDto &gt;</code>类型的，使用 <code>collect</code>方法将 Stream 转换为我们需要的类型。</p>
<p>下面是 <code>collect</code>接口方法的定义：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="o">&lt;</span><span class="n">R</span><span class="o">,</span> <span class="n">A</span><span class="o">&gt;</span> <span class="n">R</span> <span class="nf">collect</span><span class="o">(</span><span class="n">Collector</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">,</span> <span class="n">A</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">collector</span><span class="o">);</span>
</span></span></code></pre></div><p>下面这个例子演示了将一个简单的 Integer Stream 过滤出大于 7 的值，然后转换成 <code>List&lt;Integer&gt;</code>集合，用的是 <code>Collectors.toList()</code>这个收集器。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">collect</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">Stream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">integerStream</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">33</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">integerStream</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">intValue</span><span class="o">()&gt;</span><span class="mi">7</span><span class="o">).</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>很多同学表示看不太懂这个 <code>Collector</code>是怎么一个意思，来，我们看下面这段代码，这是 <code>collect</code>的另一个重载方法，你可以理解为它的参数是按顺序执行的，这样就清楚了，这就是个 ArrayList 从创建到调用 <code>addAll</code>方法的一个过程。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">collect</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">Stream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">integerStream</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">33</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">integerStream</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">intValue</span><span class="o">()&gt;</span><span class="mi">7</span><span class="o">).</span><span class="na">collect</span><span class="o">(</span><span class="n">ArrayList</span><span class="o">::</span><span class="k">new</span><span class="o">,</span> <span class="n">ArrayList</span><span class="o">::</span><span class="n">add</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">ArrayList</span><span class="o">::</span><span class="n">addAll</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>我们在自定义 <code>Collector</code>的时候其实也是这个逻辑，不过我们根本不用自定义， <code>Collectors</code>已经为我们提供了很多拿来即用的收集器。比如我们经常用到<code>Collectors.toList()</code>、<code>Collectors.toSet()</code>、<code>Collectors.toMap()</code>。另外还有比如<code>Collectors.groupingBy()</code>用来分组，比如下面这个例子，按照 userId 字段分组，返回以 userId 为key，List<!-- raw HTML omitted --> 为value 的 Map，或者返回每个 key 的个数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 返回 userId:List&lt;User&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">List</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span><span class="n">User</span><span class="o">::</span><span class="n">getUserId</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 返回 userId:每组个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span><span class="n">User</span><span class="o">::</span><span class="n">getUserId</span><span class="o">,</span><span class="n">Collectors</span><span class="o">.</span><span class="na">counting</span><span class="o">()));</span>
</span></span></code></pre></div><h3 id="toarray">toArray</h3>
<p><code>collection</code>是返回列表、map 等，<code>toArray</code>是返回数组，有两个重载，一个空参数，返回的是 <code>Object[]</code>。</p>
<p>另一个接收一个 <code>IntFunction&lt;R&gt;</code>类型参数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@FunctionalInterface</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">IntFunction</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * Applies this function to the given argument.
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param value the function argument
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @return the function result
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="n">R</span> <span class="nf">apply</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>比如像下面这样使用，参数是 <code>User[]::new</code>也就是new 一个 User 数组，长度为最后的 Stream 长度。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">toArray</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">List</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">users</span> <span class="o">=</span> <span class="n">getUserData</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">Stream</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="na">stream</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">User</span><span class="o">[]</span> <span class="n">userArray</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">user</span> <span class="o">-&gt;</span> <span class="n">user</span><span class="o">.</span><span class="na">getGender</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">user</span><span class="o">.</span><span class="na">getAge</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="o">).</span><span class="na">toArray</span><span class="o">(</span><span class="n">User</span><span class="o">[]::</span><span class="k">new</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="reduce">reduce</h3>
<p>它的作用是每次计算的时候都用到上一次的计算结果，比如求和操作，前两个数的和加上第三个数的和，再加上第四个数，一直加到最后一个数位置，最后返回结果，就是 <code>reduce</code>的工作过程。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">reduce</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">Stream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">integerStream</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">33</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Integer</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">integerStream</span><span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="mi">0</span><span class="o">,(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)-&gt;</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sum</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>另外 <code>Collectors</code>好多方法都用到了 <code>reduce</code>，比如 <code>groupingBy</code>、<code>minBy</code>、<code>maxBy</code>等等。</p>
<h2 id="并行-stream">并行 Stream</h2>
<p>Stream 本质上来说就是用来做数据处理的，为了加快处理速度，Stream API 提供了并行处理 Stream 的方式。通过 <code>users.parallelStream()</code>或者<code>users.stream().parallel()</code> 的方式来创建并行 Stream 对象，支持的 API 和普通 Stream 几乎是一致的。</p>
<p>并行 Stream 默认使用 <code>ForkJoinPool</code>线程池，当然也支持自定义，不过一般情况下没有必要。ForkJoin 框架的分治策略与并行流处理正好契合。</p>
<p>虽然并行这个词听上去很厉害，但并不是所有情况使用并行流都是正确的，很多时候完全没这个必要。</p>
<p><strong>什么情况下使用或不应使用并行流操作呢？</strong></p>
<ol>
<li>必须在多核 CPU 下才使用并行 Stream，听上去好像是废话。</li>
<li>在数据量不大的情况下使用普通串行 Stream 就可以了，使用并行 Stream 对性能影响不大。</li>
<li>CPU 密集型计算适合使用并行 Stream，而 IO 密集型使用并行 Stream 反而会更慢。</li>
<li>虽然计算是并行的可能很快，但最后大多数时候还是要使用 <code>collect</code>合并的，如果合并代价很大，也不适合用并行 Stream。</li>
<li>有些操作，比如 limit、 findFirst、forEachOrdered 等依赖于元素顺序的操作，都不适合用并行 Stream。</li>
</ol>
<h2 id="最后">最后</h2>
<p>Java 25 周岁了，有多少同学跟我一样在用 Java 8，还有多少同学再用更早的版本，请说出你的故事。</p>
]]></content:encoded></item></channel></rss>