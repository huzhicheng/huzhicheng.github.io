<!doctype html><html lang=zh-cn itemscope itemtype=http://schema.org/WebPage><head><meta name=generator content="Hugo 0.121.0"><meta charset=utf-8><title>4. 30张图说清楚 TCP 协议 · 古时的风筝</title>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=description content="大家好，我是风筝 轻解计算机网络已有高清 PDF 版本可以离线阅读了，全册 65 页，如果有需要离线版的高清 PDF 可以直接下载。 今天，继续来网管的自我修养之TC"><meta name=360-site-verification content="e75339f1cfcde17f66f71aaf8b6983e9"><meta name=keywords content="Hugo,theme,编程,Java,ChatGPT,程序员,开发"><link rel=canonical href=https://www.moonkite.cn/category/network/30%E5%BC%A0%E5%9B%BE%E8%AF%B4%E6%B8%85%E6%A5%9A-TCP-%E5%8D%8F%E8%AE%AE/><link rel=icon href=https://www.moonkite.cn/images/photo.png><link rel=stylesheet href=https://cdn.staticfile.org/twitter-bootstrap/4.1.3/css/bootstrap.min.css><link rel=stylesheet href=https://www.moonkite.cn/css/den.css><link href=https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.7.0/style.min.css rel=stylesheet><link href=https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.7.0/lxgwwenkaigbscreen.min.css rel=stylesheet><link href=https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/lxgwwenkaiscreen.min.css rel=stylesheet><meta property="og:title" content="4. 30张图说清楚 TCP 协议"><meta property="og:description" content="大家好，我是风筝 轻解计算机网络已有高清 PDF 版本可以离线阅读了，全册 65 页，如果有需要离线版的高清 PDF 可以直接下载。 今天，继续来网管的自我修养之TC"><meta property="og:type" content="article"><meta property="og:url" content="https://www.moonkite.cn/category/network/30%E5%BC%A0%E5%9B%BE%E8%AF%B4%E6%B8%85%E6%A5%9A-TCP-%E5%8D%8F%E8%AE%AE/"><meta property="article:section" content="category"><meta property="article:published_time" content="2023-02-28T08:56:23+08:00"><meta property="article:modified_time" content="2023-02-28T08:56:23+08:00"><meta itemprop=name content="4. 30张图说清楚 TCP 协议"><meta itemprop=description content="大家好，我是风筝 轻解计算机网络已有高清 PDF 版本可以离线阅读了，全册 65 页，如果有需要离线版的高清 PDF 可以直接下载。 今天，继续来网管的自我修养之TC"><meta itemprop=datePublished content="2023-02-28T08:56:23+08:00"><meta itemprop=dateModified content="2023-02-28T08:56:23+08:00"><meta itemprop=wordCount content="9806"><meta itemprop=keywords content="Java,JDK,计算机网络基础,TCP,TCP协议,"><meta name=twitter:card content="summary"><meta name=twitter:title content="4. 30张图说清楚 TCP 协议"><meta name=twitter:description content="大家好，我是风筝 轻解计算机网络已有高清 PDF 版本可以离线阅读了，全册 65 页，如果有需要离线版的高清 PDF 可以直接下载。 今天，继续来网管的自我修养之TC"></head><body><div class=header-container style=background:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2)),url(https://hexo.moonkite.cn/blog/background.png);background-position:top;background-size:cover><div class=container><nav class="header-nav navbar navbar-expand-md navbar-dark light-dark"><div class="header-logo navbar-brand"><a class=float-left href=https://www.moonkite.cn/></a></div><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarNav aria-controls=navbarNav aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="nav-menu collapse navbar-collapse" id=navbarNav><ul class=navbar-nav><li class=nav-item><a href=https://www.moonkite.cn/ class=nav-link><i class="fas fad fa-h-square"></i>主页</a></li><li class=nav-item><a href=https://www.moonkite.cn/category/notes class=nav-link><i class='fas fa-yin-yang'></i>生活随笔</a></li><li class=nav-item><a href=javascript:void(0) class=nav-link><i class='fas fa-laptop-code'></i>技术文章</a><div class=sub-dropdown-menu><a class=sub-nav-link href=https://www.moonkite.cn/category/java><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 48 48"><path fill="#f44336" d="M23.65 24.898c-.998-1.609-1.722-2.943-2.725-5.455C19.229 15.2 31.24 11.366 26.37 3.999c2.111 5.089-7.577 8.235-8.477 12.473-.823 3.898 5.752 8.426 5.757 8.426z"/><path fill="#f44336" d="M23.878 17.27c-.192 2.516 2.229 3.857 2.299 5.695.056 1.496-1.447 2.743-1.447 2.743s2.728-.536 3.579-2.818c.945-2.534-1.834-4.269-1.548-6.298.267-1.938 6.031-5.543 6.031-5.543S24.311 11.611 23.878 17.27z"/><g><path fill="#1565c0" d="M32.084 25.055c1.754-.394 3.233.723 3.233 2.01.0 2.901-4.021 5.643-4.021 5.643s6.225-.742 6.225-5.505c0-3.15-3.057-3.937-5.437-2.148zm-2.955 2.34s1.941-1.383 2.458-1.902c-4.763 1.011-15.638 1.147-15.638.269.0-.809 3.507-1.638 3.507-1.638s-7.773-.112-7.773 2.181C11.683 28.695 21.858 28.866 29.129 27.395z"/><path fill="#1565c0" d="M27.935 29.571c-4.509 1.499-12.814 1.02-10.354-.993-1.198.0-2.974.963-2.974 1.889.0 1.857 8.982 3.291 15.63.572l-2.302-1.468z"/><path fill="#1565c0" d="M18.686 32.739c-1.636.0-2.695 1.054-2.695 1.822.0 2.391 9.76 2.632 13.627.205l-2.458-1.632C24.271 34.404 17.014 34.579 18.686 32.739z"/><path fill="#1565c0" d="M36.281 36.632c0-.936-1.055-1.377-1.433-1.588 2.228 5.373-22.317 4.956-22.317 1.784.0-.721 1.807-1.427 3.477-1.093l-1.42-.839C11.26 34.374 9 35.837 9 37.017 9 42.52 36.281 42.255 36.281 36.632z"/><path fill="#1565c0" d="M39 38.604c-4.146 4.095-14.659 5.587-25.231 3.057C24.341 46.164 38.95 43.628 39 38.604z"/></g></svg>&nbsp;可爱的 Java</a>
<a class=sub-nav-link href=https://www.moonkite.cn/category/SpringCloud><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 48 48"><path fill="#8bc34a" d="M43.982 23.635c.069-4.261-.891-9.328-2.891-15.273L39.523 3.7l-2.13 4.433c-.114.237-.244.469-.38.698C33.514 5.827 28.974 4 24 4 12.954 4 4 12.954 4 24s8.954 20 20 20 20-8.954 20-20C44 23.877 43.984 23.758 43.982 23.635z"/><path fill="#fff" d="M39.385 32.558C36.262 36.86 30.734 37.091 25.531 37H18.75h-1.938c4.428-1.593 7.063-1.972 9.754-3.4 5.068-2.665 10.078-8.496 11.121-14.562-1.93 5.836-7.779 10.85-13.109 12.889-3.652 1.393-10.248 2.745-10.248 2.745l-.267-.145C9.573 32.268 9.437 22.214 17.6 18.968c3.574-1.423 6.993-.641 10.854-1.593 4.122-1.012 8.89-4.208 10.83-8.375C41.456 15.667 44.07 26.106 39.385 32.558zM15.668 38.445C15.386 38.795 14.955 39 14.505 39c-.823.0-1.495-.677-1.495-1.5s.677-1.5 1.495-1.5c.341.0.677.118.941.336C16.086 36.855 16.186 37.805 15.668 38.445z"/></svg>&nbsp; Spring Cloud 系列</a>
<a class=sub-nav-link href=https://www.moonkite.cn/category/other><img width=20 height=20 src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAADWElEQVR4nO2X30tTYRjH9xd4X2Dsol1EEtJdEFiSF10pldlVaVHEjiFFkKQVQeV0kfSTHdfW1pzKlpZtzXJuzp2pmzPFTdmUTdLJlEAvNKyB8MYzPG/visHZ2jxrnQc+8PCc85zz/e592XkfkUgIIYT4v2OoTVrtVFDTjILaYmgK8YqC2oproalzKZlwKqga3sXTSeFuZts9ykWcNOXnbITcTj67IRQcG1rlE5/dECK3GXcjxC8ADwqMuxGfBMeGVklNaRmZ83z0L3+ZR3ywMBfInJHQqGl07esKAmYjK6hnJoph64Ar/KsOOXmNK6HOTszKtD9uJitGQGSRcQFDiqh1RHAd8nSMWMQSDJgRjLAhrIgxta3lDvaiRlMpxvKvbi3BCNfI+xVRehdRIT2DIUWdejeH65BzMWKd1KO6jqOYLrEE46fp7Bm5bgki0Q0bhhS1t3UM1yHnYuS1XY5Oy0swD8USjPNmQ2aNfO6WO0KjphHgbrc9XNjsirGwdeAY7Vpl65CT15LRYb4VltLHYyzKAwcxgw3Xwr5BQ9D9ll53dz9d+msjfNLfWoO6GstR7/0zCXXBCJMPKxLMl3kkmC9GQsTf706znK3vyKLdhtznL2ISPm5TaqQdro8DeTJxm4EHKDZRGQfy308HtdvAcJY1I3BsII8RpAgwwB41IE9mBAwgR0EcyMlrRcTxB45DgpFUV+RbSIMxuq4kXRFyFl+3VuTeiqBtQYCDqUxqhOyJPCsTjDDCitB5urW8zS2oTSzBxNS7MB3tpeiC4kicO8azCQLJnkB9Me750Xs44b4CmQcjc4SzZwSGHXL42Xy0B6NTHMIDUp36RIJAsmeS2od7vuuKE+4TEUMbDHGZMLLBNrlUV/3u9sYRwH7vkq/nZFmUJaotwfRoK5bk6qoooNRUh9kegOyZkpUtsT3zuvKE+6qev4myKF899nkNTeMTJuWsu6spTBjZ4GzESUv7+R6qmCQ4aeoTZyPDLy4XMTS1xrdo5k/WmDbpflEq4XpJ7XbS1O0+bYvnve7JLNCnkXkZWmrYCfo0Mi9+r7bFA1pAkyjd0Ov1EZVKhQDI034Q3++1mM39H8xmBECeEZV8vNdmtRptAwMojtVqzIjKHH6vEEIIIcrt+AnU4LBcH67z1wAAAABJRU5ErkJggg=="> &nbsp; 杂七杂八</a></div></li><li class=nav-item><a href=https://www.moonkite.cn/category/network class=nav-link><i class="fas fa-network-wired"></i>轻解计算机网络</a></li><li class=nav-item><a href=https://www.moonkite.cn/category/product class=nav-link><i class="fas fab fa-medapps"></i>我的产品</a></li></ul></div></nav></div><div class="container header-wrapper"><div class=row><div class=col-lg-12><div class=header-content><h1 class=header-title>4. 30张图说清楚 TCP 协议</h1><p class=header-date>作者：
风筝 /
2023-02-28<div class=header-underline></div><div class=clearfix></div><p class="float-right header-tags"><i class="fas fa-tags" aria-hidden=true></i>
<a href=https://www.moonkite.cn/tag/Java/>Java</a>,
<a href=https://www.moonkite.cn/tag/JDK/>JDK</a>,
<a href=https://www.moonkite.cn/tag/TCP/>TCP</a>,
<a href=https://www.moonkite.cn/tag/TCP%E5%8D%8F%E8%AE%AE/>TCP协议</a>,
<a href=https://www.moonkite.cn/tag/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/>计算机网络基础</a></p></div></div></div></div></div><main><div class="container content"><article><p><strong>大家好，我是风筝</strong></p><p>轻解计算机网络已有高清 PDF 版本可以离线阅读了，全册 65 页，如果有需要离线版的高清 PDF 可以<a href="https://pan.baidu.com/s/10LH_5afGftayMo8Q1Io_gA?pwd=f8hp">直接下载</a>。</p><p>今天，继续来网管的自我修养之TCP协议，这可是除 IP 协议外另一个核心协议了。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/092fee6e14544be69784b5ba353e13a8~tplv-k3u1fbpfcp-zoom-1.image alt></p><p>TCP 协议是网络传输中至关重要的一个协议，它位于传输层。向上支持 FTP、TELNET、SMTP、DNS、HTTP等常见的应用层协议，向下要与网络层的 IP 协议相互配合，实现可靠的网络传输。</p><h2 id=分层网络模型>分层网络模型</h2><h3 id=osi-7层模型>OSI 7层模型</h3><p>为了让全世界的计算机有效的互联起来，国际标准化组织提出了一种概念化的网络模型，<strong>开放式系统互联模型</strong>（Open System Interconnection Model），简称 OSI 模型。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbf440d1c638424589f64de544d1ae98~tplv-k3u1fbpfcp-zoom-1.image alt></p><p>自上而下依次为应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。</p><h4 id=应用层>应用层</h4><p>应用层提供为应用软件而设计的接口，以设置与另一应用软件之间的通信。例如：HTTP、HTTPS、FTP、Telnet、SSH、SMTP、POP3等。</p><h4 id=表示层>表示层</h4><p>表示层把数据转换为能与接收者的系统格式兼容并适合传输的格式。</p><h4 id=会话层>会话层</h4><p>会话层负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接。</p><h4 id=传输层>传输层</h4><p>传输层把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:传输控制协议（TCP）等。</p><h4 id=网络层>网络层</h4><p>网络层决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组。网络表头包含了网络资料。例如:互联网协议（IP）等。</p><h4 id=数据链路层>数据链路层</h4><p>数据链路层负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成信息框。数据链表头（DLH）是包含了物理地址和错误侦测及改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串。例如以太网、无线局域网（Wi-Fi）和通用分组无线服务（GPRS）等。</p><p>分为两个子层：逻辑链路控制（logical link control，LLC）子层和介质访问控制（Media access control，MAC）子层。</p><h4 id=物理层>物理层</h4><p>物理层在局部局域网上传送数据帧，它负责管理电脑通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡等。</p><p>OSI 模型是国际标准模型，是指导互联网模型的概念标准。而在实际的设计实现过程中，最后形成了 TCP/IP 4层模型结构。</p><h3 id=tcpip-4层模型>TCP/IP 4层模型</h3><p>TCP/IP 模型实际上并不单单指 TCP 和 IP，实际上这一个协议簇，还包含了其他的一些协议，比如 UDP、ICMP、IGMP 等。</p><p>TCP/IP 模型是事实上的标准模型，在 7 层模型的基础上将最上面三层的应用层、表示层、会话层统一为应用层，将数据链路层和物理层统一为链路层或者叫网络接口层。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01a6141765d644fc9ab4ac508314b1d2~tplv-k3u1fbpfcp-zoom-1.image alt></p><p>实际应用中还是以 4 层模型为准，毕竟这才是事实上的标准。还有一种 5 层模型的说法，实际上就是把 7 层中的应用层、表示层、会话层合并为应用层，其他层保持不变。</p><h2 id=数据的加工和传输过程>数据的加工和传输过程</h2><p>TCP/IP 模型每个层都有各自的功能和分工，当有用户数据想要发送给另一台设备的时候，数据自上而下，从应用层向链路层传递有一个复杂的过程。</p><p>以 Telnet 为例，Telnet 在传输层是使用 TCP 协议的。</p><p>数据从应用层进入，到达传输层，添加上 TCP首部，将数据加工成 TCP 段，称为 Segment。这是为了保证数据的可靠性。</p><p>接着数据到达网络层，在网络层使用 IP 协议，被添加上 IP 首部，将数据加工成 IP数据报，称为 datagram 。经过网络层 IP 协议的加工，指定目标地址和 MAC 地址，保证数据准确的发送到目标机器。</p><p>接着数据到达链路层，添加上以太网头部，将数据加工成以太网帧，称为 frame，包含了网卡等硬件相关的数据。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3757de1327d74768a5d53ffd6e0bb714~tplv-k3u1fbpfcp-zoom-1.image alt></p><p>无论是 Telnet 还是 HTTP，都至少涉及到两台设备才能称之为网络互连，那发送方有一个数据自应用层向底层链路层的加工过程，对应的，在数据接收方，有一个数据从链路层向应用层解析的过程。这中间可能经历了漫长的传输介质，比如光纤，还可能有若干个中间设备，比如路由器、交换机等等。要保证数据在这么复杂的网络环境中可靠、准确的发送到目标机器，就是靠的 TCP、IP协议精巧的设计。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b29d33d0ff9459787c97a46d3810eea~tplv-k3u1fbpfcp-zoom-1.image alt></p><h2 id=tcp-协议>TCP 协议</h2><p>TCP，全称是 Transmission Control Protocol，传输控制协议。 是一种面向连接的、可靠的字节流服务协议，正因为它要保证可靠性，所以比起 UDP 协议要复杂的多，正是由于这种复杂性，导致它的性能比 UDP 差。</p><p>TCP 是 TCP/IP 模型中的传输层一个最核心的协议，不仅如此，在整个 4 层模型中，它都是核心的协议，要不然模型怎么会叫做 TCP/IP 模型呢。</p><p>它向下使用网络层的 IP 协议，向上为 FTP、SMTP、POP3、SSH、Telnet、HTTP 等应用层协议提供支持。其他的还有我们常用的 Redis 的 RESP 协议、MongoDB的网络协议，以及我们编程中用到的 Socket，都是 TCP 协议在背后提供支持的。</p><p>网络协议是通信计算机双方必须共同遵从的一组约定。如怎么样建立连接、怎么样互相识别等。只有遵守这个约定，计算机之间才能相互通信交流。它的三要素是：语法、语义、时序。</p><ol><li><p>语法：即数据与控制信息的结构或格式；</p></li><li><p>语义：即需要发出何种控制信息，完成何种动作以及做出何种响应；</p></li><li><p>时序（同步）：即事件实现顺序的详细说明。</p></li></ol><h3 id=tcp-协议格式>TCP 协议格式</h3><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46ba0f81fc144b1cbd79664d22e9bbd4~tplv-k3u1fbpfcp-zoom-1.image alt></p><p>TCP首部 + 用户数据被称为TCP段，其中 TCP 首部就是这里要主要研究的 TCP 协议的核心所在，用户数据部分是 TCP 段的负载。</p><p>TCP 段的大小也是有限制的，最大是 1460 字节，这是怎么算出的呢？</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/612ca8c8fc9942aea7d35a301f73ef1a~tplv-k3u1fbpfcp-zoom-1.image alt></p><p>最终由网卡发出去的数据包叫做以太网帧，以太网帧由以太网首部和负载构成。</p><p>以太网帧的负载就是一个 IP 数据报，IP数据报由IP首部和负载构成。</p><p>IP数据报的负载就是一个 TCP段。所以，TCP段所能搭载的最大数据量可以这样计算出来：</p><p>$TCP段搭载的数据大小 = 以太网帧大小-以太网首部-IP首部-TCP首部$</p><p>以太网帧的大小是固定的 1522字节，而IP首部和TCP首部的大小是不固定的，但是最少会各占20字节，所以最后算下来 TCP段搭载的数据大小最多为 1460字节。</p><p>$TCP段搭载的数据大小（最多1460） = 以太网帧大小（1522字节）-以太网首部（22字节）-IP首部（最少20字节）-TCP首部（最少20字节）$</p><p>下图是TCP协议的示意图，如果不算「可选项」部分的话，共占用 <code>32bit x 5 = 160bit</code>，也就是20个字节。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db1759d24ccc4660a29135fcfe81c990~tplv-k3u1fbpfcp-zoom-1.image alt></p><h4 id=源端口和目标端口>源端口和目标端口</h4><p>源端口和目标端口分别占用 2个字节，共占用 4 字节，分别记录数据发送端的端口号和数据接收端的端口号，这两个标记和 IP 协议中记录的发送端 IP 和接收端 IP组合起来，便可确定一个唯一的 TCP 连接。</p><h4 id=序号>序号</h4><p>由于TCP段的大小有限制，当要传输的数据量大于这个限制的时候，就要对数据进行分段，一段一段的发送，既然发送方要分段，那接收方就要对分段进行重组，才能还原回原始数据。在重组的过程中，要保证各段间的先后顺序，序号正是起到保证重组顺序的作用。</p><p>序号占用 4 字节，32 位，它的范围是 [0,$2^{32}$]​。TCP是字节流服务，会对每一个发送的字节进行编号。在建立连接的时候，系统会给定一个 ISN(初始序号)，然后这个设备在当前连接中发送的第一个字节的序号就是 ISN+1，假设 ISN 初始为0，那第一个字节的序号就是 1。</p><p>举个例子，假设ISN为0，发送端第一次发送 100 字节的数据包，那这第一个 TCP段的序号就是1，下次再发送 100字节的数据包，那这第二个 TCP段的序号就是 101。</p><p>这样一来，最大可以一直标记 $2^{32}$个字节，也就是 4个G的数据。当达到最大值后，又会从 0 开始标记。</p><p>序号只有在下面两种情况下才有用：</p><ol><li>数据字段至少包含一个字节。</li><li>是一个 SYN 段，或者是 FIN 段，或者是 RST 段。</li></ol><h4 id=确认序号>确认序号</h4><p>当数据发送出去，接收方收到之后，会回复一个确认序号回复给发送方，这个确认序号表示接收方希望下次接收的序号。例如发送了序号为501的，长度为100的TCP段，那接收方收到后要回复 601的确认序号，表示【0-600】的字节已经接收，下次希望收到第 601个字节以后的数据。</p><p>为了提高效率，并不是每次接收到TCP段都会马上回复给发送方，而是采用累积确认的方式，即每传送多个连续 TCP 段，可以只对最后一个 TCP 段进行确认。</p><p>确认序号只有在 ACK 标志位被设置的时候才有效。</p><h4 id=首部长度>首部长度</h4><p>之所以需要首部长度，是因为可选项的大小是不固定的，如果没有可选项的话，那首部长度就是 20字节。这个标示部分占 4 bit，单位是4字节，4bit 可表示的最大值是 15，一个单位表示的长度是4字节，所以首部长度最大可以是 <code>15 x 4字节</code>，也就是 60 字节。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdcdaf4143b24fec988ce4d8f27ed48c~tplv-k3u1fbpfcp-zoom-1.image alt></p><h4 id=保留>保留</h4><p>顾名思义，是保留位，占用6个比特位，目前的值为 0。</p><h4 id=6个标志位>6个标志位</h4><p>协议中有 6 个比特标记位，可以理解为 TCP 段的类型。</p><p><strong>URG</strong></p><p>1个比特位，当被设置为1时，表明紧急指针字段有效，该报文段有紧急数据，应尽快发送。</p><p><strong>ACK</strong></p><p>当 ACK 设置为1时，确认号才有效，连接建立后，所有的报文段ACK都为 1。</p><p><strong>PSH</strong></p><p>当 PSH 设置为1时，接收方应该尽快将这个报文段交给应用层，而不再等待整个缓存填满再交付。</p><p><strong>RST</strong></p><p>当 RST 为1时，表示连接出现严重错误，必须重新建立连接。</p><p><strong>SYN</strong></p><p>在建立连接时用到。</p><p>当SYN=1,ACK=0时，表明这是一个连接请求报文段。</p><p>当SYN=1,ACK=1时，表明对方同意连接。</p><p><strong>FIN</strong></p><p>用来释放一个连接窗口。当FIN=1时，表明此报文段的发送方不再发送数据，请求释放单向连接。TCP断开连接用到。</p><h4 id=窗口大小>窗口大小</h4><p>大小为2个字节，表示发送方自己的接收窗口，用来告诉对方允许发送的数据量，最大为65535字节。</p><h4 id=检验和>检验和</h4><p>校验和是必需的，是一个端到端的校验和，由发送端计算，然后由接收端验证。其目的是为了发现TCP首部和数据在发送端到接收端之间发生的任何改动。如果接收方检测到校验和有差错，则TCP段会被直接丢弃。</p><h4 id=紧急指针>紧急指针</h4><p>占2字节，当URG=1时，紧急指针表示本报文段中的紧急数据的字节数，表示从这个 TCP段的序号开始的后的若干个字节是紧急数据，之后的就是普通数据。</p><p>假设此TCP段的序号为101，紧急指针为30，那就表示从 101开始，直到 131，【101，131】这个区间内为紧急数据。</p><h2 id=三次握手和四次挥手>三次握手和四次挥手</h2><p>数据要完成传输，必须要建立连接。由于建立TCP连接的过程需要来回3次，所以，将这个过程形象的叫做三次握手。</p><p>而连接断开的时候要经过四次数据传输，所以也被称为4次挥手。</p><p>啥都别说了，先看图吧。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66c23a7215f64e3098e1e8bd3b0fdeb4~tplv-k3u1fbpfcp-zoom-1.image alt></p><h3 id=三次握手建立连接>三次握手，建立连接</h3><p>结合上面的图来看更清楚。</p><p>先说三次握手吧，连接是后续数据传输的基础。就像我们打电话一样，必须保证我和对方都拿着电话在听，才能保证我们两个说的话对方能够接收到。</p><p>三次握手大概就是这个意思：</p><p>张三想跟李四聊聊天，于是张三拨通了李四的手机号，李四听到铃声响起，按了接听按钮。</p><p>张三：Hi，李四，是你吗？唠两块钱的呀！</p><p>李四：Hi，张三，是我，可以唠。</p><p>张三：好，我确定是你了，接下来我要开始和你唠了。</p><p>看上去多少有点儿死板，但程序上确实就是这样的。</p><p><strong>1、第一次握手</strong></p><p>首先客户端发起连接请求，向服务器发送 TCP段，段中包含了目标端口和本机端口，设置 SYN 标志位为1，序号为 x，也就是初始序号 ISN，如果是第一个连接，很有可能就是 0。当然，此时服务器对应的端口要处于监听状态。此时，客户端进入 SYNC_SENT 状态，等待服务器的确认。</p><p><strong>2、第二次握手</strong></p><p>服务端收到客户端发来的 SYN 段，对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)，这就是确认序号。同时，服务端还要发送 SYN 请求信息，将SYN位置为1，Sequence Number为 y（服务端的TCP段序号）。服务器端将上述所有信息放到一个TCP段（即SYN+ACK段）中，一并发送给客户端，此时服务器进入SYN_RECV状态。</p><p><strong>3、第三次握手</strong></p><p>客户端接收到服务端发来的 SYN+ACK 段后，发送一个 ACK 给服务端，将 Acknowledgment Number 设置为 y+1。此时客户端进入 ESTABLISHED（已连接）状态，服务端接收到此 TCP段，也将进入 ESTABLISHED 状态，也就标志着三次握手结束，连接成功建立。</p><p>三次握手完成之后，连接就建立了，之后就可以愉快的传输数据了。</p><h3 id=四次挥手江湖再见>四次挥手，江湖再见</h3><p>一旦有了感情（连接），再分手就难了，难到需要四次挥手。不像 UDP 那样，没有连接，说分就分。</p><p>当客户端和服务端双方发送数据完成后，一般会由客户端主动发起断开连接的请求，当然，也有少数情况是服务端主动发起。</p><p>以最常见的客户端发起断开连接为例，说一下四次挥手的过程。</p><p><strong>1、第一次挥手</strong></p><p>客户端设置序号（Sequence Number）和确认序号（Acknowledgment Number），发送一个 FIN 段给服务器。这时，客户端进入 FIN_WAIT_1状态，意味着客户端没有数据要发送了。</p><p><strong>2、第二次挥手</strong></p><p>服务端收到 FIN 报文段，向客户端发送一个 ACK 段，客户端进入 FIN_WAIT_2 状态。表示服务端已同意连接关闭请求。</p><p><strong>3、第三次挥手</strong></p><p>服务端向客户端发送 FIN 段，请求关闭连接，同时服务端进入 LAST_ACK 状态。</p><p><strong>4、第四次挥手</strong></p><p>客户端收到服务端发来的 FIN 段，向服务端发送 ACK 段，之后客户端进入TIME_WAIT状态。服务端收到客户端的ACK 段以后，就关闭连接。</p><p>上面就是由客户端主动发起关闭连接的过程。</p><h3 id=半关闭状态>半关闭状态</h3><p>TCP 是一个全双工的字节流服务，意思就是说两个端点都可以同时发送和接收消息。</p><p>正常情况下需要四次挥手才能完成连接的完全断开。但是有一种情况是这样的，只主动关闭自己到对方的连接，但是对方还是可以给自己发送数据。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ede4d31feef84a349b3ace62397e57ef~tplv-k3u1fbpfcp-zoom-1.image alt></p><h2 id=用-wireshark-抓住-tcp>用 WireShark 抓住 TCP</h2><p>Wireshark 是帮助我们分析网络请求的利器，建议每个同学都装一个。我们先用 Wireshark 抓取一个完整的连接建立、发送数据、断开连接的过程。</p><p>我这儿只简单的介绍一下操作流程。</p><p>1、首先打开 Wireshark，在欢迎界面会列出当前机器上的所有网口、虚机网口等可以抓取的部件。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a22fe57fc81246078177720ef00d7c1d~tplv-k3u1fbpfcp-zoom-1.image alt></p><p>2、我接下来要用 Telnet 连接一个外网服务器，所以我选择第一个 WI-FI:en0，这样 Wireshark 就会捕获我连接的 wifi 上的网络传输。</p><p>3、我只想要抓一下最简单的 TCP 连接、发数据、断开的过程，所以要做一下抓取过滤。Wireshark 中的过滤器可以实现这样的需求。在下图红框部分可以选了一个过滤器。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/646367ea6257466097d6f046439ed33d~tplv-k3u1fbpfcp-zoom-1.image alt></p><p>4、因为当前没有直接可用的符合要求的过滤器，所以，需要自己写一个。点击前面的绿色书签图标，然后在弹出窗口中点击加号添加一个。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de380b7952d74b75898f5e25dd8a7911~tplv-k3u1fbpfcp-zoom-1.image alt></p><p>内容如下，语法就不解释了，一看就知道。</p><pre tabindex=0><code>tcp and host 你的远程ip
</code></pre><p>5、选择好刚添加的这个过滤器，双击wifi这个 interface 进入就开始捕获了。</p><p>6、我用 telnet 连接这台服务器的 6379 端口 <code>telnet ip 6379</code>，因为这台服务器上装着 redis，可以模拟发数据。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad7c53277bee41658421eaf7e0b678cf~tplv-k3u1fbpfcp-zoom-1.image alt></p><p>在控制台中连接到 6379 端口成功，然后在 Wireshark 上马上捕获到了。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d17fef11da044e8b869d38054cdc2db1~tplv-k3u1fbpfcp-zoom-1.image alt></p><p>这就是三次握手的过程。</p><p>7、然后直接关掉终端，这样会自动触发断开连接，并且发送最少的数据，方便我们观察。整个的过程都被 Wireshark 完整的捕捉到了。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/581209c810bf47c4bb361c54b03328bc~tplv-k3u1fbpfcp-zoom-1.image alt></p><p>第一部分是连接建立的三次握手，第二部分是发了长度为 1个字节的数据，第三步是客户端主动发起的断开连接的四次挥手过程。</p><h3 id=wireshark-简单介绍>Wireshark 简单介绍</h3><p>有图先看图</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a82bfc84c42f43f7984bf78adc51af0b~tplv-k3u1fbpfcp-zoom-1.image alt></p><p><strong>概览信息</strong></p><p>也就是图中最上面的红色框部分。这一次的连接建立和中断一共产生了来回 8 次的请求，每次请求会在列表上列出时间、源端IP、目的端IP、以太网帧长度以及概览信息，包括数据传输方向（源端口->目标端口）、标记情况、序号、确认序号、窗口大小等等。</p><p><strong>以太网帧</strong></p><p>在每次请求信息中，还包括以太网帧，因为信息最终都会通过帧的形式发送出去。</p><p><strong>IP数据报</strong></p><p>还有 IP 数据报内容，其中包含了源端 IP 和 目的端 IP 等信息。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d30d2f0d678c49338b87a18c25750874~tplv-k3u1fbpfcp-zoom-1.image alt></p><p><strong>TCP段</strong></p><p>TCP 段当然是重点了，其中包含了 TCP 协议中的所有信息，包括端口号、</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7b932c9224046fc9667ed0fb77752aa~tplv-k3u1fbpfcp-zoom-1.image alt></p><h2 id=粘包半包>粘包、半包</h2><p><strong>MTU是什么</strong></p><p>MTU 全称是最大传输单元，一个在网络上传输的包不能无限大，MTU 一般是对于链路层而言的，拿以太网来说，在链路层允许发送的最大的以太网帧的数据部分就是 1500字节。注意是以太网帧的<strong>数据部分</strong>，再加上以太网帧的头部，会大于1500字节。</p><p>通过 <code>ifconfig</code>（windows 系统是 ipconfig）可查看本机各个网络接口（网卡）的MTU 大小。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4f60ecef46943948c6e4bfcc4a65c4f~tplv-k3u1fbpfcp-zoom-1.image alt></p><p><strong>MSS是什么</strong></p><p>MSS 指TCP最大报文长度，是TCP协议定义的一个选项，MSS选项用于在TCP连接建立时，收发双方协商通信时每一个报文段所能承载的最大数据长度。还是用以太网为例，MTU是 1500字节，减去TCP头（20字节）和IP头（20字节），就是MSS 1460字节。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6f3ebebe61f4a19bf2dd7fb2e7c92dc~tplv-k3u1fbpfcp-zoom-1.image alt></p><h3 id=粘包>粘包</h3><p>粘包就是将几个比较小的 TCP 包合并成一个包，这样就只发送一次就可以将多个小包发送出去。例如下面这样，一个TCP报文请求中，包含小包A、B、C，每一个小包原本都是一个TCP报文。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a718ab33ca1b43b29bb5bdf48b60639c~tplv-k3u1fbpfcp-zoom-1.image alt></p><p>为什么要粘包呢？一个一个发送不行吗？</p><p>其实是可以的，只不过在多数情况下来一个包马上就发送可能会造成网络拥塞，一个TCP 报文传输到链路层的时候，会加上TCP头和IP头，占用40字节，如果发送的数据内容很小，比如只有1个字节，为了这一字节的内容，要有40倍的额外的信息被传输，是不是有点浪费。</p><p>为了减少这种浪费，TCP 协议就做了一些优化，比如 Nagle 算法：</p><ul><li>Nagle 算法规定每次只有收到上一个包的确认（ACK）之后，才会发送下一个包，在这个时间段内正好将小的包粘到一起；</li><li>但是太多的包也不行，大小不能超过 MSS ，也就是前面刚说的 1460字节，太大了装不下；</li><li>如果没有那么多小包，也不能一直等着，有一个超时时间，大约是200ms，超过这个时间也要发送；</li></ul><p>由于现在的宽带和设备性能的提升，Nagle 算法其实可以关闭了，有些设备上默认就是关闭的，也可以在写 Socket 的代码的时候主动关闭掉，关闭之后呢，只要接收端处理能力够快，可以保证来一个包马上发送，对那些要求实时反馈的应用来说尤其重要。</p><p>那来一个包发一个包，是不是就不会有粘包的问题了？也不是，这就要看接收端的处理能力了，接收端会有一个接收缓冲区，来不及被应用程序处理的会暂时放到这里，如果应用程序处理能力较差，这里还是会出现粘包。</p><h3 id=拆包>拆包</h3><p>既然发生了粘包，就要把这些大包拆成小包。怎么拆分其实都是上层应用的事儿了，核心要点就是约定好分隔符。举个简单的例子，比如说将包A和包B用一个特殊字符 <code>$</code>分隔开，那应用在拆包的时候就要根据这个特殊字符进行分隔。当然了，真实情况要比这个复杂的多，如果你用过 Netty，就会发现 Netty 提供了多种处理粘包拆包的方式。</p><h3 id=什么是半包>什么是半包</h3><p>粘包是为了将多个小包变成一个大包，而半包是把超大包拆成小包。比如下图，假设包B是一个很大的包，已经超过了MSS 了，单单发送它自己都发不过去了，所以只能将它拆开，一部分一部分的发送。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6dd02633ce2940b5a4ac61555e9fe717~tplv-k3u1fbpfcp-zoom-1.image alt></p><p>半包就没那么复杂了，纯粹是因为单独的包太大，协议不支持这么大的包，只能拆开。</p><p>这样一部分一部分的包，到了接收端之后就要将其合并为一个整体，合并也比较简单，就是如果这个部分包没有开始或没有结束标志，就表示它不是完整的，需要给其找到对应的其他部分。</p><h2 id=滑动窗口>滑动窗口</h2><p><strong>接收方通告的窗口</strong>称为 offered window，意思就是说我这边可以接受的最大字节数为这么多。例如下图中的红框部分为 offered window， 大小为 6 字节，发送端最大一次只能发送 6 个字节，要不然接收方就没有能力接收了。</p><p><strong>可用窗口</strong> = offered window - 已经发送但未被确认的字节大小，这个值由发送方自己计算。前面说了三次握手，发送方发出去包，接收方接到后会反回一个 ACK，发出去但未收到ACK的数据也会占用窗口，表明接收方正在处理，所以，可用窗口的大小是 offered window 减去未收到 ACK 的大小。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7239584a23fb42d8918028aa919d8c00~tplv-k3u1fbpfcp-zoom-1.image alt></p><p>为什么叫滑动窗口呢，看上面的图，把一个个字节想象成排成一排的格子。</p><p><strong>首先看时刻1</strong>：红色格子的部分就是offered window，大小为6字节，后面10、11、12字节因为没在窗口内，所以不能发送。已发送但未被确认的也占用窗口大小，所以最终可用窗口就是 7、8、9这三个字节。</p><p>**再看时刻2：**刚才未被确认的 4、5、6字节收到了 ACK，所以1-6都变成了过去式，然后窗口覆盖到了7、8、9、10、11、12 这6个字节，对比时刻1和时刻2，给我们的感觉就是窗口（红色格子）向右滑动了，这就是所谓的滑动窗口了。</p><p>还有，窗口两个边沿的相对运动增加或减少了窗口的大小。</p><ul><li><p>当窗口左边沿向右边沿靠近为窗口合拢。这种现象发生在数据被发送和确认时，假设现在接收方处理数据的时间变长了，来不及快速处理，那接收方在下次ACK的时候返回的窗口大小可能就会变小。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42dd5a467e86426e9ab199f59cdd36e7~tplv-k3u1fbpfcp-zoom-1.image alt></p></li><li><p>当窗口右边沿向右移动时将允许发送更多的数据， 我们称之为窗口张开。 这种现象发 生在另一端的接收进程读取已经确认的数据并释放了 TCP的接收缓存时。</p></li></ul><h2 id=慢启动和拥塞避免算法>慢启动和拥塞避免算法</h2><p>在使用 TCP 传输的过程中，肯定是希望数据传送的越快越好，但是在实际使用场景中，由于发送端和接收端处理数据的速度不一致，或者由于中间路由器性能限制、带宽限制等原因，发送的速度越快，越有可能导致丢包的情况。比如一下子发送了10M的数据出来，但是中间路由器只能处理 5 M，很可能就会把一些包丢弃。</p><p>因而设计了慢启动和拥塞避免算法，这两个设计都是为了合理的匹配发端的发送速度与收端的处理速度。</p><h3 id=慢启动>慢启动</h3><p>在连接刚建立的时候，发送端也不知道应该按什么速度发比较合适，所以就采用了一种渐进式的方式，就是慢启动的方式。</p><p>前面说了 offered window 是接收端的，在发送端也有一个窗口，叫做拥塞窗口，记做 cwnd，拥塞窗口初始化为 1 ，表示 1个报文段，也就是允许发送1个报文段，之后每当每当收到接收端返回的 ACK 时，就将 cwnd 的值加1。第一次发送一个数据报，当收到 ACK 后，cwnd 变为2，然后下一次发送两个数据报，当收到这两个数据报的 ACK 时，cwnd 就变成 4 。以此类推，这个增长是呈指数级的。</p><p>但是，在这个过程中，也是有限制的，发送的数据报大小要在消息接收端返回的通告窗口大小和 cwnd 中取较小的那个值。假设一个报文大小为 1024 字节，当 cwnd 为2，通告窗口大小为 4096 字节时，那发送端你可以连着发送2个数据报，也就是取 cwnd 的值，当 cwnd 为8 时，通告窗口大小仍然为 4096 字节时，那发送端最多可连续发送 4 个数据报，也就是不能超过 4096 字节。</p><h3 id=拥塞避免>拥塞避免</h3><p>拥塞避免算法其实和慢启动是在一起使用的。在慢启动中除了有拥塞窗口外， 还有一个叫做启动门限（ssthresh）的参数。启动门限默认的是 65535 字节。</p><p>在慢启动中，cwnd 是呈指数级增长，但是这个增长速度太快了，所以，拥塞避免算法就是让这个增速减缓的方式。</p><p>当 cwnd &lt; ssthresh 的时候，就使用慢启动。</p><p>当 cwnd > ssthresh 的时候，就启动拥塞避免算法。</p><p>拥塞避免算法保证当 cwnd 超过限制之后，每次收到一个确认时将 cwnd 增加 1/cwnd。</p><p>当拥塞发生时（超时或收到重复确认），ssthresh 被设置为当前窗口大小的一半（cwnd和接收方通告窗口大小的最小值，但最少为 2个报文段）。</p><p><strong>用一张图来说明慢启动和拥塞避免算法</strong></p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e475ac6088a4775b86fd820a06ad5c9~tplv-k3u1fbpfcp-zoom-1.image alt></p><p>假定当 cwnd 为32个报文段时就会发生拥塞。于是设置 ssthresh 为1 6个报文段， 而 cwnd 为1个报文段。 在时刻 0发送了一个报文段， 并假定在时刻 1接收到它的 ACK，此时 cwnd 增加为2。接着发送了2个报文段，并假定在时刻 2接收到它们的 ACK，于是 cwnd 增加为4 （对每个 ACK 增加1次）。这种指数增加算法一直进行到在时刻 3和4之间收到8个A C K后 cwnd 等 于 ssthresh 时才停止，从该时刻起，cwnd 以线性方式增加，在每个往返时间内最多增加 1个报 文段。</p><p>正如我们在这个图中看到的那样， 术语“慢启动”并不完全正确。 它只是采用了比引起 拥塞更慢些的分组传输速率， 但在慢启动期间进入网络的分组数增加的速率仍然是在增加的。 只有在达到 ssthresh 拥塞避免算法起作用时，这种增加的速率才会慢下来。</p><h2 id=重传机制>重传机制</h2><p>什么情况下要重传，当发送端认为丢包了就要重传，有两种情况下发送端就认为丢包了，于是就会发起重传。</p><h3 id=超时重传>超时重传</h3><p>发送端在一段时间（超时时间）后没有收到发送端返回的 ACK ，就认为这个包丢了，这个超时时间并不是固定的。</p><p>这里面有两个概念，RTT 和 RTO。</p><ul><li><p>RTT（Round Trip Time）：往返时延，也就是数据包从发出去到收到对应 ACK 的时间。RTT 是针对连接的，每一个连接都有各自独立的 RTT。</p></li><li><p>RTO（Retransmission Time Out）：重传超时，也就是前面说的超时时间。</p></li></ul><h3 id=快速重传>快速重传</h3><p>接收端回复的 ACK 会带着包的序号，当接收端重复三次收到同一个序号的ACK时，就要重传这个包；</p><p>比如下面图中画的这样：</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d85f32a261443fe9c9c597d5a78d3b2~tplv-k3u1fbpfcp-zoom-1.image alt></p><p>1、seq=1的包发过去，接收端ACK=2，表示期望下次出现的序号为2，然后发送端就发了 seq=2的包，接收端接到后回复 ACK=3，表示期望下次收到序号为3的包，这是发送端第一次收到 ACK=3;</p><p>2、发送端继续发送 seq=3 的包，但是这个包可能传输的比较慢（比如路由选择的不好），接收端一直没收到；</p><p>3、发送端先不管，继续发送 seq=4 的包，接收端收到后，回复ACK，正常情况下应该是 ACK=5，但是序号为3的包还没收到，所以再次回复ACK=3，这是第二次收到ACK=3；</p><p>4、发送端继续不管，接着发送 seq=5的包，接收端收到后，回复ACK，正常情况下应该是 ACK=6，但是序号为3的包还没收到，所以再次回复ACK=3，这是第三次收到ACK=3；</p><p>到目前为止，已经收到三次 ACK=3了，然后发送端就重新发送 seq=3的包，这时候就当做这个包已经丢了。这就是快速重传。</p></article><div class=toc><h2>文章目录</h2><nav id=TableOfContents><ul><li><a href=#分层网络模型>分层网络模型</a><ul><li><a href=#osi-7层模型>OSI 7层模型</a></li><li><a href=#tcpip-4层模型>TCP/IP 4层模型</a></li></ul></li><li><a href=#数据的加工和传输过程>数据的加工和传输过程</a></li><li><a href=#tcp-协议>TCP 协议</a><ul><li><a href=#tcp-协议格式>TCP 协议格式</a></li></ul></li><li><a href=#三次握手和四次挥手>三次握手和四次挥手</a><ul><li><a href=#三次握手建立连接>三次握手，建立连接</a></li><li><a href=#四次挥手江湖再见>四次挥手，江湖再见</a></li><li><a href=#半关闭状态>半关闭状态</a></li></ul></li><li><a href=#用-wireshark-抓住-tcp>用 WireShark 抓住 TCP</a><ul><li><a href=#wireshark-简单介绍>Wireshark 简单介绍</a></li></ul></li><li><a href=#粘包半包>粘包、半包</a><ul><li><a href=#粘包>粘包</a></li><li><a href=#拆包>拆包</a></li><li><a href=#什么是半包>什么是半包</a></li></ul></li><li><a href=#滑动窗口>滑动窗口</a></li><li><a href=#慢启动和拥塞避免算法>慢启动和拥塞避免算法</a><ul><li><a href=#慢启动>慢启动</a></li><li><a href=#拥塞避免>拥塞避免</a></li></ul></li><li><a href=#重传机制>重传机制</a><ul><li><a href=#超时重传>超时重传</a></li><li><a href=#快速重传>快速重传</a></li></ul></li></ul></nav></div><script>window.addEventListener("scroll",function(){var e=document.querySelector(".toc"),t=window.pageYOffset||document.documentElement.scrollTop,n=window.innerWidth||document.documentElement.clientWidth;t<360?e.style.top=380-t+"px":e.style.top="20px"})</script><h4>相关文章</h4><dl class=row><dd class=col-md-9><a href=/category/network/%E9%87%8D%E5%AD%A6%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%95%A5%E6%9C%89%E5%B0%8F%E6%88%90%E7%BB%8F%E9%AA%8C%E5%85%A8%E9%83%A8%E5%88%86%E4%BA%AB%E5%87%BA%E6%9D%A5/>0. 重学了计算机网络，略有小成，经验全部分享出来</a></dd><dd class=col-md-9><a href=/category/network/%E5%AE%8F%E8%A7%82%E4%B8%8A%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B-%E5%9C%A8%E7%9B%B4%E5%8D%87%E9%A3%9E%E6%9C%BA%E4%B8%8A%E7%9C%8B%E7%BD%91%E7%BB%9C/>1. 宏观上理解网络模型-在直升飞机上看网络</a></dd><dd class=col-md-9><a href=/category/network/ARP%E5%8D%8F%E8%AE%AE%E7%BD%91%E7%BB%9C%E4%B8%96%E7%95%8C%E7%9A%84%E4%B8%B4%E9%97%A8%E4%B8%80%E8%84%9A/>2. ARP协议：网络世界的临门一脚</a></dd><dd class=col-md-9><a href=/category/network/20%E5%BC%A0%E5%9B%BE%E8%AF%B4%E6%B8%85%E6%A5%9A-IP-%E5%8D%8F%E8%AE%AE/>3. 20张图说清楚 IP 协议</a></dd><dd class=col-md-9><a href=/category/network/ICMP/>5. 为什么说 ICMP 协议是网络最强辅助</a></dd></dl><div class=author-card><div class=underline></div><div class=author-box><div class=qr-author-image><a href=/><img src=/images/person.jpg alt=风筝></a></div><div class=author-content><p class=author-title>作者</p><p class=author-name>风筝</p><p class=author-desc>古时的风筝，一个平庸的程序员，主语言 Java，第二语言 Python，其实学 Python 的时间比 Java 还要早。喜欢写博客，写博客的过程能加深自己对一个知识点的理解，同时还可以分享给他人。喜欢做一些小东西，所以也会一些前端的东西，React、JavaScript、CSS 都会一些，做一些小工具还够用。</p></div></div></div><script src=https://utteranc.es/client.js repo=huzhicheng/blog-comment issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></main><div class="footer gradient-2"><div class="container footer-container"><div class=row><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>网站地图</div><ul class=list-unstyled><li><a href=https://www.moonkite.cn/tags/>标签</a></li><li><a href=https://www.moonkite.cn/categories/>分类</a></li><li><a rel=alternate type=application/rss+xml href=https://www.moonkite.cn/index.xml><i class="fas fa-rss-square"></i> RSS订阅</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>社群</div><ul class=list-unstyled><li><a href=https://github.com/huzhicheng rel=noopener target=_blank>GitHub</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>友链</div><ul class=list-unstyled><li><a href=https://github.com/huzhicheng rel=noopener target=_blank>关于我</a></li></ul></div><div class="col-xs-12 col-sm-3 col-md-3 col-lg-3"><p class="pull-right text-right"><small><em>Proudly powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo</a></em></small><br><small><em>Theme - <a href=https://github.com/shaform/hugo-theme-den rel=noopener target=_blank>Den</a></em></small><br><small>&copy;
风筝
2023</small></p></div></div><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?e417ddf834c7bb7411207e1fa09815aa",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></div></div><script src=https://cdn.staticfile.org/jquery/3.3.1/jquery.slim.min.js integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script><script src=https://cdn.staticfile.org/popper.js/1.14.3/umd/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script><script src=https://cdn.staticfile.org/twitter-bootstrap/4.1.3/js/bootstrap.js></script><script>$(document).ready(function(){$("#load_disqus").length&&$(window).scroll(function(){if($("#load_disqus").length){var e=$("#load_disqus").offset().top,t=$(window).scrollTop(),n=t+$(window).height();t<e&&e<n&&load_disqus()}})})</script></body></html>