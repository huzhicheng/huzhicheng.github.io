<!doctype html><html lang=zh-cn itemscope itemtype=http://schema.org/WebPage><head><meta name=generator content="Hugo 0.114.1"><meta charset=utf-8><title>8000字长文让你彻底了解 Java 8 的 Lambda、函数式接口、Stream 用法和原理 · 古时的风筝</title><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=description content="就在今年 Java 25周岁了，可能比在座的各位中的一些少年年龄还大，但令人遗憾的是，竟然没有我大，不禁感叹，Java 还是太小了。（难道我会说是因为我"><meta name=keywords content="Hugo,theme,编程,java,ChatGPT,程序员,开发"><link rel=canonical href=https://moonkite.cn/category/java/Java-Stream/><link rel=icon href=https://moonkite.cn/images/photo.png><link rel=stylesheet href=https://cdn.usebootstrap.com/bootstrap/4.1.3/css/bootstrap.min.css><link rel=stylesheet href=https://moonkite.cn/css/den.css><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-tc-webfont@1.0.0/style.css><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><meta name=referrer content="no-referrer-when-downgrade"><meta property="og:title" content="8000字长文让你彻底了解 Java 8 的 Lambda、函数式接口、Stream 用法和原理"><meta property="og:description" content="就在今年 Java 25周岁了，可能比在座的各位中的一些少年年龄还大，但令人遗憾的是，竟然没有我大，不禁感叹，Java 还是太小了。（难道我会说是因为我"><meta property="og:type" content="article"><meta property="og:url" content="https://moonkite.cn/category/java/Java-Stream/"><meta property="article:section" content="category"><meta property="article:published_time" content="2020-06-10T08:56:23+08:00"><meta property="article:modified_time" content="2020-06-10T08:56:23+08:00"><meta itemprop=name content="8000字长文让你彻底了解 Java 8 的 Lambda、函数式接口、Stream 用法和原理"><meta itemprop=description content="就在今年 Java 25周岁了，可能比在座的各位中的一些少年年龄还大，但令人遗憾的是，竟然没有我大，不禁感叹，Java 还是太小了。（难道我会说是因为我"><meta itemprop=datePublished content="2020-06-10T08:56:23+08:00"><meta itemprop=dateModified content="2020-06-10T08:56:23+08:00"><meta itemprop=wordCount content="7129"><meta itemprop=keywords content="Java,JDK,JVM,Lambda,函数式接口,Stream,String,"><meta name=twitter:card content="summary"><meta name=twitter:title content="8000字长文让你彻底了解 Java 8 的 Lambda、函数式接口、Stream 用法和原理"><meta name=twitter:description content="就在今年 Java 25周岁了，可能比在座的各位中的一些少年年龄还大，但令人遗憾的是，竟然没有我大，不禁感叹，Java 还是太小了。（难道我会说是因为我"></head><body><div class=header-container style=background:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2)),url(https://moonkite.cn/images/background.png);background-position:top;background-size:cover><div class=container><nav class="header-nav navbar navbar-expand-md navbar-dark light-dark"><div class="header-logo navbar-brand"><a class=float-left href=https://moonkite.cn/></a></div><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarNav aria-controls=navbarNav aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="nav-menu collapse navbar-collapse" id=navbarNav><ul class=navbar-nav><li class=nav-item><a href=https://moonkite.cn/ class=nav-link><i class="fas fad fa-h-square"></i>主页</a></li><li class=nav-item><a href=https://moonkite.cn/category/notes/ class=nav-link><i class='fas fa-yin-yang'></i>生活随笔</a></li><li class=nav-item><a href=javascript:void(0) class=nav-link><i class='fas fa-laptop-code'></i>技术文章</a><div class=sub-dropdown-menu><a class=sub-nav-link href=https://moonkite.cn/category/java><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 48 48"><path fill="#f44336" d="M23.65 24.898c-.998-1.609-1.722-2.943-2.725-5.455C19.229 15.2 31.24 11.366 26.37 3.999c2.111 5.089-7.577 8.235-8.477 12.473-.823 3.898 5.752 8.426 5.757 8.426z"/><path fill="#f44336" d="M23.878 17.27c-.192 2.516 2.229 3.857 2.299 5.695.056 1.496-1.447 2.743-1.447 2.743s2.728-.536 3.579-2.818c.945-2.534-1.834-4.269-1.548-6.298.267-1.938 6.031-5.543 6.031-5.543S24.311 11.611 23.878 17.27z"/><g><path fill="#1565c0" d="M32.084 25.055c1.754-.394 3.233.723 3.233 2.01.0 2.901-4.021 5.643-4.021 5.643s6.225-.742 6.225-5.505c0-3.15-3.057-3.937-5.437-2.148zm-2.955 2.34s1.941-1.383 2.458-1.902c-4.763 1.011-15.638 1.147-15.638.269.0-.809 3.507-1.638 3.507-1.638s-7.773-.112-7.773 2.181C11.683 28.695 21.858 28.866 29.129 27.395z"/><path fill="#1565c0" d="M27.935 29.571c-4.509 1.499-12.814 1.02-10.354-.993-1.198.0-2.974.963-2.974 1.889.0 1.857 8.982 3.291 15.63.572l-2.302-1.468z"/><path fill="#1565c0" d="M18.686 32.739c-1.636.0-2.695 1.054-2.695 1.822.0 2.391 9.76 2.632 13.627.205l-2.458-1.632C24.271 34.404 17.014 34.579 18.686 32.739z"/><path fill="#1565c0" d="M36.281 36.632c0-.936-1.055-1.377-1.433-1.588 2.228 5.373-22.317 4.956-22.317 1.784.0-.721 1.807-1.427 3.477-1.093l-1.42-.839C11.26 34.374 9 35.837 9 37.017 9 42.52 36.281 42.255 36.281 36.632z"/><path fill="#1565c0" d="M39 38.604c-4.146 4.095-14.659 5.587-25.231 3.057C24.341 46.164 38.95 43.628 39 38.604z"/></g></svg>&nbsp;可爱的 Java</a>
<a class=sub-nav-link href=https://moonkite.cn/category/SpringCloud><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 48 48"><path fill="#8bc34a" d="M43.982 23.635c.069-4.261-.891-9.328-2.891-15.273L39.523 3.7l-2.13 4.433c-.114.237-.244.469-.38.698C33.514 5.827 28.974 4 24 4 12.954 4 4 12.954 4 24s8.954 20 20 20 20-8.954 20-20C44 23.877 43.984 23.758 43.982 23.635z"/><path fill="#fff" d="M39.385 32.558C36.262 36.86 30.734 37.091 25.531 37H18.75h-1.938c4.428-1.593 7.063-1.972 9.754-3.4 5.068-2.665 10.078-8.496 11.121-14.562-1.93 5.836-7.779 10.85-13.109 12.889-3.652 1.393-10.248 2.745-10.248 2.745l-.267-.145C9.573 32.268 9.437 22.214 17.6 18.968c3.574-1.423 6.993-.641 10.854-1.593 4.122-1.012 8.89-4.208 10.83-8.375C41.456 15.667 44.07 26.106 39.385 32.558zM15.668 38.445C15.386 38.795 14.955 39 14.505 39c-.823.0-1.495-.677-1.495-1.5s.677-1.5 1.495-1.5c.341.0.677.118.941.336C16.086 36.855 16.186 37.805 15.668 38.445z"/></svg>&nbsp; Spring Cloud 系列</a></div></li><li class=nav-item><a href=https://moonkite.cn/category/network class=nav-link><i class="fas fa-network-wired"></i>轻解计算机网络</a></li><li class=nav-item><a href=https://moonkite.cn/category/product class=nav-link><i class="fas fab fa-medapps"></i>我的产品</a></li></ul></div></nav></div><div class="container header-wrapper"><div class=row><div class=col-lg-12><div class=header-content><h1 class=header-title>8000字长文让你彻底了解 Java 8 的 Lambda、函数式接口、Stream 用法和原理</h1><p class=header-date>作者：
风筝 /
2020-06-10<div class=header-underline></div><div class=header-date>&nbsp·&nbsp
  <span id=busuanzi_container_page_pv>本文被阅读<span id=busuanzi_value_page_pv></span>次</span></div><div class=clearfix></div><p class="float-right header-tags"><i class="fas fa-tags" aria-hidden=true></i>
<a href=https://moonkite.cn/tag/Java/>Java</a>,
<a href=https://moonkite.cn/tag/JDK/>JDK</a>,
<a href=https://moonkite.cn/tag/JVM/>JVM</a>,
<a href=https://moonkite.cn/tag/Lambda/>Lambda</a>,
<a href=https://moonkite.cn/tag/Stream/>Stream</a>,
<a href=https://moonkite.cn/tag/String/>String</a>,
<a href=https://moonkite.cn/tag/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/>函数式接口</a></p></div></div></div></div></div><main><div class="container content"><article><p>就在今年 Java 25周岁了，可能比在座的各位中的一些少年年龄还大，但令人遗憾的是，竟然没有我大，不禁感叹，Java 还是太小了。（难道我会说是因为我老了？）</p><p><img src=https://hexo.moonkite.cn/blog/1729bd280f103deb~tplv-t2oaga2asx-image.image alt></p><p>而就在上个月，Java 15 的试验版悄悄发布了，但是在 Java 界一直有个神秘现象，那就是「你发你发任你发，我的最爱 Java 8」.</p><p>据 Snyk 和 The Java Magazine 联合推出发布的 2020 JVM 生态调查报告显示，在所有的 Java 版本中，仍然有 64% 的开发者使用 Java 8。另外一些开发者可能已经开始用 Java 9、Java 11、Java 13 了，当然还有一些神仙开发者还在坚持使用 JDK 1.6 和 1.7。</p><p>尽管 Java 8 发布多年，使用者众多，可神奇的是竟然有很多同学没有用过 Java 8 的新特性，比如 <strong>Lambda</strong>表达式、比如<strong>方法引用</strong>，再比如今天要说的 <strong>Stream</strong>。其实 Stream 就是以 Lambda 和方法引用为基础，封装的简单易用、函数式风格的 API。</p><p>Java 8 是在 2014 年发布的，实话说，风筝我也是在 Java 8 发布后很长一段时间才用的 Stream，因为 Java 8 发布的时候我还在 C# 的世界中挣扎，而使用 Lambda 表达式却很早了，因为 Python 中用 Lambda 很方便，没错，我写 Python 的时间要比 Java 的时间还长。</p><p><img src=https://hexo.moonkite.cn/blog/1729bd280f725e46~tplv-t2oaga2asx-image.image alt=img></p><p>要讲 Stream ，那就不得不先说一下它的左膀右臂 Lambda 和方法引用，你用的 Stream API 其实就是函数式的编程风格，其中的「函数」就是方法引用，「式」就是 Lambda 表达式。</p><p><img src=https://hexo.moonkite.cn/blog/1729bd28103cd64e~tplv-t2oaga2asx-image.image alt=img></p><h2 id=lambda-表达式>Lambda 表达式</h2><blockquote><p>Lambda 表达式是一个<a href=https://baike.baidu.com/item/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/4337265>匿名函数</a>，Lambda表达式基于数学中的<a href=https://baike.baidu.com/item/%CE%BB%E6%BC%94%E7%AE%97>λ演算</a>得名，直接对应于其中的lambda抽象，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包。</p></blockquote><p>在 Java 中，Lambda 表达式的格式是像下面这样</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 无参数，无返回值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>()</span> <span class=o>-&gt;</span> <span class=n>log</span><span class=o>.</span><span class=na>info</span><span class=o>(</span><span class=s>&#34;Lambda&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=c1>// 有参数，有返回值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>(</span><span class=kt>int</span> <span class=n>a</span><span class=o>,</span> <span class=kt>int</span> <span class=n>b</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>{</span> <span class=n>a</span><span class=o>+</span><span class=n>b</span> <span class=o>}</span>
</span></span></code></pre></div><p>其等价于</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>log</span><span class=o>.</span><span class=na>info</span><span class=o>(</span><span class=s>&#34;Lambda&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kt>int</span> <span class=nf>plus</span><span class=o>(</span><span class=kt>int</span> <span class=n>a</span><span class=o>,</span> <span class=kt>int</span> <span class=n>b</span><span class=o>){</span>
</span></span><span class=line><span class=cl>  	<span class=k>return</span> <span class=n>a</span><span class=o>+</span><span class=n>b</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>最常见的一个例子就是新建线程，有时候为了省事，会用下面的方法创建并启动一个线程，这是匿名内部类的写法，<code>new Thread</code>需要一个 implements 自<code>Runnable</code>类型的对象实例作为参数，比较好的方式是创建一个新类，这个类 <code>implements Runnable</code>，然后 new 出这个新类的实例作为参数传给 Thread。而匿名内部类不用找对象接收，直接当做参数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=k>new</span> <span class=n>Thread</span><span class=o>(</span><span class=k>new</span> <span class=n>Runnable</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>run</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;快速新建并启动一个线程&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}).</span><span class=na>run</span><span class=o>();</span>
</span></span></code></pre></div><p>但是这样写是不是感觉看上去很乱、很土，而这时候，换上 Lambda 表达式就是另外一种感觉了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=k>new</span> <span class=n>Thread</span><span class=o>(()-&gt;{</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;快速新建并启动一个线程&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}).</span><span class=na>run</span><span class=o>();</span>
</span></span></code></pre></div><p>怎么样，这样一改，瞬间感觉清新脱俗了不少，简洁优雅了不少。</p><p>Lambda 表达式简化了匿名内部类的形式，可以达到同样的效果，但是 Lambda 要优雅的多。虽然最终达到的目的是一样的，但其实内部的实现原理却不相同。</p><p>匿名内部类在编译之后会创建一个新的匿名内部类出来，而 Lambda 是调用 JVM <code>invokedynamic</code>指令实现的，并不会产生新类。</p><h2 id=方法引用>方法引用</h2><p>方法引用的出现，使得我们可以将一个方法赋给一个变量或者作为参数传递给另外一个方法。<code>::</code>双冒号作为方法引用的符号，比如下面这两行语句，引用 <code>Integer</code>类的 <code>parseInt</code>方法。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Function</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;</span> <span class=n>s</span> <span class=o>=</span> <span class=n>Integer</span><span class=o>::</span><span class=n>parseInt</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=n>Integer</span> <span class=n>i</span> <span class=o>=</span> <span class=n>s</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=s>&#34;10&#34;</span><span class=o>);</span>
</span></span></code></pre></div><p>或者下面这两行，引用 <code>Integer</code>类的 <code>compare</code>方法。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Comparator</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>comparator</span> <span class=o>=</span> <span class=n>Integer</span><span class=o>::</span><span class=n>compare</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>comparator</span><span class=o>.</span><span class=na>compare</span><span class=o>(</span><span class=mi>100</span><span class=o>,</span><span class=mi>10</span><span class=o>);</span>
</span></span></code></pre></div><p>再比如，下面这两行代码，同样是引用 <code>Integer</code>类的 <code>compare</code>方法，但是返回类型却不一样，但却都能正常执行，并正确返回。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>IntBinaryOperator</span> <span class=n>intBinaryOperator</span> <span class=o>=</span> <span class=n>Integer</span><span class=o>::</span><span class=n>compare</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>intBinaryOperator</span><span class=o>.</span><span class=na>applyAsInt</span><span class=o>(</span><span class=mi>10</span><span class=o>,</span><span class=mi>100</span><span class=o>);</span>
</span></span></code></pre></div><p>相信有的同学看到这里恐怕是下面这个状态，完全不可理喻吗，也太随便了吧，返回给谁都能接盘。</p><p><img src=https://hexo.moonkite.cn/blog/1729bd28113e1081~tplv-t2oaga2asx-image.image alt=img></p><p>先别激动，来来来，现在咱们就来解惑，解除蒙圈脸。</p><p><strong>Q：什么样的方法可以被引用？</strong></p><p>A：这么说吧，任何你有办法访问到的方法都可以被引用。</p><p><strong>Q：返回值到底是什么类型？</strong></p><p>A：这就问到点儿上了，上面又是 <code>Function</code>、又是<code>Comparator</code>、又是 <code>IntBinaryOperator</code>的，看上去好像没有规律，其实不然。</p><p>返回的类型是 Java 8 专门定义的函数式接口，这类接口用 <code>@FunctionalInterface</code> 注解。</p><p>比如 <code>Function</code>这个函数式接口的定义如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@FunctionalInterface</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>Function</span><span class=o>&lt;</span><span class=n>T</span><span class=o>,</span> <span class=n>R</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>R</span> <span class=nf>apply</span><span class=o>(</span><span class=n>T</span> <span class=n>t</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>还有很关键的一点，你的引用方法的参数个数、类型，返回值类型要和函数式接口中的方法声明一一对应才行。</p><p>比如 <code>Integer.parseInt</code>方法定义如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=kt>int</span> <span class=nf>parseInt</span><span class=o>(</span><span class=n>String</span> <span class=n>s</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>NumberFormatException</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>parseInt</span><span class=o>(</span><span class=n>s</span><span class=o>,</span><span class=mi>10</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>首先<code>parseInt</code>方法的参数个数是 1 个，而 <code>Function</code>中的 <code>apply</code>方法参数个数也是 1 个，参数个数对应上了，再来，<code>apply</code>方法的参数类型和返回类型是泛型类型，所以肯定能和 <code>parseInt</code>方法对应上。</p><p>这样一来，就可以正确的接收<code>Integer::parseInt</code>的方法引用，并可以调用<code>Funciton</code>的<code>apply</code>方法，这时候，调用到的其实就是对应的 <code>Integer.parseInt</code>方法了。</p><p>用这套标准套到 <code>Integer::compare</code>方法上，就不难理解为什么即可以用 <code>Comparator&lt;Integer></code>接收，又可以用 <code>IntBinaryOperator</code>接收了，而且调用它们各自的方法都能正确的返回结果。</p><p><code>Integer.compare</code>方法定义如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=kt>int</span> <span class=nf>compare</span><span class=o>(</span><span class=kt>int</span> <span class=n>x</span><span class=o>,</span> <span class=kt>int</span> <span class=n>y</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>(</span><span class=n>x</span> <span class=o>&lt;</span> <span class=n>y</span><span class=o>)</span> <span class=o>?</span> <span class=o>-</span><span class=mi>1</span> <span class=o>:</span> <span class=o>((</span><span class=n>x</span> <span class=o>==</span> <span class=n>y</span><span class=o>)</span> <span class=o>?</span> <span class=mi>0</span> <span class=o>:</span> <span class=mi>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>返回值类型 <code>int</code>，两个参数，并且参数类型都是 <code>int</code>。</p><p>然后来看<code>Comparator</code>和<code>IntBinaryOperator</code>它们两个的函数式接口定义和其中对应的方法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@FunctionalInterface</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>Comparator</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>compare</span><span class=o>(</span><span class=n>T</span> <span class=n>o1</span><span class=o>,</span> <span class=n>T</span> <span class=n>o2</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@FunctionalInterface</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>IntBinaryOperator</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>applyAsInt</span><span class=o>(</span><span class=kt>int</span> <span class=n>left</span><span class=o>,</span> <span class=kt>int</span> <span class=n>right</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>对不对，都能正确的匹配上，所以前面示例中用这两个函数式接口都能正常接收。其实不止这两个，只要是在某个函数式接口中声明了这样的方法：两个参数，参数类型是 <code>int</code>或者泛型，并且返回值是 <code>int</code>或者泛型的，都可以完美接收。</p><p>JDK 中定义了很多函数式接口，主要在 <code>java.util.function</code>包下，还有 <code>java.util.Comparator</code> 专门用作定制比较器。另外，前面说的 <code>Runnable</code>也是一个函数式接口。</p><p><img src=https://hexo.moonkite.cn/blog/1729bd28111998c3~tplv-t2oaga2asx-image.image alt="functionInterface 引用"></p><h2 id=自己动手实现一个例子>自己动手实现一个例子</h2><p><strong>1. 定义一个函数式接口，并添加一个方法</strong></p><p>定义了名称为 KiteFunction 的函数式接口，使用 <code>@FunctionalInterface</code>注解，然后声明了具有两个参数的方法 <code>run</code>，都是泛型类型，返回结果也是泛型。</p><p>还有一点很重要，函数式接口中只能声明一个可被实现的方法，你不能声明了一个 <code>run</code>方法，又声明一个 <code>start</code>方法，到时候编译器就不知道用哪个接收了。而用<code>default</code> 关键字修饰的方法则没有影响。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@FunctionalInterface</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>KiteFunction</span><span class=o>&lt;</span><span class=n>T</span><span class=o>,</span> <span class=n>R</span><span class=o>,</span> <span class=n>S</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 定义一个双参数的方法
</span></span></span><span class=line><span class=cl><span class=cm>     * @param t
</span></span></span><span class=line><span class=cl><span class=cm>     * @param s
</span></span></span><span class=line><span class=cl><span class=cm>     * @return
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=n>R</span> <span class=nf>run</span><span class=o>(</span><span class=n>T</span> <span class=n>t</span><span class=o>,</span><span class=n>S</span> <span class=n>s</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p><strong>2. 定义一个与 KiteFunction 中 run 方法对应的方法</strong></p><p>在 FunctionTest 类中定义了方法 <code>DateFormat</code>，一个将 <code>LocalDateTime</code>类型格式化为字符串类型的方法。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>FunctionTest</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=n>String</span> <span class=nf>DateFormat</span><span class=o>(</span><span class=n>LocalDateTime</span> <span class=n>dateTime</span><span class=o>,</span> <span class=n>String</span> <span class=n>partten</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>DateTimeFormatter</span> <span class=n>dateTimeFormatter</span> <span class=o>=</span> <span class=n>DateTimeFormatter</span><span class=o>.</span><span class=na>ofPattern</span><span class=o>(</span><span class=n>partten</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>dateTime</span><span class=o>.</span><span class=na>format</span><span class=o>(</span><span class=n>dateTimeFormatter</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p><strong>3.用方法引用的方式调用</strong></p><p>正常情况下我们直接使用 <code>FunctionTest.DateFormat()</code>就可以了。</p><p>而用函数式方式，是这样的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>KiteFunction</span><span class=o>&lt;</span><span class=n>LocalDateTime</span><span class=o>,</span><span class=n>String</span><span class=o>,</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>functionDateFormat</span> <span class=o>=</span> <span class=n>FunctionTest</span><span class=o>::</span><span class=n>DateFormat</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=n>String</span> <span class=n>dateString</span> <span class=o>=</span> <span class=n>functionDateFormat</span><span class=o>.</span><span class=na>run</span><span class=o>(</span><span class=n>LocalDateTime</span><span class=o>.</span><span class=na>now</span><span class=o>(),</span><span class=s>&#34;yyyy-MM-dd HH:mm:ss&#34;</span><span class=o>);</span>
</span></span></code></pre></div><p>而其实我可以不专门在外面定义 <code>DateFormat</code>这个方法，而是像下面这样，使用匿名内部类。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>Exception</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=n>String</span> <span class=n>dateString</span> <span class=o>=</span> <span class=k>new</span> <span class=n>KiteFunction</span><span class=o>&lt;</span><span class=n>LocalDateTime</span><span class=o>,</span> <span class=n>String</span><span class=o>,</span> <span class=n>String</span><span class=o>&gt;()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>        <span class=kd>public</span> <span class=n>String</span> <span class=nf>run</span><span class=o>(</span><span class=n>LocalDateTime</span> <span class=n>localDateTime</span><span class=o>,</span> <span class=n>String</span> <span class=n>s</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>DateTimeFormatter</span> <span class=n>dateTimeFormatter</span> <span class=o>=</span> <span class=n>DateTimeFormatter</span><span class=o>.</span><span class=na>ofPattern</span><span class=o>(</span><span class=n>s</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>localDateTime</span><span class=o>.</span><span class=na>format</span><span class=o>(</span><span class=n>dateTimeFormatter</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}.</span><span class=na>run</span><span class=o>(</span><span class=n>LocalDateTime</span><span class=o>.</span><span class=na>now</span><span class=o>(),</span> <span class=s>&#34;yyyy-MM-dd HH:mm:ss&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>dateString</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>前面第一个 <code>Runnable</code>的例子也提到了，这样的匿名内部类可以用 Lambda 表达式的形式简写，简写后的代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>Exception</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>KiteFunction</span><span class=o>&lt;</span><span class=n>LocalDateTime</span><span class=o>,</span> <span class=n>String</span><span class=o>,</span> <span class=n>String</span><span class=o>&gt;</span> <span class=n>functionDateFormat</span> <span class=o>=</span> <span class=o>(</span><span class=n>LocalDateTime</span> <span class=n>dateTime</span><span class=o>,</span> <span class=n>String</span> <span class=n>partten</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>DateTimeFormatter</span> <span class=n>dateTimeFormatter</span> <span class=o>=</span> <span class=n>DateTimeFormatter</span><span class=o>.</span><span class=na>ofPattern</span><span class=o>(</span><span class=n>partten</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>dateTime</span><span class=o>.</span><span class=na>format</span><span class=o>(</span><span class=n>dateTimeFormatter</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>};</span>
</span></span><span class=line><span class=cl>        <span class=n>String</span> <span class=n>dateString</span> <span class=o>=</span> <span class=n>functionDateFormat</span><span class=o>.</span><span class=na>run</span><span class=o>(</span><span class=n>LocalDateTime</span><span class=o>.</span><span class=na>now</span><span class=o>(),</span> <span class=s>&#34;yyyy-MM-dd HH:mm:ss&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>dateString</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>使用（LocalDateTime dateTime, String partten) -> { } 这样的 Lambda 表达式直接返回方法引用。</p><h2 id=stream-api>Stream API</h2><p>为了说一下 Stream API 的使用，可以说是大费周章啊，知其然，也要知其所以然吗，追求技术的态度和姿势要正确。</p><p>当然 Stream 也不只是 Lambda 表达式就厉害了，真正厉害的还是它的功能，Stream 是 Java 8 中集合数据处理的利器，很多本来复杂、需要写很多代码的方法，比如过滤、分组等操作，往往使用 Stream 就可以在一行代码搞定，当然也因为 Stream 都是链式操作，一行代码可能会调用好几个方法。</p><p><code>Collection</code>接口提供了 <code>stream()</code>方法，让我们可以在一个集合方便的使用 Stream API 来进行各种操作。值得注意的是，我们执行的任何操作都不会对源集合造成影响，你可以同时在一个集合上提取出多个 stream 进行操作。</p><p>我们看 Stream 接口的定义，继承自 <code>BaseStream</code>，几乎所有的接口声明都是接收方法引用类型的参数，比如 <code>filter</code>方法，接收了一个 <code>Predicate</code>类型的参数，它就是一个函数式接口，常用来作为条件比较、筛选、过滤用，<code>JPA</code>中也使用了这个函数式接口用来做查询条件拼接。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>Stream</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=kd>extends</span> <span class=n>BaseStream</span><span class=o>&lt;</span><span class=n>T</span><span class=o>,</span> <span class=n>Stream</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=n>Stream</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=nf>filter</span><span class=o>(</span><span class=n>Predicate</span><span class=o>&lt;?</span> <span class=kd>super</span> <span class=n>T</span><span class=o>&gt;</span> <span class=n>predicate</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=c1>// 其他接口
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>}</span>  
</span></span></code></pre></div><p>下面就来看看 Stream 常用 API。</p><p><img src=https://hexo.moonkite.cn/blog/1729bd28128ee5d8~tplv-t2oaga2asx-image.image alt=img></p><h3 id=of>of</h3><p>可接收一个泛型对象或可变成泛型集合，构造一个 Stream 对象。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>createStream</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>Stream</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>stringStream</span> <span class=o>=</span> <span class=n>Stream</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=s>&#34;a&#34;</span><span class=o>,</span><span class=s>&#34;b&#34;</span><span class=o>,</span><span class=s>&#34;c&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=empty>empty</h3><p>创建一个空的 Stream 对象。</p><h3 id=concat>concat</h3><p>连接两个 Stream ，不改变其中任何一个 Steam 对象，返回一个新的 Stream 对象。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>concatStream</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>Stream</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>a</span> <span class=o>=</span> <span class=n>Stream</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=s>&#34;a&#34;</span><span class=o>,</span><span class=s>&#34;b&#34;</span><span class=o>,</span><span class=s>&#34;c&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Stream</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>b</span> <span class=o>=</span> <span class=n>Stream</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=s>&#34;d&#34;</span><span class=o>,</span><span class=s>&#34;e&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Stream</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>c</span> <span class=o>=</span> <span class=n>Stream</span><span class=o>.</span><span class=na>concat</span><span class=o>(</span><span class=n>a</span><span class=o>,</span><span class=n>b</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=max>max</h3><p>一般用于求数字集合中的最大值，或者按实体中数字类型的属性比较，拥有最大值的那个实体。它接收一个 <code>Comparator&lt;T></code>，上面也举到这个例子了，它是一个函数式接口类型，专门用作定义两个对象之间的比较，例如下面这个方法使用了 <code>Integer::compareTo</code>这个方法引用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>max</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>Stream</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>integerStream</span> <span class=o>=</span> <span class=n>Stream</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=mi>2</span><span class=o>,</span> <span class=mi>2</span><span class=o>,</span> <span class=mi>100</span><span class=o>,</span> <span class=mi>5</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Integer</span> <span class=n>max</span> <span class=o>=</span> <span class=n>integerStream</span><span class=o>.</span><span class=na>max</span><span class=o>(</span><span class=n>Integer</span><span class=o>::</span><span class=n>compareTo</span><span class=o>).</span><span class=na>get</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>max</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>当然，我们也可以自己定制一个 <code>Comparator</code>，顺便复习一下 Lambda 表达式形式的方法引用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>max</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>Stream</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>integerStream</span> <span class=o>=</span> <span class=n>Stream</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=mi>2</span><span class=o>,</span> <span class=mi>2</span><span class=o>,</span> <span class=mi>100</span><span class=o>,</span> <span class=mi>5</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Comparator</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>comparator</span> <span class=o>=</span>  <span class=o>(</span><span class=n>x</span><span class=o>,</span> <span class=n>y</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>(</span><span class=n>x</span><span class=o>.</span><span class=na>intValue</span><span class=o>()</span> <span class=o>&lt;</span> <span class=n>y</span><span class=o>.</span><span class=na>intValue</span><span class=o>())</span> <span class=o>?</span> <span class=o>-</span><span class=mi>1</span> <span class=o>:</span> <span class=o>((</span><span class=n>x</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>y</span><span class=o>))</span> <span class=o>?</span> <span class=mi>0</span> <span class=o>:</span> <span class=mi>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Integer</span> <span class=n>max</span> <span class=o>=</span> <span class=n>integerStream</span><span class=o>.</span><span class=na>max</span><span class=o>(</span><span class=n>comparator</span><span class=o>).</span><span class=na>get</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>max</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=min>min</h3><p>与 max 用法一样，只不过是求最小值。</p><h3 id=findfirst>findFirst</h3><p>获取 Stream 中的第一个元素。</p><h3 id=findany>findAny</h3><p>获取 Stream 中的某个元素，如果是串行情况下，一般都会返回第一个元素，并行情况下就不一定了。</p><h3 id=count>count</h3><p>返回元素个数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Stream</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>a</span> <span class=o>=</span> <span class=n>Stream</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=s>&#34;a&#34;</span><span class=o>,</span> <span class=s>&#34;b&#34;</span><span class=o>,</span> <span class=s>&#34;c&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=kt>long</span> <span class=n>x</span> <span class=o>=</span> <span class=n>a</span><span class=o>.</span><span class=na>count</span><span class=o>();</span>
</span></span></code></pre></div><h3 id=peek>peek</h3><p>建立一个通道，在这个通道中对 Stream 的每个元素执行对应的操作，对应 <code>Consumer&lt;T></code>的函数式接口，这是一个消费者函数式接口，顾名思义，它是用来消费 Stream 元素的，比如下面这个方法，把每个元素转换成对应的大写字母并输出。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>peek</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Stream</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>a</span> <span class=o>=</span> <span class=n>Stream</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=s>&#34;a&#34;</span><span class=o>,</span> <span class=s>&#34;b&#34;</span><span class=o>,</span> <span class=s>&#34;c&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>list</span> <span class=o>=</span> <span class=n>a</span><span class=o>.</span><span class=na>peek</span><span class=o>(</span><span class=n>e</span><span class=o>-&gt;</span><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>e</span><span class=o>.</span><span class=na>toUpperCase</span><span class=o>())).</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>toList</span><span class=o>());</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=foreach>forEach</h3><p>和 peek 方法类似，都接收一个消费者函数式接口，可以对每个元素进行对应的操作，但是和 peek 不同的是，<code>forEach</code> 执行之后，这个 Stream 就真的被消费掉了，之后这个 Stream 流就没有了，不可以再对它进行后续操作了，而 <code>peek</code>操作完之后，还是一个可操作的 Stream 对象。</p><p>正好借着这个说一下，我们在使用 Stream API 的时候，都是一串链式操作，这是因为很多方法，比如接下来要说到的 <code>filter</code>方法等，返回值还是这个 Stream 类型的，也就是被当前方法处理过的 Stream 对象，所以 Stream API 仍然可以使用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>forEach</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Stream</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>a</span> <span class=o>=</span> <span class=n>Stream</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=s>&#34;a&#34;</span><span class=o>,</span> <span class=s>&#34;b&#34;</span><span class=o>,</span> <span class=s>&#34;c&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>.</span><span class=na>forEach</span><span class=o>(</span><span class=n>e</span><span class=o>-&gt;</span><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>e</span><span class=o>.</span><span class=na>toUpperCase</span><span class=o>()));</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=foreachordered>forEachOrdered</h3><p>功能与 <code>forEach</code>是一样的，不同的是，<code>forEachOrdered</code>是有顺序保证的，也就是对 Stream 中元素按插入时的顺序进行消费。为什么这么说呢，当开启并行的时候，<code>forEach</code>和 <code>forEachOrdered</code>的效果就不一样了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Stream</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>a</span> <span class=o>=</span> <span class=n>Stream</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=s>&#34;a&#34;</span><span class=o>,</span> <span class=s>&#34;b&#34;</span><span class=o>,</span> <span class=s>&#34;c&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=o>.</span><span class=na>parallel</span><span class=o>().</span><span class=na>forEach</span><span class=o>(</span><span class=n>e</span><span class=o>-&gt;</span><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>e</span><span class=o>.</span><span class=na>toUpperCase</span><span class=o>()));</span>
</span></span></code></pre></div><p>当使用上面的代码时，输出的结果可能是 B、A、C 或者 A、C、B或者A、B、C，而使用下面的代码，则每次都是 A、 B、C</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Stream</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>a</span> <span class=o>=</span> <span class=n>Stream</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=s>&#34;a&#34;</span><span class=o>,</span> <span class=s>&#34;b&#34;</span><span class=o>,</span> <span class=s>&#34;c&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=o>.</span><span class=na>parallel</span><span class=o>().</span><span class=na>forEachOrdered</span><span class=o>(</span><span class=n>e</span><span class=o>-&gt;</span><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>e</span><span class=o>.</span><span class=na>toUpperCase</span><span class=o>()));</span>
</span></span></code></pre></div><h3 id=limit>limit</h3><p>获取前 n 条数据，类似于 MySQL 的limit，只不过只能接收一个参数，就是数据条数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>limit</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Stream</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>a</span> <span class=o>=</span> <span class=n>Stream</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=s>&#34;a&#34;</span><span class=o>,</span> <span class=s>&#34;b&#34;</span><span class=o>,</span> <span class=s>&#34;c&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>.</span><span class=na>limit</span><span class=o>(</span><span class=mi>2</span><span class=o>).</span><span class=na>forEach</span><span class=o>(</span><span class=n>e</span><span class=o>-&gt;</span><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>e</span><span class=o>));</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>上述代码打印的结果是 a、b。</p><h3 id=skip>skip</h3><p>跳过前 n 条数据，例如下面代码，返回结果是 c。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>skip</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Stream</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>a</span> <span class=o>=</span> <span class=n>Stream</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=s>&#34;a&#34;</span><span class=o>,</span> <span class=s>&#34;b&#34;</span><span class=o>,</span> <span class=s>&#34;c&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>.</span><span class=na>skip</span><span class=o>(</span><span class=mi>2</span><span class=o>).</span><span class=na>forEach</span><span class=o>(</span><span class=n>e</span><span class=o>-&gt;</span><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>e</span><span class=o>));</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=distinct>distinct</h3><p>元素去重，例如下面方法返回元素是 a、b、c，将重复的 b 只保留了一个。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>distinct</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Stream</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>a</span> <span class=o>=</span> <span class=n>Stream</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=s>&#34;a&#34;</span><span class=o>,</span> <span class=s>&#34;b&#34;</span><span class=o>,</span> <span class=s>&#34;c&#34;</span><span class=o>,</span><span class=s>&#34;b&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>.</span><span class=na>distinct</span><span class=o>().</span><span class=na>forEach</span><span class=o>(</span><span class=n>e</span><span class=o>-&gt;</span><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>e</span><span class=o>));</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=sorted>sorted</h3><p>有两个重载，一个无参数，另外一个有个 <code>Comparator</code>类型的参数。</p><p>无参类型的按照自然顺序进行排序，只适合比较单纯的元素，比如数字、字母等。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>sorted</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Stream</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>a</span> <span class=o>=</span> <span class=n>Stream</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=s>&#34;a&#34;</span><span class=o>,</span> <span class=s>&#34;c&#34;</span><span class=o>,</span> <span class=s>&#34;b&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>.</span><span class=na>sorted</span><span class=o>().</span><span class=na>forEach</span><span class=o>(</span><span class=n>e</span><span class=o>-&gt;</span><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>e</span><span class=o>));</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>有参数的需要自定义排序规则，例如下面这个方法，按照第二个字母的大小顺序排序，最后输出的结果是 a1、b3、c6。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>sortedWithComparator</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Stream</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>a</span> <span class=o>=</span> <span class=n>Stream</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=s>&#34;a1&#34;</span><span class=o>,</span> <span class=s>&#34;c6&#34;</span><span class=o>,</span> <span class=s>&#34;b3&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>.</span><span class=na>sorted</span><span class=o>((</span><span class=n>x</span><span class=o>,</span><span class=n>y</span><span class=o>)-&gt;</span><span class=n>Integer</span><span class=o>.</span><span class=na>parseInt</span><span class=o>(</span><span class=n>x</span><span class=o>.</span><span class=na>substring</span><span class=o>(</span><span class=mi>1</span><span class=o>))&gt;</span><span class=n>Integer</span><span class=o>.</span><span class=na>parseInt</span><span class=o>(</span><span class=n>y</span><span class=o>.</span><span class=na>substring</span><span class=o>(</span><span class=mi>1</span><span class=o>))?</span><span class=mi>1</span><span class=o>:-</span><span class=mi>1</span><span class=o>).</span><span class=na>forEach</span><span class=o>(</span><span class=n>e</span><span class=o>-&gt;</span><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>e</span><span class=o>));</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p><strong>为了更好的说明接下来的几个 API ，我模拟了几条项目中经常用到的类似数据，10条用户信息。</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=nf>getUserData</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Random</span> <span class=n>random</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Random</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=n>users</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=mi>10</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>User</span> <span class=n>user</span> <span class=o>=</span> <span class=k>new</span> <span class=n>User</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>user</span><span class=o>.</span><span class=na>setUserId</span><span class=o>(</span><span class=n>i</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>user</span><span class=o>.</span><span class=na>setUserName</span><span class=o>(</span><span class=n>String</span><span class=o>.</span><span class=na>format</span><span class=o>(</span><span class=s>&#34;古时的风筝 %s 号&#34;</span><span class=o>,</span> <span class=n>i</span><span class=o>));</span>
</span></span><span class=line><span class=cl>        <span class=n>user</span><span class=o>.</span><span class=na>setAge</span><span class=o>(</span><span class=n>random</span><span class=o>.</span><span class=na>nextInt</span><span class=o>(</span><span class=mi>100</span><span class=o>));</span>
</span></span><span class=line><span class=cl>        <span class=n>user</span><span class=o>.</span><span class=na>setGender</span><span class=o>(</span><span class=n>i</span> <span class=o>%</span> <span class=mi>2</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>user</span><span class=o>.</span><span class=na>setPhone</span><span class=o>(</span><span class=s>&#34;18812021111&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>user</span><span class=o>.</span><span class=na>setAddress</span><span class=o>(</span><span class=s>&#34;无&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>users</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>user</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>users</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=filter>filter</h3><p>用于条件筛选过滤，筛选出符合条件的数据。例如下面这个方法，筛选出性别为 0，年龄大于 50 的记录。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>filter</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=n>users</span> <span class=o>=</span> <span class=n>getUserData</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>Stream</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=n>stream</span> <span class=o>=</span> <span class=n>users</span><span class=o>.</span><span class=na>stream</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>stream</span><span class=o>.</span><span class=na>filter</span><span class=o>(</span><span class=n>user</span> <span class=o>-&gt;</span> <span class=n>user</span><span class=o>.</span><span class=na>getGender</span><span class=o>().</span><span class=na>equals</span><span class=o>(</span><span class=mi>0</span><span class=o>)</span> <span class=o>&amp;&amp;</span> <span class=n>user</span><span class=o>.</span><span class=na>getAge</span><span class=o>()&gt;</span><span class=mi>50</span><span class=o>).</span><span class=na>forEach</span><span class=o>(</span><span class=n>e</span><span class=o>-&gt;</span><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>e</span><span class=o>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     *等同于下面这种形式 匿名内部类
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl><span class=c1>//    stream.filter(new Predicate&lt;User&gt;() {
</span></span></span><span class=line><span class=cl><span class=c1>//        @Override
</span></span></span><span class=line><span class=cl><span class=c1>//        public boolean test(User user) {
</span></span></span><span class=line><span class=cl><span class=c1>//            return user.getGender().equals(0) &amp;&amp; user.getAge()&gt;50;
</span></span></span><span class=line><span class=cl><span class=c1>//        }
</span></span></span><span class=line><span class=cl><span class=c1>//    }).forEach(e-&gt;System.out.println(e));
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>}</span>
</span></span></code></pre></div><h3 id=map>map</h3><p><code>map</code>方法的接口方法声明如下，接受一个 <code>Function</code>函数式接口，把它翻译成映射最合适了，通过原始数据元素，映射出新的类型。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=n>Stream</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=nf>map</span><span class=o>(</span><span class=n>Function</span><span class=o>&lt;?</span> <span class=kd>super</span> <span class=n>T</span><span class=o>,</span> <span class=o>?</span> <span class=kd>extends</span> <span class=n>R</span><span class=o>&gt;</span> <span class=n>mapper</span><span class=o>);</span>
</span></span></code></pre></div><p>而 <code>Function</code>的声明是这样的，观察 <code>apply</code>方法，接受一个 T 型参数，返回一个 R 型参数。用于将一个类型转换成另外一个类型正合适，这也是 <code>map</code>的初衷所在，用于改变当前元素的类型，例如将 <code>Integer</code> 转为 <code>String</code>类型，将 DAO 实体类型，转换为 DTO 实例类型。</p><p>当然了，T 和 R 的类型也可以一样，这样的话，就和 <code>peek</code>方法没什么不同了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@FunctionalInterface</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>Function</span><span class=o>&lt;</span><span class=n>T</span><span class=o>,</span> <span class=n>R</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Applies this function to the given argument.
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * @param t the function argument
</span></span></span><span class=line><span class=cl><span class=cm>     * @return the function result
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=n>R</span> <span class=nf>apply</span><span class=o>(</span><span class=n>T</span> <span class=n>t</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>例如下面这个方法，应该是业务系统的常用需求，将 User 转换为 API 输出的数据格式。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>map</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=n>users</span> <span class=o>=</span> <span class=n>getUserData</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>Stream</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=n>stream</span> <span class=o>=</span> <span class=n>users</span><span class=o>.</span><span class=na>stream</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span><span class=o>&lt;</span><span class=n>UserDto</span><span class=o>&gt;</span> <span class=n>userDtos</span> <span class=o>=</span> <span class=n>stream</span><span class=o>.</span><span class=na>map</span><span class=o>(</span><span class=n>user</span> <span class=o>-&gt;</span> <span class=n>dao2Dto</span><span class=o>(</span><span class=n>user</span><span class=o>)).</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>toList</span><span class=o>());</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=n>UserDto</span> <span class=nf>dao2Dto</span><span class=o>(</span><span class=n>User</span> <span class=n>user</span><span class=o>){</span>
</span></span><span class=line><span class=cl>    <span class=n>UserDto</span> <span class=n>dto</span> <span class=o>=</span> <span class=k>new</span> <span class=n>UserDto</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>BeanUtils</span><span class=o>.</span><span class=na>copyProperties</span><span class=o>(</span><span class=n>user</span><span class=o>,</span> <span class=n>dto</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//其他额外处理
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>dto</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=maptoint>mapToInt</h3><p>将元素转换成 int 类型，在 <code>map</code>方法的基础上进行封装。</p><h3 id=maptolong>mapToLong</h3><p>将元素转换成 Long 类型，在 <code>map</code>方法的基础上进行封装。</p><h3 id=maptodouble>mapToDouble</h3><p>将元素转换成 Double 类型，在 <code>map</code>方法的基础上进行封装。</p><h3 id=flatmap>flatMap</h3><p>这是用在一些比较特别的场景下，当你的 Stream 是以下这几种结构的时候，需要用到 <code>flatMap</code>方法，用于将原有二维结构扁平化。</p><ol><li><code>Stream&lt;String[]></code></li><li><code>Stream&lt;Set&lt;String>></code></li><li><code>Stream&lt;List&lt;String>></code></li></ol><p>以上这三类结构，通过 <code>flatMap</code>方法，可以将结果转化为 <code>Stream&lt;String></code>这种形式，方便之后的其他操作。</p><p>比如下面这个方法，将<code>List&lt;List&lt;User>></code>扁平处理，然后再使用 <code>map</code>或其他方法进行操作。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>flatMap</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=n>users</span> <span class=o>=</span> <span class=n>getUserData</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=n>users1</span> <span class=o>=</span> <span class=n>getUserData</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span><span class=o>&lt;</span><span class=n>List</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;&gt;</span> <span class=n>userList</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>    <span class=n>userList</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>users</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>userList</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>users1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Stream</span><span class=o>&lt;</span><span class=n>List</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;&gt;</span> <span class=n>stream</span> <span class=o>=</span> <span class=n>userList</span><span class=o>.</span><span class=na>stream</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span><span class=o>&lt;</span><span class=n>UserDto</span><span class=o>&gt;</span> <span class=n>userDtos</span> <span class=o>=</span> <span class=n>stream</span><span class=o>.</span><span class=na>flatMap</span><span class=o>(</span><span class=n>subUserList</span><span class=o>-&gt;</span><span class=n>subUserList</span><span class=o>.</span><span class=na>stream</span><span class=o>()).</span><span class=na>map</span><span class=o>(</span><span class=n>user</span> <span class=o>-&gt;</span> <span class=n>dao2Dto</span><span class=o>(</span><span class=n>user</span><span class=o>)).</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>toList</span><span class=o>());</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=flatmaptoint>flatMapToInt</h3><p>用法参考 <code>flatMap</code>，将元素扁平为 int 类型，在 <code>flatMap</code>方法的基础上进行封装。</p><h3 id=flatmaptolong>flatMapToLong</h3><p>用法参考 <code>flatMap</code>，将元素扁平为 Long 类型，在 <code>flatMap</code>方法的基础上进行封装。</p><h3 id=flatmaptodouble>flatMapToDouble</h3><p>用法参考 <code>flatMap</code>，将元素扁平为 Double 类型，在 <code>flatMap</code>方法的基础上进行封装。</p><h3 id=collection>collection</h3><p>在进行了一系列操作之后，我们最终的结果大多数时候并不是为了获取 Stream 类型的数据，而是要把结果变为 List、Map 这样的常用数据结构，而 <code>collection</code>就是为了实现这个目的。</p><p>就拿 map 方法的那个例子说明，将对象类型进行转换后，最终我们需要的结果集是一个 <code>List&lt;UserDto ></code>类型的，使用 <code>collect</code>方法将 Stream 转换为我们需要的类型。</p><p>下面是 <code>collect</code>接口方法的定义：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=o>&lt;</span><span class=n>R</span><span class=o>,</span> <span class=n>A</span><span class=o>&gt;</span> <span class=n>R</span> <span class=nf>collect</span><span class=o>(</span><span class=n>Collector</span><span class=o>&lt;?</span> <span class=kd>super</span> <span class=n>T</span><span class=o>,</span> <span class=n>A</span><span class=o>,</span> <span class=n>R</span><span class=o>&gt;</span> <span class=n>collector</span><span class=o>);</span>
</span></span></code></pre></div><p>下面这个例子演示了将一个简单的 Integer Stream 过滤出大于 7 的值，然后转换成 <code>List&lt;Integer></code>集合，用的是 <code>Collectors.toList()</code>这个收集器。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>collect</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>Stream</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>integerStream</span> <span class=o>=</span> <span class=n>Stream</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=mi>1</span><span class=o>,</span><span class=mi>2</span><span class=o>,</span><span class=mi>5</span><span class=o>,</span><span class=mi>7</span><span class=o>,</span><span class=mi>8</span><span class=o>,</span><span class=mi>12</span><span class=o>,</span><span class=mi>33</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>list</span> <span class=o>=</span> <span class=n>integerStream</span><span class=o>.</span><span class=na>filter</span><span class=o>(</span><span class=n>s</span> <span class=o>-&gt;</span> <span class=n>s</span><span class=o>.</span><span class=na>intValue</span><span class=o>()&gt;</span><span class=mi>7</span><span class=o>).</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>toList</span><span class=o>());</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>很多同学表示看不太懂这个 <code>Collector</code>是怎么一个意思，来，我们看下面这段代码，这是 <code>collect</code>的另一个重载方法，你可以理解为它的参数是按顺序执行的，这样就清楚了，这就是个 ArrayList 从创建到调用 <code>addAll</code>方法的一个过程。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>collect</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>Stream</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>integerStream</span> <span class=o>=</span> <span class=n>Stream</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=mi>1</span><span class=o>,</span><span class=mi>2</span><span class=o>,</span><span class=mi>5</span><span class=o>,</span><span class=mi>7</span><span class=o>,</span><span class=mi>8</span><span class=o>,</span><span class=mi>12</span><span class=o>,</span><span class=mi>33</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>list</span> <span class=o>=</span> <span class=n>integerStream</span><span class=o>.</span><span class=na>filter</span><span class=o>(</span><span class=n>s</span> <span class=o>-&gt;</span> <span class=n>s</span><span class=o>.</span><span class=na>intValue</span><span class=o>()&gt;</span><span class=mi>7</span><span class=o>).</span><span class=na>collect</span><span class=o>(</span><span class=n>ArrayList</span><span class=o>::</span><span class=k>new</span><span class=o>,</span> <span class=n>ArrayList</span><span class=o>::</span><span class=n>add</span><span class=o>,</span>
</span></span><span class=line><span class=cl>            <span class=n>ArrayList</span><span class=o>::</span><span class=n>addAll</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>我们在自定义 <code>Collector</code>的时候其实也是这个逻辑，不过我们根本不用自定义， <code>Collectors</code>已经为我们提供了很多拿来即用的收集器。比如我们经常用到<code>Collectors.toList()</code>、<code>Collectors.toSet()</code>、<code>Collectors.toMap()</code>。另外还有比如<code>Collectors.groupingBy()</code>用来分组，比如下面这个例子，按照 userId 字段分组，返回以 userId 为key，List 为value 的 Map，或者返回每个 key 的个数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 返回 userId:List&lt;User&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Map</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span><span class=n>List</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;&gt;</span> <span class=n>map</span> <span class=o>=</span> <span class=n>user</span><span class=o>.</span><span class=na>stream</span><span class=o>().</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>groupingBy</span><span class=o>(</span><span class=n>User</span><span class=o>::</span><span class=n>getUserId</span><span class=o>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 返回 userId:每组个数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Map</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span><span class=n>Long</span><span class=o>&gt;</span> <span class=n>map</span> <span class=o>=</span> <span class=n>user</span><span class=o>.</span><span class=na>stream</span><span class=o>().</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>groupingBy</span><span class=o>(</span><span class=n>User</span><span class=o>::</span><span class=n>getUserId</span><span class=o>,</span><span class=n>Collectors</span><span class=o>.</span><span class=na>counting</span><span class=o>()));</span>
</span></span></code></pre></div><h3 id=toarray>toArray</h3><p><code>collection</code>是返回列表、map 等，<code>toArray</code>是返回数组，有两个重载，一个空参数，返回的是 <code>Object[]</code>。</p><p>另一个接收一个 <code>IntFunction&lt;R></code>类型参数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@FunctionalInterface</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>IntFunction</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Applies this function to the given argument.
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * @param value the function argument
</span></span></span><span class=line><span class=cl><span class=cm>     * @return the function result
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=n>R</span> <span class=nf>apply</span><span class=o>(</span><span class=kt>int</span> <span class=n>value</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>比如像下面这样使用，参数是 <code>User[]::new</code>也就是new 一个 User 数组，长度为最后的 Stream 长度。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>toArray</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=n>users</span> <span class=o>=</span> <span class=n>getUserData</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>Stream</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=n>stream</span> <span class=o>=</span> <span class=n>users</span><span class=o>.</span><span class=na>stream</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>User</span><span class=o>[]</span> <span class=n>userArray</span> <span class=o>=</span> <span class=n>stream</span><span class=o>.</span><span class=na>filter</span><span class=o>(</span><span class=n>user</span> <span class=o>-&gt;</span> <span class=n>user</span><span class=o>.</span><span class=na>getGender</span><span class=o>().</span><span class=na>equals</span><span class=o>(</span><span class=mi>0</span><span class=o>)</span> <span class=o>&amp;&amp;</span> <span class=n>user</span><span class=o>.</span><span class=na>getAge</span><span class=o>()</span> <span class=o>&gt;</span> <span class=mi>50</span><span class=o>).</span><span class=na>toArray</span><span class=o>(</span><span class=n>User</span><span class=o>[]::</span><span class=k>new</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=reduce>reduce</h3><p>它的作用是每次计算的时候都用到上一次的计算结果，比如求和操作，前两个数的和加上第三个数的和，再加上第四个数，一直加到最后一个数位置，最后返回结果，就是 <code>reduce</code>的工作过程。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>reduce</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>Stream</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>integerStream</span> <span class=o>=</span> <span class=n>Stream</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=mi>1</span><span class=o>,</span><span class=mi>2</span><span class=o>,</span><span class=mi>5</span><span class=o>,</span><span class=mi>7</span><span class=o>,</span><span class=mi>8</span><span class=o>,</span><span class=mi>12</span><span class=o>,</span><span class=mi>33</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Integer</span> <span class=n>sum</span> <span class=o>=</span> <span class=n>integerStream</span><span class=o>.</span><span class=na>reduce</span><span class=o>(</span><span class=mi>0</span><span class=o>,(</span><span class=n>x</span><span class=o>,</span><span class=n>y</span><span class=o>)-&gt;</span><span class=n>x</span><span class=o>+</span><span class=n>y</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>sum</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>另外 <code>Collectors</code>好多方法都用到了 <code>reduce</code>，比如 <code>groupingBy</code>、<code>minBy</code>、<code>maxBy</code>等等。</p><h2 id=并行-stream>并行 Stream</h2><p>Stream 本质上来说就是用来做数据处理的，为了加快处理速度，Stream API 提供了并行处理 Stream 的方式。通过 <code>users.parallelStream()</code>或者<code>users.stream().parallel()</code> 的方式来创建并行 Stream 对象，支持的 API 和普通 Stream 几乎是一致的。</p><p>并行 Stream 默认使用 <code>ForkJoinPool</code>线程池，当然也支持自定义，不过一般情况下没有必要。ForkJoin 框架的分治策略与并行流处理正好契合。</p><p>虽然并行这个词听上去很厉害，但并不是所有情况使用并行流都是正确的，很多时候完全没这个必要。</p><p><strong>什么情况下使用或不应使用并行流操作呢？</strong></p><ol><li>必须在多核 CPU 下才使用并行 Stream，听上去好像是废话。</li><li>在数据量不大的情况下使用普通串行 Stream 就可以了，使用并行 Stream 对性能影响不大。</li><li>CPU 密集型计算适合使用并行 Stream，而 IO 密集型使用并行 Stream 反而会更慢。</li><li>虽然计算是并行的可能很快，但最后大多数时候还是要使用 <code>collect</code>合并的，如果合并代价很大，也不适合用并行 Stream。</li><li>有些操作，比如 limit、 findFirst、forEachOrdered 等依赖于元素顺序的操作，都不适合用并行 Stream。</li></ol><h2 id=最后>最后</h2><p>Java 25 周岁了，有多少同学跟我一样在用 Java 8，还有多少同学再用更早的版本，请说出你的故事。</p></article><h4>相关文章</h4><dl class=row><dd class=col-md-9><a href=/category/java/Java-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%97/>Java 字符串常量池漫游指南（图文并茂）</a></dd><dd class=col-md-9><a href=/category/java/JDK17/>新项目为什么决定用 JDK 17了</a></dd><dd class=col-md-9><a href=/category/java/Graalvm/>过两年 JVM 可能就要被GraalVM替代了</a></dd><dd class=col-md-9><a href=/category/java/JVM-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E9%A2%84%E9%98%B2/>JVM 内存溢出的原因及预防</a></dd><dd class=col-md-9><a href=/category/java/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E8%87%AA%E5%B7%B1%E7%9A%84-JDK/>手把手教你编译属于自己的 JDK</a></dd></dl><div class=author-card><div class=underline></div><div class=author-box><div class=qr-author-image><a href=https://www.moonkite.cn><img src=/images/person.jpg alt=风筝></a></div><div class=author-content><p class=author-title>作者</p><p class=author-name>风筝</p><p class=author-desc>古时的风筝，一个平庸的程序员，主语言 Java，第二语言 Python，其实学 Python 的时间比 Java 还要早。喜欢写博客，写博客的过程能加深自己对一个知识点的理解，同时还可以分享给他人。喜欢做一些小东西，所以也会一些前端的东西，React、JavaScript、CSS 都会一些，做一些小工具还够用。</p></div></div></div><script src=https://utteranc.es/client.js repo=huzhicheng/blog-comment issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></main><div class="footer gradient-2"><div class="container footer-container"><div class=row><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>网站地图</div><ul class=list-unstyled><li><a href=https://moonkite.cn/tags/>标签</a></li><li><a href=https://moonkite.cn/categories/>分类</a></li><li><a rel=alternate type=application/rss+xml href=https://moonkite.cn/index.xml><i class="fas fa-rss-square"></i> RSS订阅</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>社群</div><ul class=list-unstyled><li><a href=https://github.com/huzhicheng rel=noopener target=_blank>GitHub</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>友链</div><ul class=list-unstyled><li><a href=https://github.com/huzhicheng rel=noopener target=_blank>关于我</a></li></ul></div><div class="col-xs-12 col-sm-3 col-md-3 col-lg-3"><p class="pull-right text-right"><small><em>Proudly powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo</a></em></small><br><small><em>Theme - <a href=https://github.com/shaform/hugo-theme-den rel=noopener target=_blank>Den</a></em></small><br><small>&copy;
风筝
2023</small></p></div></div><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?e417ddf834c7bb7411207e1fa09815aa",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-C714TFXRD4"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-C714TFXRD4")</script><div class=busuanzi-footer><span id=busuanzi_container_site_pv>本站总访问量<span id=busuanzi_value_site_pv></span>次</span>
<span id=busuanzi_container_site_uv>本站访客数<span id=busuanzi_value_site_uv></span>人次</span></div></div></div><script src=https://code.jquery.com/jquery-3.3.1.slim.min.js integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap_4.1.3_js_bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script>
<script>$(document).ready(function(){$("#load_disqus").length&&$(window).scroll(function(){if($("#load_disqus").length){var e=$("#load_disqus").offset().top,t=$(window).scrollTop(),n=t+$(window).height();t<e&&e<n&&load_disqus()}})})</script></body></html>