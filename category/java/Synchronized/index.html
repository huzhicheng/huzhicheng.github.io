<!doctype html><html lang=zh-cn itemscope itemtype=http://schema.org/WebPage><head><meta name=generator content="Hugo 0.113.0"><meta charset=utf-8><title>synchronized 到底该不该用？ · 古时的风筝</title><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=description content="在多线程环境中，锁的使用是避免不了的，使用锁时候有多种锁供我们选择，比如 ReentrantLock、CountDownLatch等等，但是作"><meta name=keywords content="Hugo,theme,编程,java,ChatGPT,程序员,开发"><link rel=canonical href=https://moonkite.cn/category/java/Synchronized/><link rel=icon href=https://moonkite.cn/images/photo.png><link rel=stylesheet href=https://cdn.usebootstrap.com/bootstrap/4.1.3/css/bootstrap.min.css><link rel=stylesheet href=https://moonkite.cn/css/den.css><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><meta name=referrer content="no-referrer-when-downgrade"><meta property="og:title" content="synchronized 到底该不该用？"><meta property="og:description" content="在多线程环境中，锁的使用是避免不了的，使用锁时候有多种锁供我们选择，比如 ReentrantLock、CountDownLatch等等，但是作"><meta property="og:type" content="article"><meta property="og:url" content="https://moonkite.cn/category/java/Synchronized/"><meta property="article:section" content="category"><meta property="article:published_time" content="2021-02-11T08:56:23+08:00"><meta property="article:modified_time" content="2021-02-11T08:56:23+08:00"><meta itemprop=name content="synchronized 到底该不该用？"><meta itemprop=description content="在多线程环境中，锁的使用是避免不了的，使用锁时候有多种锁供我们选择，比如 ReentrantLock、CountDownLatch等等，但是作"><meta itemprop=datePublished content="2021-02-11T08:56:23+08:00"><meta itemprop=dateModified content="2021-02-11T08:56:23+08:00"><meta itemprop=wordCount content="3970"><meta itemprop=keywords content="Java,JDK,synchronized,Java多线程,"><meta name=twitter:card content="summary"><meta name=twitter:title content="synchronized 到底该不该用？"><meta name=twitter:description content="在多线程环境中，锁的使用是避免不了的，使用锁时候有多种锁供我们选择，比如 ReentrantLock、CountDownLatch等等，但是作"></head><body><div class=header-container style=background:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2)),url(https://moonkite.cn/images/background.png);background-position:top;background-size:cover><div class=container><nav class="header-nav navbar navbar-expand-md navbar-dark light-dark"><div class="header-logo navbar-brand"><a class=float-left href=https://moonkite.cn/></a></div><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarNav aria-controls=navbarNav aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="nav-menu collapse navbar-collapse" id=navbarNav><ul class=navbar-nav><li class=nav-item><a href=https://moonkite.cn/ class=nav-link><i class="fas fad fa-h-square"></i>主页</a></li><li class=nav-item><a href=https://moonkite.cn/category/notes/ class=nav-link><i class='fas fa-yin-yang'></i>生活随笔</a></li><li class=nav-item><a href=javascript:void(0) class=nav-link><i class='fas fa-laptop-code'></i>技术文章</a><div class=sub-dropdown-menu><a class=sub-nav-link href=https://moonkite.cn/category/java><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 48 48"><path fill="#f44336" d="M23.65 24.898c-.998-1.609-1.722-2.943-2.725-5.455C19.229 15.2 31.24 11.366 26.37 3.999c2.111 5.089-7.577 8.235-8.477 12.473-.823 3.898 5.752 8.426 5.757 8.426z"/><path fill="#f44336" d="M23.878 17.27c-.192 2.516 2.229 3.857 2.299 5.695.056 1.496-1.447 2.743-1.447 2.743s2.728-.536 3.579-2.818c.945-2.534-1.834-4.269-1.548-6.298.267-1.938 6.031-5.543 6.031-5.543S24.311 11.611 23.878 17.27z"/><g><path fill="#1565c0" d="M32.084 25.055c1.754-.394 3.233.723 3.233 2.01.0 2.901-4.021 5.643-4.021 5.643s6.225-.742 6.225-5.505c0-3.15-3.057-3.937-5.437-2.148zm-2.955 2.34s1.941-1.383 2.458-1.902c-4.763 1.011-15.638 1.147-15.638.269.0-.809 3.507-1.638 3.507-1.638s-7.773-.112-7.773 2.181C11.683 28.695 21.858 28.866 29.129 27.395z"/><path fill="#1565c0" d="M27.935 29.571c-4.509 1.499-12.814 1.02-10.354-.993-1.198.0-2.974.963-2.974 1.889.0 1.857 8.982 3.291 15.63.572l-2.302-1.468z"/><path fill="#1565c0" d="M18.686 32.739c-1.636.0-2.695 1.054-2.695 1.822.0 2.391 9.76 2.632 13.627.205l-2.458-1.632C24.271 34.404 17.014 34.579 18.686 32.739z"/><path fill="#1565c0" d="M36.281 36.632c0-.936-1.055-1.377-1.433-1.588 2.228 5.373-22.317 4.956-22.317 1.784.0-.721 1.807-1.427 3.477-1.093l-1.42-.839C11.26 34.374 9 35.837 9 37.017 9 42.52 36.281 42.255 36.281 36.632z"/><path fill="#1565c0" d="M39 38.604c-4.146 4.095-14.659 5.587-25.231 3.057C24.341 46.164 38.95 43.628 39 38.604z"/></g></svg>&nbsp;可爱的 Java</a>
<a class=sub-nav-link href=https://moonkite.cn/category/SpringCloud><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 48 48"><path fill="#8bc34a" d="M43.982 23.635c.069-4.261-.891-9.328-2.891-15.273L39.523 3.7l-2.13 4.433c-.114.237-.244.469-.38.698C33.514 5.827 28.974 4 24 4 12.954 4 4 12.954 4 24s8.954 20 20 20 20-8.954 20-20C44 23.877 43.984 23.758 43.982 23.635z"/><path fill="#fff" d="M39.385 32.558C36.262 36.86 30.734 37.091 25.531 37H18.75h-1.938c4.428-1.593 7.063-1.972 9.754-3.4 5.068-2.665 10.078-8.496 11.121-14.562-1.93 5.836-7.779 10.85-13.109 12.889-3.652 1.393-10.248 2.745-10.248 2.745l-.267-.145C9.573 32.268 9.437 22.214 17.6 18.968c3.574-1.423 6.993-.641 10.854-1.593 4.122-1.012 8.89-4.208 10.83-8.375C41.456 15.667 44.07 26.106 39.385 32.558zM15.668 38.445C15.386 38.795 14.955 39 14.505 39c-.823.0-1.495-.677-1.495-1.5s.677-1.5 1.495-1.5c.341.0.677.118.941.336C16.086 36.855 16.186 37.805 15.668 38.445z"/></svg>&nbsp; Spring Cloud 系列</a></div></li><li class=nav-item><a href=https://moonkite.cn/category/network class=nav-link><i class="fas fa-network-wired"></i>轻解计算机网络</a></li><li class=nav-item><a href=https://moonkite.cn/category/product class=nav-link><i class="fas fab fa-medapps"></i>我的产品</a></li></ul></div></nav></div><div class="container header-wrapper"><div class=row><div class=col-lg-12><div class=header-content><h1 class=header-title>synchronized 到底该不该用？</h1><p class=header-date>作者：
风筝 /
2021-02-11<div class=header-underline></div><div class=header-date>&nbsp·&nbsp
  <span id=busuanzi_container_page_pv>本文被阅读<span id=busuanzi_value_page_pv></span>次</span></div><div class=clearfix></div><p class="float-right header-tags"><i class="fas fa-tags" aria-hidden=true></i>
<a href=https://moonkite.cn/tag/Java/>Java</a>,
<a href=https://moonkite.cn/tag/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/>Java多线程</a>,
<a href=https://moonkite.cn/tag/JDK/>JDK</a>,
<a href=https://moonkite.cn/tag/synchronized/>synchronized</a></p></div></div></div></div></div><main><div class="container content"><article><p>在多线程环境中，锁的使用是避免不了的，使用锁时候有多种锁供我们选择，比如 <code>ReentrantLock</code>、<code>CountDownLatch</code>等等，但是作为 Java 开发者来说，刚刚接触多线程的时候，最早接触和使用的恐怕非 <code>synchronized</code>莫属了。那你真的了解<code>synchronized</code>吗，今天我们就从以下几个方面彻底搞懂 <code>synchronized</code>。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/092f3df261ec4777a60a1fad596f25ec~tplv-k3u1fbpfcp-zoom-1.image alt></p><p>首先有一点要说明一下，各位可能或多或少都听过这样的说法：“synchronized 的性能不行，比显式锁差很多，开发中还是要慎用。”</p><p>大可不必有这样的顾虑，要说在 JDK 1.6 之前，synchronized 的性能确实有点差，但是 JDK 1.6 之后，JDK 开发团队已经持续对 synchronized 做了性能优化，其性能已经与其他显式锁基本没有差距了。所以，在考虑是不是使用 <code>synchronized</code>的时候，只需要根据场景是否合适来决定，性能问题不用作为衡量标准。</p><h2 id=使用方法>使用方法</h2><p>synchronized 是一个关键字，它的一个明显特点就是使用简单，一个关键字搞定。它可以在一个方法上使用，也可以在一个方法中的某些代码块上使用，非常方便。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>SyncLock</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  	<span class=kd>private</span> <span class=n>Object</span> <span class=n>lock</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Object</span><span class=o>();</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 直接在方法上加关键字
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>synchronized</span> <span class=kt>void</span> <span class=nf>methodLock</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>().</span><span class=na>getName</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 在代码块上加关键字，锁住当前实例
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>codeBlockLock</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>synchronized</span> <span class=o>(</span><span class=k>this</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>().</span><span class=na>getName</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  	<span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 在代码块上加关键字,锁住一个变量
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>codeBlockLock2</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>synchronized</span> <span class=o>(</span><span class=n>lock</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>().</span><span class=na>getName</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>具体的使用可以参考我之前写的这篇文章：<a href=https://juejin.im/post/6844904116590755853>类锁和对象锁到底有什么区别</a></p><p>依靠 JVM 中的 monitorenter 和 monitorexit 指令控制。通过 <code>javap -v</code>命令可以看到前面的实例代码中对 synchronized 关键字在字节码层面的处理，对于在代码块上加 synchronized 关键字的情况，会通过 <code>monitorenter</code>和<code>monitorexit</code>指令来表示同步的开始和退出标识。而在方法上加关键字的情况，会用 <code>ACC_SYNCHRONIZED</code>作为方法标识，这是一种隐式形式，底层原理都是一样的。</p><pre tabindex=0><code class=language-idl data-lang=idl> public synchronized void methodLock();
    descriptor: ()V
    flags: ACC_PUBLIC, ACC_SYNCHRONIZED
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: invokestatic  #3                  // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;
         6: invokevirtual #4                  // Method java/lang/Thread.getName:()Ljava/lang/String;
         9: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        12: return
      LineNumberTable:
        line 12: 0
        line 13: 12

  public void codeBlockLock();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=1
         0: aload_0
         1: dup
         2: astore_1
         3: monitorenter     #
         4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
         7: invokestatic  #3                  // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;
        10: invokevirtual #4                  // Method java/lang/Thread.getName:()Ljava/lang/String;
        13: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        16: aload_1
        17: monitorexit
        18: goto          26
        21: astore_2
        22: aload_1
        23: monitorexit
        24: aload_2
        25: athrow
        26: return
</code></pre><h2 id=对象布局>对象布局</h2><p>为什么介绍 synchronized 要说到对象头呢，这和它的锁升级过程有关系，具体的锁升级过程稍后会讲到，作为锁升级过程的数据支撑，必须要掌握对象头的结构才能了解锁升级的完整过程。</p><p>在 Java 中，任何的对象实例的内存布局都分为对象头、对象实例数据和对齐填充数据三个部分，其中对象头又包括 MarkWord 和 类型指针。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee2b5be003b2478ba6df316c71dae0f0~tplv-k3u1fbpfcp-zoom-1.image alt></p><p>**对象实例数据：**这部分就是对象的实际数据。</p><p>**对齐填充：**因为 HotSpot 虚拟机内存管理要求对象的大小必须是8字节的整数倍，而对象头正好是8个字节的整数倍，但是实例数据不一定，所以需要对齐填充补全。</p><p><strong>对象头：</strong></p><p>*Klass 指针：*对象头中的 Klass 指针是用来指向对象所属类型的，一个类实例究竟属于哪个类，需要有地方记录，就在这里记。</p><p>*MarkWord:*还有一部分就是和 synchronized 紧密相关的 MarkWord 了，主要用来存储对象自身的运行时数据，如hashcode、gc 分代年龄等信息。 MarkWord 的位长度为 JVM 的一个 Word 大小，32位 JVM 的大小为32位，64位JVM的大小为64位。</p><p>下图是 64 位虚拟机下的 MarkWord 结构说明，根据对象锁状态不同，某些比特位代表的含义会动态的变化，之所以要这么设计，是因为不想让对象头占用过大的空间，如果为每一个标示都分配固定的空间，那对象头占用的空间将会比较大。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97faedd0871345e6b227136510bda1b6~tplv-k3u1fbpfcp-zoom-1.image alt></p><p>*数组长度：*要说明一下，如果是数组对象的话， 由于数组无法通过本身内容求得自身长度，所以需要在对象头中记录数组的长度。</p><h3 id=源码中的定义>源码中的定义</h3><p>追根溯源，对象在 JVM 中是怎么定义的呢？打开 JVM 源码，找到其中对象的定义文件，可以看到关于前面说的对象头的定义。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>oopDesc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>friend</span> <span class=k>class</span> <span class=nc>VMStructs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>friend</span> <span class=k>class</span> <span class=nc>JVMCIVMStructs</span><span class=p>;</span>
</span></span><span class=line><span class=cl> <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>volatile</span> <span class=n>markOop</span> <span class=n>_mark</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>union</span> <span class=nc>_metadata</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Klass</span><span class=o>*</span>      <span class=n>_klass</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>narrowKlass</span> <span class=n>_compressed_klass</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=n>_metadata</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>  
</span></span></code></pre></div><p>oop 是对象的基础类定义，也就是或 Java 中的 Object 类的定义其实就是用的 oop，而任何类都由 Object 继承而来。oopDesc 只是 oop 的一个别名而已。</p><p>可以看到里面有关于 Klass 的声明，还有 markOop 的声明，这个 markOop 就是对应上面说到的 MarkWord。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>markOopDesc</span><span class=o>:</span> <span class=k>public</span> <span class=n>oopDesc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Conversion
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>uintptr_t</span> <span class=n>value</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=p>(</span><span class=n>uintptr_t</span><span class=p>)</span> <span class=k>this</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Constants
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>enum</span> <span class=p>{</span> <span class=n>age_bits</span>                 <span class=o>=</span> <span class=mi>4</span><span class=p>,</span> <span class=c1>//分代年龄
</span></span></span><span class=line><span class=cl><span class=c1></span>         <span class=n>lock_bits</span>                <span class=o>=</span> <span class=mi>2</span><span class=p>,</span> <span class=c1>//锁标志位
</span></span></span><span class=line><span class=cl><span class=c1></span>         <span class=n>biased_lock_bits</span>         <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=c1>//偏向锁标记  
</span></span></span><span class=line><span class=cl><span class=c1></span>         <span class=n>max_hash_bits</span>            <span class=o>=</span> <span class=n>BitsPerWord</span> <span class=o>-</span> <span class=n>age_bits</span> <span class=o>-</span> <span class=n>lock_bits</span> <span class=o>-</span> <span class=n>biased_lock_bits</span><span class=p>,</span>
</span></span><span class=line><span class=cl>         <span class=n>hash_bits</span>                <span class=o>=</span> <span class=n>max_hash_bits</span> <span class=o>&gt;</span> <span class=mi>31</span> <span class=o>?</span> <span class=mi>31</span> <span class=o>:</span> <span class=n>max_hash_bits</span><span class=p>,</span>
</span></span><span class=line><span class=cl>         <span class=n>cms_bits</span>                 <span class=o>=</span> <span class=n>LP64_ONLY</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=n>NOT_LP64</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span>
</span></span><span class=line><span class=cl>         <span class=n>epoch_bits</span>               <span class=o>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>  
</span></span></code></pre></div><p>以上代码只是截取了其中一部分，可以看到其中有关于分代年龄、锁标志位、偏向锁的定义。</p><p>虽然源码咱也看不太懂，但是当我看到它们的时候，恍惚之间，内心会感叹到，原来如此。有种宇宙之间，已尽在我掌控之中的感觉。过两天才发现，原来只是一种心理安慰。但是，已经不重要了。</p><h5 id=提示>提示</h5><p>如果你有兴趣翻源码看看，这部分的定义在 <code>/src/hotspot/share/oops</code>目录下，能告诉你的就这么多了。</p><h2 id=锁升级>锁升级</h2><p>JDK 1.6 之后，对 synchronized 做了优化，主要就是 CAS 自旋、锁消除、锁膨胀、轻量级锁、偏向锁等，这些技术都是为了在线程之间更高效地共享数据及解决竞争问题，从而提高程序的执行效率，进而产生了一套锁升级的规则。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55f99fe47ee24cb8b8f1b199fdd1227d~tplv-k3u1fbpfcp-zoom-1.image alt></p><p>synchronized 的锁升级过程是通过动态改变对象 MarkWord 各个标志位来表示当前的锁状态的，那修改的是哪个对象的 MarkWord 呢，看上面的代码中，synchronized 关键字是加在 lock 变量上的，那就会控制 lock 的 MarkWord。如果是 <code>synchronized(this)</code>或者在方法上加关键字，那控制的就是当前实例对象的 MarkWord。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41c21d10f8cc4060a6eca371abd5665d~tplv-k3u1fbpfcp-zoom-1.image alt></p><p>synchronized 的核心准则概括起来大概是这个样子。</p><blockquote><ol><li>能不加锁就不加锁。</li><li>能偏向就尽量偏向。</li><li>能加轻量级锁就不用重量级锁。</li></ol></blockquote><h3 id=无锁转向偏向锁>无锁转向偏向锁</h3><p>偏向锁的意思是说，这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a1a80865207415793b23d311dcbdb92~tplv-k3u1fbpfcp-zoom-1.image alt></p><p>当线程尝试获取锁对象的时候，先检查 MarkWord 中的线程ID 是否为空。如果为空，则虚拟机会将 MarkWord 中的偏向标记设置为 1，锁标记位为 01。同时，使用 CAS 操作尝试将线程ID记录到 MarkWord 中，如果 CAS 操作成功，那之后这个持有偏向锁的线程再次进入相关同步块的时候，将不需要再进行任何的同步操作。</p><p>如果检查线程ID不为空，并且不为当前线程ID，或者进行 CAS 操作设置线程ID失败的情况下，都要撤销偏向状态，这时候就要升级为偏向锁了。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ac0b7b979654fa48964ce54ee849827~tplv-k3u1fbpfcp-zoom-1.image alt></p><h3 id=偏向锁升级到轻量级锁>偏向锁升级到轻量级锁</h3><p>当多个线程竞争锁时，偏向锁会向轻量级锁状态升级。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/511451a5100c4322a950f44a2b709def~tplv-k3u1fbpfcp-zoom-1.image alt></p><p>首先，线程尝试获取锁的时候，先检查锁标志为是否为 01 状态，也就是未锁定状态。</p><p>如果是未锁定状态，那就在当前线程的栈帧中建立一个锁记录（Lock Record）区域，这个区域存储 MarkWord 的拷贝。</p><p>之后，尝试用 CAS 操作将 MarkWord 更新为指向锁记录的指针（就是上一步在线程栈帧中的 MarkWord 拷贝），如果 CAS 更新成功了，那偏向锁正式升级为轻量级锁，锁标志为变为 00。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6bd791f6550405c8a9ff593ab1a5cfa~tplv-k3u1fbpfcp-zoom-1.image alt></p><p>如果 CAS 更新失败了，那检查 MarkWord 是否已经指向了当前线程的锁记录，如果已经指向自己，那表示已经获取了锁，否则，轻量级锁要膨胀为重量级锁。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5dde0d41b19f4598b5f33d0754ade4c8~tplv-k3u1fbpfcp-zoom-1.image alt></p><h3 id=轻量级锁升级到重量级锁>轻量级锁升级到重量级锁</h3><p>上面的图中已经有了关于轻量级锁膨胀为重量级锁的逻辑。当锁已经是轻量级锁的状态，再有其他线程来竞争锁，此时轻量级锁就会膨胀为重量级锁。</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61e3f97077c24412a9a3d9269a3fcf58~tplv-k3u1fbpfcp-zoom-1.image alt></p><h3 id=重量级锁的实现原理>重量级锁的实现原理</h3><p>为什么叫重量级锁呢？在重量级锁中没有竞争到锁的对象会 park 被挂起，退出同步块时 unpark 唤醒后续线程。唤醒操作涉及到操作系统调度会有额外的开销，这就是它被称为重量级锁的原因。</p><p>当锁升级为重量级锁的时候，MarkWord 会指向重量级锁的指针 monitor，monitor 也称为管程或监视器锁， 每个对象都存在着一个 monitor 与之关联 ，对象与其 monitor 之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。</p><p>ObjectMonitor中有两个队列，_WaitSet 和 _EntryList，用来保存 ObjectWaiter 对象列表( 每个等待锁的线程都会被封装成 ObjectWaiter对象)，_owner 指向持有 ObjectMonitor 对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把 monitor 中的 owner 变量设置为当前线程同时 monitor 中的计数器 count 加1，若线程调用 wait() 方法，将释放当前持有的 monitor，owner 变量恢复为 null，count 自减1，同时该线程进入 WaitSet 集合中等待被唤醒。若当前线程执行完毕也将释放 monitor(锁)并复位变量的值，以便其他线程进入获取 monitor(锁)</p><p>monitor 对象存在于每个 Java 对象的对象头中(存储的指针的指向)，synchronized 锁便是通过这种方式获取锁的，也是为什么 Java 中任意对象可以作为锁的原因，同时也是notify/notifyAll/wait等方法存在于顶级对象Object中的原因。</p><h3 id=适用场景>适用场景</h3><h4 id=偏向锁>偏向锁</h4><p><strong>优点：</strong> 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</p><p><strong>缺点：</strong> 如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</p><p><strong>适用场景：</strong> 适用于只有一个线程访问同步块场景。</p><p>有的同学可能会有疑惑，适用于只有一个线程的场景是什么鬼，一个线程还加什么锁。</p><p>要知道，有些锁不是你想不加就不加的。比方说你在使用一个第三方库，调用它里面的一个 API，你虽然知道是在单线程下使用，并不需要加锁，但是第三方库不知道啊，你调用的这个 API 正好是用 synchronized 做了同步的。这种情况下，使用偏向锁可以达到最高的性能。</p><h4 id=轻量级锁>轻量级锁</h4><p><strong>优点：</strong> 竞争的线程不会阻塞，提高了程序的响应速度。</p><p><strong>缺点：</strong> 如果始终得不到锁竞争的线程使用自旋会消耗CPU。</p><p><strong>适用场景：</strong> 追求响应时间。同步块执行速度非常快。</p><h4 id=重量级锁>重量级锁</h4><p><strong>优点：</strong> 线程竞争不使用自旋，不会消耗CPU。</p><p><strong>缺点：</strong> 线程阻塞，响应时间缓慢。</p><p><strong>适用场景：</strong> 追求吞吐量。同步块执行速度较长。</p><h2 id=总结>总结</h2><p>1、synchronized 是可重入锁，是一个非公平的可重入锁，所以如果场景比较复杂的情况，还是要考虑其他的显式锁，比如 <code>Reentrantlock</code>、<code>CountDownLatch</code>等。</p><p>2、synchronized 有锁升级的过程，当有线程竞争的情况下，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在有竞争的情况下，synchronized 会有一定的性能损耗。</p></article><h4>相关文章</h4><dl class=row><dd class=col-md-9><a href=/category/java/%E7%B1%BB%E9%94%81%E5%92%8C%E5%AF%B9%E8%B1%A1%E9%94%81%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/>类锁和对象锁到底有什么区别</a></dd><dd class=col-md-9><a href=/category/java/Java-%E8%B0%83%E5%BC%8F%E7%83%AD%E9%83%A8%E7%BD%B2JVM-%E8%83%8C%E5%90%8E%E7%9A%84%E6%94%AF%E6%8C%81%E8%80%85-Java-Agent/>Java 调式、热部署、JVM 背后的支持者 Java Agent</a></dd><dd class=col-md-9><a href=/category/java/Java-%E5%BC%80%E5%8F%91-volatile-%E4%BD%A0%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B/>Java 开发， volatile 你必须了解一下</a></dd><dd class=col-md-9><a href=/category/SpringCloud/0-Srping-Cloud-%E5%BC%80%E7%AF%87/>0. Spring Cloud 是什么</a></dd><dd class=col-md-9><a href=/category/SpringCloud/1-Spring-Cloud-Eureka-%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/>1. Spring Cloud Eureka 实现服务注册与发现</a></dd></dl><div class=author-card><div class=underline></div><div class=author-box><div class=qr-author-image><a href=https://www.moonkite.cn><img src=/images/person.jpg alt=风筝></a></div><div class=author-content><p class=author-title>作者</p><p class=author-name>风筝</p><p class=author-desc>古时的风筝，一个平庸的程序员，主语言 Java，第二语言 Python，其实学 Python 的时间比 Java 还要早。喜欢写博客，写博客的过程能加深自己对一个知识点的理解，同时还可以分享给他人。喜欢做一些小东西，所以也会一些前端的东西，React、JavaScript、CSS 都会一些，做一些小工具还够用。</p></div></div></div><script src=https://utteranc.es/client.js repo=huzhicheng/blog-comment issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></main><div class="footer gradient-2"><div class="container footer-container"><div class=row><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>网站地图</div><ul class=list-unstyled><li><a href=https://moonkite.cn/tags/>标签</a></li><li><a href=https://moonkite.cn/categories/>分类</a></li><li><a rel=alternate type=application/rss+xml href=https://moonkite.cn/index.xml><i class="fas fa-rss-square"></i> RSS订阅</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>社群</div><ul class=list-unstyled><li><a href=https://github.com/huzhicheng rel=noopener target=_blank>GitHub</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>友链</div><ul class=list-unstyled><li><a href=https://github.com/huzhicheng rel=noopener target=_blank>关于我</a></li></ul></div><div class="col-xs-12 col-sm-3 col-md-3 col-lg-3"><p class="pull-right text-right"><small><em>Proudly powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo</a></em></small><br><small><em>Theme - <a href=https://github.com/shaform/hugo-theme-den rel=noopener target=_blank>Den</a></em></small><br><small>&copy;
风筝
2023</small></p></div></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-C714TFXRD4"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-C714TFXRD4")</script><div class=busuanzi-footer><span id=busuanzi_container_site_pv>本站总访问量<span id=busuanzi_value_site_pv></span>次</span>
<span id=busuanzi_container_site_uv>本站访客数<span id=busuanzi_value_site_uv></span>人次</span></div></div></div><script src=https://code.jquery.com/jquery-3.3.1.slim.min.js integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap_4.1.3_js_bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script>
<script>$(document).ready(function(){$("#load_disqus").length&&$(window).scroll(function(){if($("#load_disqus").length){var e=$("#load_disqus").offset().top,t=$(window).scrollTop(),n=t+$(window).height();t<e&&e<n&&load_disqus()}})})</script></body></html>