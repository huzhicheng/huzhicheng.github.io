<!doctype html><html lang=zh-cn itemscope itemtype=http://schema.org/WebPage><head><meta name=generator content="Hugo 0.115.4"><meta charset=utf-8><title>Java 中的几种线程池，你之前用对了吗 · 古时的风筝</title><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=description content="如果你经常用到线程池，不知道你的用法标准不标准，是否有隐藏的 OOM 风险。不经常用线程池的同学，还有对几种线程的使用不甚了解的同学可以读一下此文。"><meta name=360-site-verification content="e75339f1cfcde17f66f71aaf8b6983e9"><meta name=keywords content="Hugo,theme,编程,java,ChatGPT,程序员,开发"><meta name=google-site-verification content="google57680cd58c46e2f3.html"><link rel=canonical href=https://www.moonkite.cn/category/java/Java-%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%A0%E4%B9%8B%E5%89%8D%E7%94%A8%E5%AF%B9%E4%BA%86%E5%90%97/><link rel=icon href=https://www.moonkite.cn/images/photo.png><link rel=stylesheet href=https://cdn.usebootstrap.com/bootstrap/4.1.3/css/bootstrap.min.css><link rel=stylesheet href=https://www.moonkite.cn/css/den.css><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-tc-webfont@1.0.0/style.css><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><meta name=referrer content="no-referrer-when-downgrade"><meta property="og:title" content="Java 中的几种线程池，你之前用对了吗"><meta property="og:description" content="如果你经常用到线程池，不知道你的用法标准不标准，是否有隐藏的 OOM 风险。不经常用线程池的同学，还有对几种线程的使用不甚了解的同学可以读一下此文。"><meta property="og:type" content="article"><meta property="og:url" content="https://www.moonkite.cn/category/java/Java-%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%A0%E4%B9%8B%E5%89%8D%E7%94%A8%E5%AF%B9%E4%BA%86%E5%90%97/"><meta property="article:section" content="category"><meta property="article:published_time" content="2018-07-12T08:56:23+08:00"><meta property="article:modified_time" content="2018-07-12T08:56:23+08:00"><meta itemprop=name content="Java 中的几种线程池，你之前用对了吗"><meta itemprop=description content="如果你经常用到线程池，不知道你的用法标准不标准，是否有隐藏的 OOM 风险。不经常用线程池的同学，还有对几种线程的使用不甚了解的同学可以读一下此文。"><meta itemprop=datePublished content="2018-07-12T08:56:23+08:00"><meta itemprop=dateModified content="2018-07-12T08:56:23+08:00"><meta itemprop=wordCount content="3117"><meta itemprop=keywords content="Java,JDK,线程池,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java 中的几种线程池，你之前用对了吗"><meta name=twitter:description content="如果你经常用到线程池，不知道你的用法标准不标准，是否有隐藏的 OOM 风险。不经常用线程池的同学，还有对几种线程的使用不甚了解的同学可以读一下此文。"></head><body><div class=header-container style=background:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2)),url(https://www.moonkite.cn/images/background.png);background-position:top;background-size:cover><div class=container><nav class="header-nav navbar navbar-expand-md navbar-dark light-dark"><div class="header-logo navbar-brand"><a class=float-left href=https://www.moonkite.cn/></a></div><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarNav aria-controls=navbarNav aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="nav-menu collapse navbar-collapse" id=navbarNav><ul class=navbar-nav><li class=nav-item><a href=https://www.moonkite.cn/ class=nav-link><i class="fas fad fa-h-square"></i>主页</a></li><li class=nav-item><a href=https://www.moonkite.cn/category/notes class=nav-link><i class='fas fa-yin-yang'></i>生活随笔</a></li><li class=nav-item><a href=javascript:void(0) class=nav-link><i class='fas fa-laptop-code'></i>技术文章</a><div class=sub-dropdown-menu><a class=sub-nav-link href=https://www.moonkite.cn/category/java><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 48 48"><path fill="#f44336" d="M23.65 24.898c-.998-1.609-1.722-2.943-2.725-5.455C19.229 15.2 31.24 11.366 26.37 3.999c2.111 5.089-7.577 8.235-8.477 12.473-.823 3.898 5.752 8.426 5.757 8.426z"/><path fill="#f44336" d="M23.878 17.27c-.192 2.516 2.229 3.857 2.299 5.695.056 1.496-1.447 2.743-1.447 2.743s2.728-.536 3.579-2.818c.945-2.534-1.834-4.269-1.548-6.298.267-1.938 6.031-5.543 6.031-5.543S24.311 11.611 23.878 17.27z"/><g><path fill="#1565c0" d="M32.084 25.055c1.754-.394 3.233.723 3.233 2.01.0 2.901-4.021 5.643-4.021 5.643s6.225-.742 6.225-5.505c0-3.15-3.057-3.937-5.437-2.148zm-2.955 2.34s1.941-1.383 2.458-1.902c-4.763 1.011-15.638 1.147-15.638.269.0-.809 3.507-1.638 3.507-1.638s-7.773-.112-7.773 2.181C11.683 28.695 21.858 28.866 29.129 27.395z"/><path fill="#1565c0" d="M27.935 29.571c-4.509 1.499-12.814 1.02-10.354-.993-1.198.0-2.974.963-2.974 1.889.0 1.857 8.982 3.291 15.63.572l-2.302-1.468z"/><path fill="#1565c0" d="M18.686 32.739c-1.636.0-2.695 1.054-2.695 1.822.0 2.391 9.76 2.632 13.627.205l-2.458-1.632C24.271 34.404 17.014 34.579 18.686 32.739z"/><path fill="#1565c0" d="M36.281 36.632c0-.936-1.055-1.377-1.433-1.588 2.228 5.373-22.317 4.956-22.317 1.784.0-.721 1.807-1.427 3.477-1.093l-1.42-.839C11.26 34.374 9 35.837 9 37.017 9 42.52 36.281 42.255 36.281 36.632z"/><path fill="#1565c0" d="M39 38.604c-4.146 4.095-14.659 5.587-25.231 3.057C24.341 46.164 38.95 43.628 39 38.604z"/></g></svg>&nbsp;可爱的 Java</a>
<a class=sub-nav-link href=https://www.moonkite.cn/category/SpringCloud><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 48 48"><path fill="#8bc34a" d="M43.982 23.635c.069-4.261-.891-9.328-2.891-15.273L39.523 3.7l-2.13 4.433c-.114.237-.244.469-.38.698C33.514 5.827 28.974 4 24 4 12.954 4 4 12.954 4 24s8.954 20 20 20 20-8.954 20-20C44 23.877 43.984 23.758 43.982 23.635z"/><path fill="#fff" d="M39.385 32.558C36.262 36.86 30.734 37.091 25.531 37H18.75h-1.938c4.428-1.593 7.063-1.972 9.754-3.4 5.068-2.665 10.078-8.496 11.121-14.562-1.93 5.836-7.779 10.85-13.109 12.889-3.652 1.393-10.248 2.745-10.248 2.745l-.267-.145C9.573 32.268 9.437 22.214 17.6 18.968c3.574-1.423 6.993-.641 10.854-1.593 4.122-1.012 8.89-4.208 10.83-8.375C41.456 15.667 44.07 26.106 39.385 32.558zM15.668 38.445C15.386 38.795 14.955 39 14.505 39c-.823.0-1.495-.677-1.495-1.5s.677-1.5 1.495-1.5c.341.0.677.118.941.336C16.086 36.855 16.186 37.805 15.668 38.445z"/></svg>&nbsp; Spring Cloud 系列</a>
<a class=sub-nav-link href=https://www.moonkite.cn/category/other><img width=20 height=20 src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAADWElEQVR4nO2X30tTYRjH9xd4X2Dsol1EEtJdEFiSF10pldlVaVHEjiFFkKQVQeV0kfSTHdfW1pzKlpZtzXJuzp2pmzPFTdmUTdLJlEAvNKyB8MYzPG/visHZ2jxrnQc+8PCc85zz/e592XkfkUgIIYT4v2OoTVrtVFDTjILaYmgK8YqC2oproalzKZlwKqga3sXTSeFuZts9ykWcNOXnbITcTj67IRQcG1rlE5/dECK3GXcjxC8ADwqMuxGfBMeGVklNaRmZ83z0L3+ZR3ywMBfInJHQqGl07esKAmYjK6hnJoph64Ar/KsOOXmNK6HOTszKtD9uJitGQGSRcQFDiqh1RHAd8nSMWMQSDJgRjLAhrIgxta3lDvaiRlMpxvKvbi3BCNfI+xVRehdRIT2DIUWdejeH65BzMWKd1KO6jqOYLrEE46fp7Bm5bgki0Q0bhhS1t3UM1yHnYuS1XY5Oy0swD8USjPNmQ2aNfO6WO0KjphHgbrc9XNjsirGwdeAY7Vpl65CT15LRYb4VltLHYyzKAwcxgw3Xwr5BQ9D9ll53dz9d+msjfNLfWoO6GstR7/0zCXXBCJMPKxLMl3kkmC9GQsTf706znK3vyKLdhtznL2ISPm5TaqQdro8DeTJxm4EHKDZRGQfy308HtdvAcJY1I3BsII8RpAgwwB41IE9mBAwgR0EcyMlrRcTxB45DgpFUV+RbSIMxuq4kXRFyFl+3VuTeiqBtQYCDqUxqhOyJPCsTjDDCitB5urW8zS2oTSzBxNS7MB3tpeiC4kicO8azCQLJnkB9Me750Xs44b4CmQcjc4SzZwSGHXL42Xy0B6NTHMIDUp36RIJAsmeS2od7vuuKE+4TEUMbDHGZMLLBNrlUV/3u9sYRwH7vkq/nZFmUJaotwfRoK5bk6qoooNRUh9kegOyZkpUtsT3zuvKE+6qev4myKF899nkNTeMTJuWsu6spTBjZ4GzESUv7+R6qmCQ4aeoTZyPDLy4XMTS1xrdo5k/WmDbpflEq4XpJ7XbS1O0+bYvnve7JLNCnkXkZWmrYCfo0Mi9+r7bFA1pAkyjd0Ov1EZVKhQDI034Q3++1mM39H8xmBECeEZV8vNdmtRptAwMojtVqzIjKHH6vEEIIIcrt+AnU4LBcH67z1wAAAABJRU5ErkJggg=="> &nbsp; 杂七杂八</a></div></li><li class=nav-item><a href=https://www.moonkite.cn/category/network class=nav-link><i class="fas fa-network-wired"></i>轻解计算机网络</a></li><li class=nav-item><a href=https://www.moonkite.cn/category/product class=nav-link><i class="fas fab fa-medapps"></i>我的产品</a></li></ul></div></nav></div><div class="container header-wrapper"><div class=row><div class=col-lg-12><div class=header-content><h1 class=header-title>Java 中的几种线程池，你之前用对了吗</h1><p class=header-date>作者：
风筝 /
2018-07-12<div class=header-underline></div><div class=header-date>&nbsp·&nbsp
  <span id=busuanzi_container_page_pv>本文被阅读<span id=busuanzi_value_page_pv></span>次</span></div><div class=clearfix></div><p class="float-right header-tags"><i class="fas fa-tags" aria-hidden=true></i>
<a href=https://www.moonkite.cn/tag/Java/>Java</a>,
<a href=https://www.moonkite.cn/tag/JDK/>JDK</a>,
<a href=https://www.moonkite.cn/tag/%E7%BA%BF%E7%A8%8B%E6%B1%A0/>线程池</a></p></div></div></div></div></div><main><div class="container content"><article><p>如果你经常用到线程池，不知道你的用法标准不标准，是否有隐藏的 OOM 风险。不经常用线程池的同学，还有对几种线程的使用不甚了解的同学可以读一下此文。</p><h2 id=为什么要使用线程池><strong>为什么要使用线程池</strong></h2><p>虽然大家应该都已经很清楚了，但还是说一下。其实归根结底最主要的一个原因就是为了提高性能。</p><p>线程池和数据库连接池是同样的道理，数据库连接池是为了减少连接建立和释放带来的性能开销。而线程池则是为了减少线程建立和销毁带来的性能消耗。</p><p>以 web 项目为例，有以下两种情况：</p><p>1、每次过来一个请求，都要在服务端创建一个新线程来处理请求，请求处理完成销毁线程；</p><p>2、每次过来一个请求，服务端在线程池中直接拿过一个空闲的线程来处理这个请求，处理完成后还给线程池；</p><p>答案是肯定的，肯定是第二种使用线程池的方式性能更好。</p><p>除了性能这个最重要的原因外，线程池的使用可以帮助我们更合理的使用系统资源。还是以 web 项目为例，如果我们在服务端不使用线程池，而是无节制的来一个请求创建一个线程，系统资源将会很快被耗尽。而使用线程池的话，则可以防止这种情况发生，当然这要建立在正确合理的使用线程池的基础上，要固定线程的最大数以及等待队列的大小。</p><h2 id=几种线程池的使用和原理><strong>几种线程池的使用和原理</strong></h2><p>线程池固然好用，但是要建立在正确的使用方式的基础上，如果使用方式不当，同样会出现问题。接下来就介绍一下几种线程池的使用。</p><p>在大名鼎鼎的 J.U.C 包下已经提供了 Executors 类，它已经封装实现了四种创建线程池的方式，它暴露出几个简单的方法供开发者调用。最终都是通过 new ThreadPoolExecutor() ExecutorService 实例，从而得到我们想要的线程池类型。这样做其实有利有弊，好的是我们不用关心那么多参数，只需要简单的指定一两个参数就可以；不好的是，这样一来又屏蔽了很多细节，如果有些参数使用默认的，而开发者又不了解原理的情况下，可能会造成 OOM 等问题。</p><p>很多公司都不建议或者强制不允许直接使用 Executors 类提供的方法来创建线程池，例如阿里巴巴Java开发手册里就明确不允许这样创建线程池，一定要通过 ThreadPoolExecutor(xx,xx,xx&mldr;) 来明确线程池的运行规则，指定更合理的参数。</p><p>先来看一下 ThreadPoolExecutor 的几个参数和它们的意义，先来看一下它最完整参数的重载。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=nf>ThreadPoolExecutor</span><span class=o>(</span><span class=kt>int</span> <span class=n>corePoolSize</span><span class=o>,</span>
</span></span><span class=line><span class=cl>                              <span class=kt>int</span> <span class=n>maximumPoolSize</span><span class=o>,</span>
</span></span><span class=line><span class=cl>                              <span class=kt>long</span> <span class=n>keepAliveTime</span><span class=o>,</span>
</span></span><span class=line><span class=cl>                              <span class=n>TimeUnit</span> <span class=n>unit</span><span class=o>,</span>
</span></span><span class=line><span class=cl>                              <span class=n>BlockingQueue</span><span class=o>&lt;</span><span class=n>Runnable</span><span class=o>&gt;</span> <span class=n>workQueue</span><span class=o>,</span>
</span></span><span class=line><span class=cl>                              <span class=n>ThreadFactory</span> <span class=n>threadFactory</span><span class=o>,</span>
</span></span><span class=line><span class=cl>                              <span class=n>RejectedExecutionHandler</span> <span class=n>handler</span><span class=o>)</span>
</span></span></code></pre></div><p>一共有 7 个参数。</p><p><strong>corePoolSize</strong></p><p>核心线程数，当有任务进来的时候，如果当前线程数还未达到 corePoolSize 个数，则创建核心线程，核心线程有几个特点：</p><p>1、当线程数未达到核心线程最大值的时候，新任务进来，即使有空闲线程，也不会复用，仍然新建核心线程；</p><p>2、核心线程一般不会被销毁，即使是空闲的状态，但是如果通过方法 allowCoreThreadTimeOut(boolean value) 设置为 true 时，超时也同样会被销毁；</p><p>3、生产环境首次初始化的时候，可以调用 prestartCoreThread() 方法来预先创建所有核心线程，避免第一次调用缓慢；</p><p><strong>maximumPoolSize</strong></p><p>除了有核心线程外，有些策略是当核心线程完全无空闲的时候，还会创建一些临时的线程来处理任务，maximumPoolSize 就是核心线程 + 临时线程的最大上限。临时线程有一个超时机制，超过了设置的空闲时间没有事儿干，就会被销毁。</p><p><strong>keepAliveTime</strong></p><p>这个就是上面两个参数里所提到的超时时间，也就是线程的最大空闲时间，默认用于非核心线程，通过 allowCoreThreadTimeOut(boolean value) 方法设置后，也会用于核心线程。</p><p><strong>unit</strong></p><p>这个参数配合上面的 keepAliveTime ，指定超时的时间单位，秒、分、时等。</p><p><strong>workQueue</strong></p><p>等待执行的任务队列，如果核心线程没有空闲的了，新来的任务就会被放到这个等待队列中。这个参数其实一定程度上决定了线程池的运行策略，为什么这么说呢，因为队列分为有界队列和无界队列。</p><p>有界队列：队列的长度有上限，当核心线程满载的时候，新任务进来进入队列，当达到上限，有没有核心线程去即时取走处理，这个时候，就会创建临时线程。（警惕临时线程无限增加的风险）</p><p>无界队列：队列没有上限的，当没有核心线程空闲的时候，新来的任务可以无止境的向队列中添加，而永远也不会创建临时线程。（警惕任务队列无限堆积的风险）</p><p><strong>threadFactory</strong></p><p>它是一个接口，用于实现生成线程的方式、定义线程名格式、是否后台执行等等，可以用 Executors.defaultThreadFactory() 默认的实现即可，也可以用 Guava 等三方库提供的方法实现，如果有特殊要求的话可以自己定义。它最重要的地方应该就是定义线程名称的格式，便于排查问题了吧。</p><p><strong>handler</strong></p><p>当没有空闲的线程处理任务，并且等待队列已满（当然这只对有界队列有效），再有新任务进来的话，就要做一些取舍了，而这个参数就是指定取舍策略的，有下面四种策略可以选择：</p><pre tabindex=0><code>ThreadPoolExecutor.AbortPolicy：直接抛出异常，这是默认策略； 
ThreadPoolExecutor.DiscardPolicy：直接丢弃任务，但是不抛出异常。 
ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后将新来的任务加入等待队列
ThreadPoolExecutor.CallerRunsPolicy：由线程池所在的线程处理该任务，比如在 main 函数中创建线程池，如果执行此策略，将有 main 线程来执行该任务
</code></pre><p>虽然并不提倡用 Executors 中的方法来创建线程池，但还是用他们来讲一下几种线程池的原理。</p><p>1、newFixedThreadPool</p><p>它有两个重载方法，代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=n>ExecutorService</span> <span class=nf>newFixedThreadPool</span><span class=o>(</span><span class=kt>int</span> <span class=n>nThreads</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>new</span> <span class=n>ThreadPoolExecutor</span><span class=o>(</span><span class=n>nThreads</span><span class=o>,</span> <span class=n>nThreads</span><span class=o>,</span>
</span></span><span class=line><span class=cl>                                      <span class=mi>0</span><span class=n>L</span><span class=o>,</span> <span class=n>TimeUnit</span><span class=o>.</span><span class=na>MILLISECONDS</span><span class=o>,</span>
</span></span><span class=line><span class=cl>                                      <span class=k>new</span> <span class=n>LinkedBlockingQueue</span><span class=o>&lt;</span><span class=n>Runnable</span><span class=o>&gt;());</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=n>ExecutorService</span> <span class=nf>newFixedThreadPool</span><span class=o>(</span><span class=kt>int</span> <span class=n>nThreads</span><span class=o>,</span> <span class=n>ThreadFactory</span> <span class=n>threadFactory</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>new</span> <span class=n>ThreadPoolExecutor</span><span class=o>(</span><span class=n>nThreads</span><span class=o>,</span> <span class=n>nThreads</span><span class=o>,</span>
</span></span><span class=line><span class=cl>                                      <span class=mi>0</span><span class=n>L</span><span class=o>,</span> <span class=n>TimeUnit</span><span class=o>.</span><span class=na>MILLISECONDS</span><span class=o>,</span>
</span></span><span class=line><span class=cl>                                      <span class=k>new</span> <span class=n>LinkedBlockingQueue</span><span class=o>&lt;</span><span class=n>Runnable</span><span class=o>&gt;(),</span>
</span></span><span class=line><span class=cl>                                      <span class=n>threadFactory</span><span class=o>);</span>
</span></span><span class=line><span class=cl> <span class=o>}</span>
</span></span><span class=line><span class=cl>    
</span></span></code></pre></div><p>建立一个线程数量固定的线程池，规定的最大线程数量，超过这个数量之后进来的任务，会放到等待队列中，如果有空闲线程，则在等待队列中获取，遵循先进先出原则。</p><p>创建固定线程数量线程池， corePoolSize 和 maximumPoolSize 要一致，即核心线程数和最大线程数（核心+非核心线程）一致，Executors 默认使用的是 LinkedBlockingQueue 作为等待队列，这是一个无界队列，这也是使用它的风险所在，除非你能保证提交的任务不会无节制的增长，否则不要使用无界队列，这样有可能造成等待队列无限增加，造成 OOM。</p><p><strong>正确的创建固定线程数线程池的做法是</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=n>ThreadFactory</span> <span class=n>threadFactory</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ThreadFactoryBuilder</span><span class=o>().</span><span class=na>setNameFormat</span><span class=o>(</span><span class=s>&#34;fengzheng&#34;</span> <span class=o>+</span> <span class=s>&#34;-%d&#34;</span><span class=o>).</span><span class=na>setDaemon</span><span class=o>(</span><span class=kc>true</span><span class=o>).</span><span class=na>build</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=n>ExecutorService</span> <span class=nf>createFixedThreadPool</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>poolSize</span> <span class=o>=</span> <span class=mi>5</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    	<span class=kt>int</span> <span class=n>queueSize</span> <span class=o>=</span> <span class=mi>10</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>ExecutorService</span> <span class=n>executorService</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ThreadPoolExecutor</span><span class=o>(</span><span class=n>poolSize</span><span class=o>,</span> <span class=n>poolSize</span><span class=o>,</span> <span class=mi>0</span><span class=n>L</span><span class=o>,</span> <span class=n>TimeUnit</span><span class=o>.</span><span class=na>SECONDS</span><span class=o>,</span>
</span></span><span class=line><span class=cl>                <span class=k>new</span> <span class=n>ArrayBlockingQueue</span><span class=o>&lt;</span><span class=n>Runnable</span><span class=o>&gt;(</span><span class=n>queueSize</span><span class=o>),</span> <span class=n>threadFactory</span><span class=o>,</span> <span class=k>new</span> <span class=n>ThreadPoolExecutor</span><span class=o>.</span><span class=na>AbortPolicy</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>executorService</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>上面代码是创建一个 5 个线程的固定数量线程池，这里线程存活时间没有作用，所以设置为 0，使用了 ArrayBlockingQueue 作为等待队列，设置长度为 10 ，最多允许10个等待任务，超过的任务会执行默认的 AbortPolicy 策略，也就是直接抛异常。ThreadFactory 使用了 Guava 库提供的方法，定义了线程名称，方便之后排查问题。</p><p>2、newSingleThreadExecutor</p><p>建立一个只有一个线程的线程池，如果有超过一个任务进来，只有一个可以执行，其余的都会放到等待队列中，如果有空闲线程，则在等待队列中获取，遵循先进先出原则。使用 LinkedBlockingQueue 作为等待队列。</p><p>这个方法同样存在等待队列无限长的问题，容易造成 OOM，所以正确的创建方式参考上面固定数量线程池创建的方式，只是把 poolSize 设置为 1 。</p><p>3、newCachedThreadPool</p><p>缓存型线程池，在核心线程达到最大值之前，有任务进来就会创建新的核心线程，并加入核心线程池，即时有空闲的线程，也不会复用。达到最大核心线程数后，新任务进来，如果有空闲线程，则直接拿来使用，如果没有空闲线程，则新建临时线程。并且线程的允许空闲时间都很短，如果超过空闲时间没有活动，则销毁临时线程。关键点就在于它使用 SynchronousQueue 作为等待队列，它不会保留任务，新任务进来后，直接创建临时线程处理，这样一来，也就容易造成无限制的创建线程，造成 OOM。</p><p><strong>正确的创建缓存型线程池的做法是</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=n>ThreadFactory</span> <span class=n>threadFactory</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ThreadFactoryBuilder</span><span class=o>().</span><span class=na>setNameFormat</span><span class=o>(</span><span class=s>&#34;fengzheng&#34;</span> <span class=o>+</span> <span class=s>&#34;-%d&#34;</span><span class=o>).</span><span class=na>setDaemon</span><span class=o>(</span><span class=kc>true</span><span class=o>).</span><span class=na>build</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=n>ExecutorService</span> <span class=nf>createCacheThreadPool</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>coreSize</span> <span class=o>=</span> <span class=mi>10</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>maxSize</span> <span class=o>=</span> <span class=mi>20</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>new</span> <span class=n>ThreadPoolExecutor</span><span class=o>(</span><span class=n>coreSize</span><span class=o>,</span> <span class=n>maxSize</span><span class=o>,</span> <span class=mi>10L</span><span class=o>,</span> <span class=n>TimeUnit</span><span class=o>.</span><span class=na>SECONDS</span><span class=o>,</span>
</span></span><span class=line><span class=cl>                <span class=k>new</span> <span class=n>SynchronousQueue</span><span class=o>&lt;</span><span class=n>Runnable</span><span class=o>&gt;(),</span> <span class=n>threadFactory</span><span class=o>,</span> <span class=k>new</span> <span class=n>ThreadPoolExecutor</span><span class=o>.</span><span class=na>AbortPolicy</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>4、newScheduledThreadPool</p><p>计划型线程池，可以设置固定时间的延时或者定期执行任务，同样是看线程池中有没有空闲线程，如果有，直接拿来使用，如果没有，则新建线程加入池。使用的是 DelayedWorkQueue 作为等待队列，这中类型的队列会保证只有到了指定的延时时间，才会执行任务。</p><p><strong>正确的创建缓存型线程池的做法是</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=n>ThreadFactory</span> <span class=n>threadFactory</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ThreadFactoryBuilder</span><span class=o>().</span><span class=na>setNameFormat</span><span class=o>(</span><span class=s>&#34;fengzheng&#34;</span> <span class=o>+</span> <span class=s>&#34;-%d&#34;</span><span class=o>).</span><span class=na>setDaemon</span><span class=o>(</span><span class=kc>true</span><span class=o>).</span><span class=na>build</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>static</span> <span class=n>CountDownLatch</span> <span class=n>latch</span> <span class=o>=</span> <span class=k>new</span> <span class=n>CountDownLatch</span><span class=o>(</span><span class=mi>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>InterruptedException</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Task</span> <span class=n>task</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Task</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>ScheduledExecutorService</span> <span class=n>executorService</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ScheduledThreadPoolExecutor</span><span class=o>(</span><span class=mi>2</span><span class=o>,</span> <span class=n>threadFactory</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>executorService</span><span class=o>.</span><span class=na>scheduleAtFixedRate</span><span class=o>(</span><span class=n>task</span><span class=o>,</span><span class=mi>0</span><span class=n>L</span><span class=o>,</span><span class=mi>5L</span><span class=o>,</span> <span class=n>TimeUnit</span><span class=o>.</span><span class=na>SECONDS</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>latch</span><span class=o>.</span><span class=na>await</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=kd>class</span> <span class=nc>Task</span> <span class=kd>implements</span> <span class=n>Runnable</span><span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>        <span class=kd>public</span> <span class=kt>void</span> <span class=nf>run</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>().</span><span class=na>getName</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34;executing&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div></article><div class=toc><h2>文章目录</h2><nav id=TableOfContents><ul><li><a href=#为什么要使用线程池><strong>为什么要使用线程池</strong></a></li><li><a href=#几种线程池的使用和原理><strong>几种线程池的使用和原理</strong></a></li></ul></nav></div><script>window.addEventListener("scroll",function(){var e=document.querySelector(".toc"),t=window.pageYOffset||document.documentElement.scrollTop,n=window.innerWidth||document.documentElement.clientWidth;t<360?e.style.top=380-t+"px":e.style.top="20px"})</script><h4>相关文章</h4><dl class=row><dd class=col-md-9><a href=/category/java/RPC-%E6%A6%82%E8%A7%88/>RPC框架的核心是什么？</a></dd><dd class=col-md-9><a href=/category/SpringCloud/0-Srping-Cloud-%E5%BC%80%E7%AF%87/>0. Spring Cloud 是什么</a></dd><dd class=col-md-9><a href=/category/SpringCloud/1-Spring-Cloud-Eureka-%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/>1. Spring Cloud Eureka 实现服务注册与发现</a></dd><dd class=col-md-9><a href=/category/SpringCloud/2-Spring-Cloud-Eureka-%E5%AE%9E%E7%8E%B0%E5%AE%89%E5%85%A8%E6%8E%A7%E5%88%B6/>2. Spring Cloud Eureka 实现安全控制</a></dd><dd class=col-md-9><a href=/category/SpringCloud/3-Spring-Cloud-Eureka-%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/>3. Spring Cloud Eureka 实现高可用服务发现注册中心</a></dd></dl><div class=author-card><div class=underline></div><div class=author-box><div class=qr-author-image><a href=/><img src=/images/person.jpg alt=风筝></a></div><div class=author-content><p class=author-title>作者</p><p class=author-name>风筝</p><p class=author-desc>古时的风筝，一个平庸的程序员，主语言 Java，第二语言 Python，其实学 Python 的时间比 Java 还要早。喜欢写博客，写博客的过程能加深自己对一个知识点的理解，同时还可以分享给他人。喜欢做一些小东西，所以也会一些前端的东西，React、JavaScript、CSS 都会一些，做一些小工具还够用。</p></div></div></div><script src=https://utteranc.es/client.js repo=huzhicheng/blog-comment issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></main><div class="footer gradient-2"><div class="container footer-container"><div class=row><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>网站地图</div><ul class=list-unstyled><li><a href=https://www.moonkite.cn/tags/>标签</a></li><li><a href=https://www.moonkite.cn/categories/>分类</a></li><li><a rel=alternate type=application/rss+xml href=https://www.moonkite.cn/index.xml><i class="fas fa-rss-square"></i> RSS订阅</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>社群</div><ul class=list-unstyled><li><a href=https://github.com/huzhicheng rel=noopener target=_blank>GitHub</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>友链</div><ul class=list-unstyled><li><a href=https://github.com/huzhicheng rel=noopener target=_blank>关于我</a></li></ul></div><div class="col-xs-12 col-sm-3 col-md-3 col-lg-3"><p class="pull-right text-right"><small><em>Proudly powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo</a></em></small><br><small><em>Theme - <a href=https://github.com/shaform/hugo-theme-den rel=noopener target=_blank>Den</a></em></small><br><small>&copy;
风筝
2023</small></p></div></div><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?e417ddf834c7bb7411207e1fa09815aa",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-C714TFXRD4"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-C714TFXRD4")</script><div class=busuanzi-footer><span id=busuanzi_container_site_pv>本站总访问量<span id=busuanzi_value_site_pv></span>次</span>
<span id=busuanzi_container_site_uv>本站访客数<span id=busuanzi_value_site_uv></span>人次</span></div></div></div><script src=https://code.jquery.com/jquery-3.3.1.slim.min.js integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap_4.1.3_js_bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script>
<script>$(document).ready(function(){$("#load_disqus").length&&$(window).scroll(function(){if($("#load_disqus").length){var e=$("#load_disqus").offset().top,t=$(window).scrollTop(),n=t+$(window).height();t<e&&e<n&&load_disqus()}})})</script></body></html>