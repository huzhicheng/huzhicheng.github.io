<!doctype html><html lang=zh-cn itemscope itemtype=http://schema.org/WebPage><head><meta name=generator content="Hugo 0.113.0"><meta charset=utf-8><title>Java多线程之-用 CountDownLatch 说明 AQS 的实现原理 · 古时的风筝</title><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=description content="本文基于 jdk 1.8 。 CountDownLatch 的使用 前面的文章中说到了 volatile 以及用 volatile 来实现自旋锁，例如 java.util.concurrent.atomic 包下的工具类。但是 volatile 的使用场景毕竟有限，很多的情况下并不是适用，这个时"><meta name=keywords content="Hugo,theme,编程,java,ChatGPT,程序员,开发"><link rel=canonical href=https://moonkite.cn/category/java/%E7%94%A8-CountDownLatch-%E8%AF%B4%E6%98%8E-AQS-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/><link rel=icon href=https://moonkite.cn/images/photo.png><link rel=stylesheet href=https://cdn.usebootstrap.com/bootstrap/4.1.3/css/bootstrap.min.css><link rel=stylesheet href=https://moonkite.cn/css/den.css><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-tc-webfont@1.0.0/style.css><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><meta name=referrer content="no-referrer-when-downgrade"><meta property="og:title" content="Java多线程之-用 CountDownLatch 说明 AQS 的实现原理"><meta property="og:description" content="本文基于 jdk 1.8 。 CountDownLatch 的使用 前面的文章中说到了 volatile 以及用 volatile 来实现自旋锁，例如 java.util.concurrent.atomic 包下的工具类。但是 volatile 的使用场景毕竟有限，很多的情况下并不是适用，这个时"><meta property="og:type" content="article"><meta property="og:url" content="https://moonkite.cn/category/java/%E7%94%A8-CountDownLatch-%E8%AF%B4%E6%98%8E-AQS-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"><meta property="article:section" content="category"><meta property="article:published_time" content="2018-06-08T08:56:23+08:00"><meta property="article:modified_time" content="2018-06-08T08:56:23+08:00"><meta itemprop=name content="Java多线程之-用 CountDownLatch 说明 AQS 的实现原理"><meta itemprop=description content="本文基于 jdk 1.8 。 CountDownLatch 的使用 前面的文章中说到了 volatile 以及用 volatile 来实现自旋锁，例如 java.util.concurrent.atomic 包下的工具类。但是 volatile 的使用场景毕竟有限，很多的情况下并不是适用，这个时"><meta itemprop=datePublished content="2018-06-08T08:56:23+08:00"><meta itemprop=dateModified content="2018-06-08T08:56:23+08:00"><meta itemprop=wordCount content="3976"><meta itemprop=keywords content="Java,JDK,JVM,CountDownLatch,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java多线程之-用 CountDownLatch 说明 AQS 的实现原理"><meta name=twitter:description content="本文基于 jdk 1.8 。 CountDownLatch 的使用 前面的文章中说到了 volatile 以及用 volatile 来实现自旋锁，例如 java.util.concurrent.atomic 包下的工具类。但是 volatile 的使用场景毕竟有限，很多的情况下并不是适用，这个时"></head><body><div class=header-container style=background:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2)),url(https://moonkite.cn/images/background.png);background-position:top;background-size:cover><div class=container><nav class="header-nav navbar navbar-expand-md navbar-dark light-dark"><div class="header-logo navbar-brand"><a class=float-left href=https://moonkite.cn/></a></div><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarNav aria-controls=navbarNav aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="nav-menu collapse navbar-collapse" id=navbarNav><ul class=navbar-nav><li class=nav-item><a href=https://moonkite.cn/ class=nav-link><i class="fas fad fa-h-square"></i>主页</a></li><li class=nav-item><a href=https://moonkite.cn/category/notes/ class=nav-link><i class='fas fa-yin-yang'></i>生活随笔</a></li><li class=nav-item><a href=javascript:void(0) class=nav-link><i class='fas fa-laptop-code'></i>技术文章</a><div class=sub-dropdown-menu><a class=sub-nav-link href=https://moonkite.cn/category/java><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 48 48"><path fill="#f44336" d="M23.65 24.898c-.998-1.609-1.722-2.943-2.725-5.455C19.229 15.2 31.24 11.366 26.37 3.999c2.111 5.089-7.577 8.235-8.477 12.473-.823 3.898 5.752 8.426 5.757 8.426z"/><path fill="#f44336" d="M23.878 17.27c-.192 2.516 2.229 3.857 2.299 5.695.056 1.496-1.447 2.743-1.447 2.743s2.728-.536 3.579-2.818c.945-2.534-1.834-4.269-1.548-6.298.267-1.938 6.031-5.543 6.031-5.543S24.311 11.611 23.878 17.27z"/><g><path fill="#1565c0" d="M32.084 25.055c1.754-.394 3.233.723 3.233 2.01.0 2.901-4.021 5.643-4.021 5.643s6.225-.742 6.225-5.505c0-3.15-3.057-3.937-5.437-2.148zm-2.955 2.34s1.941-1.383 2.458-1.902c-4.763 1.011-15.638 1.147-15.638.269.0-.809 3.507-1.638 3.507-1.638s-7.773-.112-7.773 2.181C11.683 28.695 21.858 28.866 29.129 27.395z"/><path fill="#1565c0" d="M27.935 29.571c-4.509 1.499-12.814 1.02-10.354-.993-1.198.0-2.974.963-2.974 1.889.0 1.857 8.982 3.291 15.63.572l-2.302-1.468z"/><path fill="#1565c0" d="M18.686 32.739c-1.636.0-2.695 1.054-2.695 1.822.0 2.391 9.76 2.632 13.627.205l-2.458-1.632C24.271 34.404 17.014 34.579 18.686 32.739z"/><path fill="#1565c0" d="M36.281 36.632c0-.936-1.055-1.377-1.433-1.588 2.228 5.373-22.317 4.956-22.317 1.784.0-.721 1.807-1.427 3.477-1.093l-1.42-.839C11.26 34.374 9 35.837 9 37.017 9 42.52 36.281 42.255 36.281 36.632z"/><path fill="#1565c0" d="M39 38.604c-4.146 4.095-14.659 5.587-25.231 3.057C24.341 46.164 38.95 43.628 39 38.604z"/></g></svg>&nbsp;可爱的 Java</a>
<a class=sub-nav-link href=https://moonkite.cn/category/SpringCloud><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 48 48"><path fill="#8bc34a" d="M43.982 23.635c.069-4.261-.891-9.328-2.891-15.273L39.523 3.7l-2.13 4.433c-.114.237-.244.469-.38.698C33.514 5.827 28.974 4 24 4 12.954 4 4 12.954 4 24s8.954 20 20 20 20-8.954 20-20C44 23.877 43.984 23.758 43.982 23.635z"/><path fill="#fff" d="M39.385 32.558C36.262 36.86 30.734 37.091 25.531 37H18.75h-1.938c4.428-1.593 7.063-1.972 9.754-3.4 5.068-2.665 10.078-8.496 11.121-14.562-1.93 5.836-7.779 10.85-13.109 12.889-3.652 1.393-10.248 2.745-10.248 2.745l-.267-.145C9.573 32.268 9.437 22.214 17.6 18.968c3.574-1.423 6.993-.641 10.854-1.593 4.122-1.012 8.89-4.208 10.83-8.375C41.456 15.667 44.07 26.106 39.385 32.558zM15.668 38.445C15.386 38.795 14.955 39 14.505 39c-.823.0-1.495-.677-1.495-1.5s.677-1.5 1.495-1.5c.341.0.677.118.941.336C16.086 36.855 16.186 37.805 15.668 38.445z"/></svg>&nbsp; Spring Cloud 系列</a></div></li><li class=nav-item><a href=https://moonkite.cn/category/network class=nav-link><i class="fas fa-network-wired"></i>轻解计算机网络</a></li><li class=nav-item><a href=https://moonkite.cn/category/product class=nav-link><i class="fas fab fa-medapps"></i>我的产品</a></li></ul></div></nav></div><div class="container header-wrapper"><div class=row><div class=col-lg-12><div class=header-content><h1 class=header-title>Java多线程之-用 CountDownLatch 说明 AQS 的实现原理</h1><p class=header-date>作者：
风筝 /
2018-06-08<div class=header-underline></div><div class=header-date>&nbsp·&nbsp
  <span id=busuanzi_container_page_pv>本文被阅读<span id=busuanzi_value_page_pv></span>次</span></div><div class=clearfix></div><p class="float-right header-tags"><i class="fas fa-tags" aria-hidden=true></i>
<a href=https://moonkite.cn/tag/CountDownLatch/>CountDownLatch</a>,
<a href=https://moonkite.cn/tag/Java/>Java</a>,
<a href=https://moonkite.cn/tag/JDK/>JDK</a>,
<a href=https://moonkite.cn/tag/JVM/>JVM</a></p></div></div></div></div></div><main><div class="container content"><article><blockquote><p>本文基于 jdk 1.8 。</p></blockquote><h2 id=countdownlatch-的使用><strong>CountDownLatch 的使用</strong></h2><p><a href=https://www.cnblogs.com/fengzheng/p/9070268.html>前面的文章</a>中说到了 volatile 以及用 volatile 来实现自旋锁，例如 java.util.concurrent.atomic 包下的工具类。但是 volatile 的使用场景毕竟有限，很多的情况下并不是适用，这个时候就需要 synchronized 或者各种锁实现了。今天就来说一下几种锁的实现原理。</p><p>先来看一个最简单的 CountDownLatch 使用方法，例子很简单，可以运行看一下效果。CountDownLatch 的作用是：当一个线程需要另外一个或多个线程完成后，再开始执行。比如主线程要等待一个子线程完成环境相关配置的加载工作，主线程才继续执行，就可以利用 CountDownLatch 来实现。</p><p>例如下面这个例子，首先实例化一个 CountDownLatch ，参数可以理解为一个计数器，这里为 1，然后主线程执行，调用 worker 子线程，接着调用 CountDownLatch 的 await() 方法，表示阻塞主线程。当子线程执行完成后，在 finnaly 块调用 countDown() 方法，表示一个等待已经完成，把计数器减一，直到减为 0，主线程又开始执行。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=n>CountDownLatch</span> <span class=n>latch</span> <span class=o>=</span> <span class=k>new</span> <span class=n>CountDownLatch</span><span class=o>(</span><span class=mi>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>InterruptedException</span><span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;主线程开始......&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Thread</span> <span class=n>thread</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Thread</span><span class=o>(</span><span class=k>new</span> <span class=n>Worker</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=n>thread</span><span class=o>.</span><span class=na>start</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;主线程等待......&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>latch</span><span class=o>.</span><span class=na>toString</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=n>latch</span><span class=o>.</span><span class=na>await</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>latch</span><span class=o>.</span><span class=na>toString</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;主线程继续.......&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kd>class</span> <span class=nc>Worker</span> <span class=kd>implements</span> <span class=n>Runnable</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>        <span class=kd>public</span> <span class=kt>void</span> <span class=nf>run</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;子线程任务正在执行&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>Thread</span><span class=o>.</span><span class=na>sleep</span><span class=o>(</span><span class=mi>2000</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span><span class=k>catch</span> <span class=o>(</span><span class=n>InterruptedException</span> <span class=n>e</span><span class=o>){</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=o>}</span><span class=k>finally</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>latch</span><span class=o>.</span><span class=na>countDown</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>执行结果如下：</p><pre tabindex=0><code>主线程开始......
子线程任务正在执行
主线程等待......
java.util.concurrent.CountDownLatch@1d44bcfa[Count = 1]
java.util.concurrent.CountDownLatch@1d44bcfa[Count = 0]
主线程继续.......
</code></pre><h2 id=aqs-的原理><strong>AQS 的原理</strong></h2><p>这么好用的功能是怎么实现的呢，下面就来说一说实现它的核心技术原理 AQS。 AQS 全称 <code>AbstractQueuedSynchronizer</code>，是 java.util.concurrent 中提供的一种高效且可扩展的同步机制。它可以用来实现可以依赖 int 状态的同步器，获取和释放参数以及一个内部FIFO等待队列，除了<code>CountDownLatch</code>，<code>ReentrantLock</code>、<code>Semaphore</code> 等功能实现都使用了它。</p><p>接下来用 CountDownLatch 来分析一下 AQS 的实现。建议看文章的时候先大致看一下源码，有助于理解下面所说的内容。</p><p>在我们的方法中调用 <code>awit()</code>和<code>countDown()</code>的时候，发生了几个关键的调用关系，我画了一个方法调用图。</p><p><img src=https://hexo.moonkite.cn/blog/273364-20180608074920780-931190535.png alt></p><p>首先在 CountDownLatch 类内部定义了一个 Sync 内部类，这个内部类就是继承自 AbstractQueuedSynchronizer 的。并且重写了方法 <code>tryAcquireShared</code>和<code>tryReleaseShared</code>。例如当调用 <code>awit()</code>方法时，CountDownLatch 会调用内部类Sync 的 <code>acquireSharedInterruptibly()</code> 方法，然后在这个方法中会调用 <code>tryAcquireShared</code> 方法，这个方法就是 CountDownLatch 的内部类 Sync 里重写的 AbstractQueuedSynchronizer 的方法。调用 <code>countDown()</code> 方法同理。</p><p>这种方式是使用 AbstractQueuedSynchronizer 的标准化方式，大致分为两步：</p><p>1、内部持有继承自 AbstractQueuedSynchronizer 的对象 Sync；</p><p>2、并在 Sync 内重写 AbstractQueuedSynchronizer protected 的部分或全部方法，这些方法包括如下几个：
<img src=https://hexo.moonkite.cn/blog/273364-20180608074941782-565895757.png alt></p><p>之所以要求子类重写这些方法，是为了让使用者（这里的使用者指 CountDownLatch 等）可以在其中加入自己的判断逻辑，例如 CountDownLatch 在 <code>tryAcquireShared</code>中加入了判断，判断 state 是否不为0，如果不为0，才符合调用条件。</p><p><code>tryAcquire</code>和<code>tryRelease</code>是对应的，前者是独占模式获取，后者是独占模式释放。</p><p><code>tryAcquireShared</code>和<code>tryReleaseShared</code>是对应的，前者是共享模式获取，后者是共享模式释放。</p><p>我们看到 CountDownLatch 重写的方法 tryAcquireShared 实现如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>protected</span> <span class=kt>int</span> <span class=nf>tryAcquireShared</span><span class=o>(</span><span class=kt>int</span> <span class=n>acquires</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=o>(</span><span class=n>getState</span><span class=o>()</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span> <span class=o>?</span> <span class=mi>1</span> <span class=o>:</span> <span class=o>-</span><span class=mi>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span></code></pre></div><p>判断 state 值是否为0，为0 返回1，否则返回 -1。state 值是 AbstractQueuedSynchronizer 类中的一个 volatile 变量。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>volatile</span> <span class=kt>int</span> <span class=n>state</span><span class=o>;</span>
</span></span></code></pre></div><p>在 CountDownLatch 中这个 state 值就是计数器，在调用 await 方法的时候，将值赋给 state 。</p><p>##<strong>等待线程入队</strong></p><p>根据上面的逻辑，调用 await() 方法时，先去获取 state 的值，当计数器不为0的时候，说明还有需要等待的线程在运行，则调用 doAcquireSharedInterruptibly 方法，进来执行的第一个动作就是尝试加入等待队列 ，即调用 addWaiter（）方法， 源码如下：</p><p>到这里就走到了 AQS 的核心部分，AQS 用内部的一个 Node 类维护一个 CHL Node FIFO 队列。将当前线程加入等待队列，并通过 parkAndCheckInterrupt（）方法实现当前线程的阻塞。下面一大部分都是在说明 CHL 队列的实现，里面用 CAS 实现队列出入不会发生阻塞。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kt>void</span> <span class=nf>doAcquireSharedInterruptibly</span><span class=o>(</span><span class=kt>int</span> <span class=n>arg</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=kd>throws</span> <span class=n>InterruptedException</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    	<span class=c1>//加入等待队列 				      
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kd>final</span> <span class=n>Node</span> <span class=n>node</span> <span class=o>=</span> <span class=n>addWaiter</span><span class=o>(</span><span class=n>Node</span><span class=o>.</span><span class=na>SHARED</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>boolean</span> <span class=n>failed</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    	<span class=c1>// 进入 CAS 循环
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=o>(;;)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>//当一个节点(关联一个线程)进入等待队列后， 获取此节点的 prev 节点 
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=kd>final</span> <span class=n>Node</span> <span class=n>p</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=na>predecessor</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                <span class=c1>// 如果获取到的 prev 是 head，也就是队列中第一个等待线程
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=o>(</span><span class=n>p</span> <span class=o>==</span> <span class=n>head</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=c1>// 再次尝试申请 反应到 CountDownLatch 就是查看是否还有线程需要等待(state是否为0)
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=kt>int</span> <span class=n>r</span> <span class=o>=</span> <span class=n>tryAcquireShared</span><span class=o>(</span><span class=n>arg</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                    <span class=c1>// 如果 r &gt;=0 说明 没有线程需要等待了 state==0
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=k>if</span> <span class=o>(</span><span class=n>r</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                        <span class=c1>//尝试将第一个线程关联的节点设置为 head 
</span></span></span><span class=line><span class=cl><span class=c1></span>                        <span class=n>setHeadAndPropagate</span><span class=o>(</span><span class=n>node</span><span class=o>,</span> <span class=n>r</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                        <span class=n>p</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span> <span class=c1>// help GC
</span></span></span><span class=line><span class=cl><span class=c1></span>                        <span class=n>failed</span> <span class=o>=</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                        <span class=k>return</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                    <span class=o>}</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>                <span class=c1>//经过自旋tryAcquireShared后，state还不为0，就会到这里，第一次的时候，waitStatus是0，那么node的waitStatus就会被置为SIGNAL，第二次再走到这里，就会用LockSupport的park方法把当前线程阻塞住
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=o>(</span><span class=n>shouldParkAfterFailedAcquire</span><span class=o>(</span><span class=n>p</span><span class=o>,</span> <span class=n>node</span><span class=o>)</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                    <span class=n>parkAndCheckInterrupt</span><span class=o>())</span>
</span></span><span class=line><span class=cl>                    <span class=k>throw</span> <span class=k>new</span> <span class=n>InterruptedException</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>finally</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>failed</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=n>cancelAcquire</span><span class=o>(</span><span class=n>node</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>我看看到上面先执行了 addWaiter() 方法，就是将当前线程加入等待队列，源码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/** Marker to indicate a node is waiting in shared mode */</span>
</span></span><span class=line><span class=cl> <span class=kd>static</span> <span class=kd>final</span> <span class=n>Node</span> <span class=n>SHARED</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Node</span><span class=o>();</span>
</span></span><span class=line><span class=cl> <span class=cm>/** Marker to indicate a node is waiting in exclusive mode */</span>
</span></span><span class=line><span class=cl> <span class=kd>static</span> <span class=kd>final</span> <span class=n>Node</span> <span class=n>EXCLUSIVE</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=n>Node</span> <span class=nf>addWaiter</span><span class=o>(</span><span class=n>Node</span> <span class=n>mode</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Node</span> <span class=n>node</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Node</span><span class=o>(</span><span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>(),</span> <span class=n>mode</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 尝试快速入队操作，因为大多数时候尾节点不为 null
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>Node</span> <span class=n>pred</span> <span class=o>=</span> <span class=n>tail</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>pred</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>node</span><span class=o>.</span><span class=na>prev</span> <span class=o>=</span> <span class=n>pred</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>compareAndSetTail</span><span class=o>(</span><span class=n>pred</span><span class=o>,</span> <span class=n>node</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>pred</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>node</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>node</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    	<span class=c1>//如果尾节点为空(也就是队列为空) 或者尝试CAS入队失败(由于并发原因)，进入enq方法
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>enq</span><span class=o>(</span><span class=n>node</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>node</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>上面是向等待队列中添加等待者（waiter）的方法。首先构造一个 Node 实体，参数为当前线程和一个mode，这个mode有两种形式，一个是 SHARED ，一个是 EXCLUSIVE，请看上面的代码。然后执行下面的入队操作 addWaiter，和 enq() 方法的 else 分支操作是一样的，这里的操作如果成功了，就不用再进到 enq() 方法的循环中去了，可以提高性能。如果没有成功，再调用 enq() 方法。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=n>Node</span> <span class=nf>enq</span><span class=o>(</span><span class=kd>final</span> <span class=n>Node</span> <span class=n>node</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    	<span class=c1>// 死循环+CAS保证所有节点都入队
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=o>(;;)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Node</span> <span class=n>t</span> <span class=o>=</span> <span class=n>tail</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 如果队列为空 设置一个空节点作为 head
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=o>(</span><span class=n>t</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span> <span class=c1>// Must initialize
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=o>(</span><span class=n>compareAndSetHead</span><span class=o>(</span><span class=k>new</span> <span class=n>Node</span><span class=o>()))</span>
</span></span><span class=line><span class=cl>                    <span class=n>tail</span> <span class=o>=</span> <span class=n>head</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>//加入队尾
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>node</span><span class=o>.</span><span class=na>prev</span> <span class=o>=</span> <span class=n>t</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=o>(</span><span class=n>compareAndSetTail</span><span class=o>(</span><span class=n>t</span><span class=o>,</span> <span class=n>node</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>t</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>node</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=n>t</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>说明：循环加 CAS 操作是实现乐观锁的标准方式，CAS 是为了实现原子操作而出现的，所谓的原子操作指操作执行期间，不会受其他线程的干扰。Java 实现的 CAS 是调用 unsafe 类提供的方法，底层是调用 c++ 方法，直接操作内存，在 cpu 层面加锁，直接对内存进行操作。</p><p>上面是 AQS 等待队列入队方法，操作在无限循环中进行，如果入队成功则返回新的队尾节点，否则一直自旋，直到入队成功。假设入队的节点为 node ，上来直接进入循环，在循环中，先拿到尾节点。</p><p>1、if 分支，如果尾节点为 null，说明现在队列中还没有等待线程，则尝试 CAS 操作将头节点初始化，然后将尾节点也设置为头节点，因为初始化的时候头尾是同一个，这和 AQS 的设计实现有关， AQS 默认要有一个虚拟节点。此时，尾节点不在为空，循环继续，进入 else 分支；</p><p>2、else 分支，如果尾节点不为 null， node.prev = t ，也就是将当前尾节点设置为待入队节点的前置节点。然后又是利用 CAS 操作，将待入队的节点设置为队列的尾节点，如果 CAS 返回 false，表示未设置成功，继续循环设置，直到设置成功，接着将之前的尾节点（也就是倒数第二个节点）的 next 属性设置为当前尾节点，对应 t.next = node 语句，然后返回当前尾节点，退出循环。</p><p>setHeadAndPropagate 方法负责将自旋等待或被 LockSupport 阻塞的线程唤醒。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kt>void</span> <span class=nf>setHeadAndPropagate</span><span class=o>(</span><span class=n>Node</span> <span class=n>node</span><span class=o>,</span> <span class=kt>int</span> <span class=n>propagate</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    	<span class=c1>//备份现在的 head
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>Node</span> <span class=n>h</span> <span class=o>=</span> <span class=n>head</span><span class=o>;</span>  
</span></span><span class=line><span class=cl>    	<span class=c1>//抢到锁的线程被唤醒 将这个节点设置为head
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>setHead</span><span class=o>(</span><span class=n>node</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    	<span class=c1>// propagate 一般都会大于0 或者存在可被唤醒的线程
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>propagate</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>h</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>h</span><span class=o>.</span><span class=na>waitStatus</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>            <span class=o>(</span><span class=n>h</span> <span class=o>=</span> <span class=n>head</span><span class=o>)</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>h</span><span class=o>.</span><span class=na>waitStatus</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Node</span> <span class=n>s</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 只有一个节点 或者是共享模式 释放所有等待线程 各自尝试抢占锁
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=o>(</span><span class=n>s</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>s</span><span class=o>.</span><span class=na>isShared</span><span class=o>())</span>
</span></span><span class=line><span class=cl>                <span class=n>doReleaseShared</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>Node 对象中有一个属性是 waitStatus ，它有四种状态，分别是：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//线程已被 cancelled ，这种状态的节点将会被忽略，并移出队列
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>CANCELLED</span> <span class=o>=</span>  <span class=mi>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=c1>// 表示当前线程已被挂起，并且后继节点可以尝试抢占锁
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>SIGNAL</span>    <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=c1>//线程正在等待某些条件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>CONDITION</span> <span class=o>=</span> <span class=o>-</span><span class=mi>2</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=c1>//共享模式下 无条件所有等待线程尝试抢占锁
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>PROPAGATE</span> <span class=o>=</span> <span class=o>-</span><span class=mi>3</span><span class=o>;</span>
</span></span></code></pre></div><h3 id=等待线程被唤醒><strong>等待线程被唤醒</strong></h3><p>当执行 CountDownLatch 的 countDown（）方法，将计数器减一，也就是state减一，当减到0的时候，等待队列中的线程被释放。是调用 AQS 的 releaseShared 方法来实现的，下面代码中的方法是按顺序调用的，摘到了一起，方便查看：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// AQS类
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>public</span> <span class=kd>final</span> <span class=kt>boolean</span> <span class=nf>releaseShared</span><span class=o>(</span><span class=kt>int</span> <span class=n>arg</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    	<span class=c1>// arg 为固定值 1
</span></span></span><span class=line><span class=cl><span class=c1></span>    	<span class=c1>// 如果计数器state 为0 返回true，前提是调用 countDown() 之前不能已经为0
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>tryReleaseShared</span><span class=o>(</span><span class=n>arg</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 唤醒等待队列的线程
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>doReleaseShared</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// CountDownLatch 重写的方法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>protected</span> <span class=kt>boolean</span> <span class=nf>tryReleaseShared</span><span class=o>(</span><span class=kt>int</span> <span class=n>releases</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Decrement count; signal when transition to zero
</span></span></span><span class=line><span class=cl><span class=c1></span>    		<span class=c1>// 依然是循环+CAS配合 实现计数器减1
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>for</span> <span class=o>(;;)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=kt>int</span> <span class=n>c</span> <span class=o>=</span> <span class=n>getState</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=o>(</span><span class=n>c</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=kt>int</span> <span class=n>nextc</span> <span class=o>=</span> <span class=n>c</span><span class=o>-</span><span class=mi>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=o>(</span><span class=n>compareAndSetState</span><span class=o>(</span><span class=n>c</span><span class=o>,</span> <span class=n>nextc</span><span class=o>))</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=n>nextc</span> <span class=o>==</span> <span class=mi>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>/// AQS类
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=kd>private</span> <span class=kt>void</span> <span class=nf>doReleaseShared</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=o>(;;)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Node</span> <span class=n>h</span> <span class=o>=</span> <span class=n>head</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>h</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>h</span> <span class=o>!=</span> <span class=n>tail</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=kt>int</span> <span class=n>ws</span> <span class=o>=</span> <span class=n>h</span><span class=o>.</span><span class=na>waitStatus</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=c1>// 如果节点状态为SIGNAL，则他的next节点也可以尝试被唤醒
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=o>(</span><span class=n>ws</span> <span class=o>==</span> <span class=n>Node</span><span class=o>.</span><span class=na>SIGNAL</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=o>(!</span><span class=n>compareAndSetWaitStatus</span><span class=o>(</span><span class=n>h</span><span class=o>,</span> <span class=n>Node</span><span class=o>.</span><span class=na>SIGNAL</span><span class=o>,</span> <span class=mi>0</span><span class=o>))</span>
</span></span><span class=line><span class=cl>                        <span class=k>continue</span><span class=o>;</span>            <span class=c1>// loop to recheck cases
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=n>unparkSuccessor</span><span class=o>(</span><span class=n>h</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>                <span class=c1>// 将节点状态设置为PROPAGATE，表示要向下传播，依次唤醒
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>ws</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                         <span class=o>!</span><span class=n>compareAndSetWaitStatus</span><span class=o>(</span><span class=n>h</span><span class=o>,</span> <span class=mi>0</span><span class=o>,</span> <span class=n>Node</span><span class=o>.</span><span class=na>PROPAGATE</span><span class=o>))</span>
</span></span><span class=line><span class=cl>                    <span class=k>continue</span><span class=o>;</span>                <span class=c1>// loop on failed CAS
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>h</span> <span class=o>==</span> <span class=n>head</span><span class=o>)</span>                   <span class=c1>// loop if head changed
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>break</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>因为这是共享型的，当计数器为 0 后，会唤醒等待队列里的所有线程，所有调用了 await() 方法的线程都被唤醒，并发执行。这种情况对应到的场景是，有多个线程需要等待一些动作完成，比如一个线程完成初始化动作，其他5个线程都需要用到初始化的结果，那么在初始化线程调用 countDown 之前，其他5个线程都处在等待状态。一旦初始化线程调用了 countDown ，其他5个线程都被唤醒，开始执行。</p><h2 id=总结><strong>总结</strong></h2><p>1、AQS 分为独占模式和共享模式，CountDownLatch 使用了它的共享模式。</p><p>2、AQS 当第一个等待线程（被包装为 Node）要入队的时候，要保证存在一个 head 节点，这个 head 节点不关联线程，也就是一个虚节点。</p><p>3、当队列中的等待节点（关联线程的，非 head 节点）抢到锁，将这个节点设置为 head 节点。</p><p>4、第一次自旋抢锁失败后，waitStatus 会被设置为 -1（SIGNAL），第二次再失败，就会被 LockSupport 阻塞挂起。</p><p>5、如果一个节点的前置节点为 SIGNAL 状态，则这个节点可以尝试抢占锁。</p></article><h4>相关文章</h4><dl class=row><dd class=col-md-9><a href=/category/java/JDK17/>新项目为什么决定用 JDK 17了</a></dd><dd class=col-md-9><a href=/category/java/Graalvm/>过两年 JVM 可能就要被GraalVM替代了</a></dd><dd class=col-md-9><a href=/category/java/JVM-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E9%A2%84%E9%98%B2/>JVM 内存溢出的原因及预防</a></dd><dd class=col-md-9><a href=/category/java/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E8%87%AA%E5%B7%B1%E7%9A%84-JDK/>手把手教你编译属于自己的 JDK</a></dd><dd class=col-md-9><a href=/category/java/Java-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%97/>Java 字符串常量池漫游指南（图文并茂）</a></dd></dl><div class=author-card><div class=underline></div><div class=author-box><div class=qr-author-image><a href=https://www.moonkite.cn><img src=/images/person.jpg alt=风筝></a></div><div class=author-content><p class=author-title>作者</p><p class=author-name>风筝</p><p class=author-desc>古时的风筝，一个平庸的程序员，主语言 Java，第二语言 Python，其实学 Python 的时间比 Java 还要早。喜欢写博客，写博客的过程能加深自己对一个知识点的理解，同时还可以分享给他人。喜欢做一些小东西，所以也会一些前端的东西，React、JavaScript、CSS 都会一些，做一些小工具还够用。</p></div></div></div><script src=https://utteranc.es/client.js repo=huzhicheng/blog-comment issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></main><div class="footer gradient-2"><div class="container footer-container"><div class=row><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>网站地图</div><ul class=list-unstyled><li><a href=https://moonkite.cn/tags/>标签</a></li><li><a href=https://moonkite.cn/categories/>分类</a></li><li><a rel=alternate type=application/rss+xml href=https://moonkite.cn/index.xml><i class="fas fa-rss-square"></i> RSS订阅</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>社群</div><ul class=list-unstyled><li><a href=https://github.com/huzhicheng rel=noopener target=_blank>GitHub</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>友链</div><ul class=list-unstyled><li><a href=https://github.com/huzhicheng rel=noopener target=_blank>关于我</a></li></ul></div><div class="col-xs-12 col-sm-3 col-md-3 col-lg-3"><p class="pull-right text-right"><small><em>Proudly powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo</a></em></small><br><small><em>Theme - <a href=https://github.com/shaform/hugo-theme-den rel=noopener target=_blank>Den</a></em></small><br><small>&copy;
风筝
2023</small></p></div></div><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?e417ddf834c7bb7411207e1fa09815aa",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-C714TFXRD4"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-C714TFXRD4")</script><div class=busuanzi-footer><span id=busuanzi_container_site_pv>本站总访问量<span id=busuanzi_value_site_pv></span>次</span>
<span id=busuanzi_container_site_uv>本站访客数<span id=busuanzi_value_site_uv></span>人次</span></div></div></div><script src=https://code.jquery.com/jquery-3.3.1.slim.min.js integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap_4.1.3_js_bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script>
<script>$(document).ready(function(){$("#load_disqus").length&&$(window).scroll(function(){if($("#load_disqus").length){var e=$("#load_disqus").offset().top,t=$(window).scrollTop(),n=t+$(window).height();t<e&&e<n&&load_disqus()}})})</script></body></html>