<!doctype html><html lang=zh-cn itemscope itemtype=http://schema.org/WebPage><head><meta name=generator content="Hugo 0.115.3"><meta charset=utf-8><title>JVM 内存溢出的原因及预防 · 古时的风筝</title><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=description content="我们都知道 Java 程序都是跑在 JVM 上的，一旦 JVM 有什么风吹草动，必然会影响服务的稳定性。幸运的话，服务会发生抖动，可能有部分请求出现延迟或异常。不幸的"><meta name=keywords content="Hugo,theme,编程,java,ChatGPT,程序员,开发"><meta name=google-site-verification content="google57680cd58c46e2f3.html"><link rel=canonical href=https://www.moonkite.cn/category/java/JVM-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E9%A2%84%E9%98%B2/><link rel=icon href=https://www.moonkite.cn/images/photo.png><link rel=stylesheet href=https://cdn.usebootstrap.com/bootstrap/4.1.3/css/bootstrap.min.css><link rel=stylesheet href=https://www.moonkite.cn/css/den.css><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-tc-webfont@1.0.0/style.css><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><meta name=referrer content="no-referrer-when-downgrade"><meta property="og:title" content="JVM 内存溢出的原因及预防"><meta property="og:description" content="我们都知道 Java 程序都是跑在 JVM 上的，一旦 JVM 有什么风吹草动，必然会影响服务的稳定性。幸运的话，服务会发生抖动，可能有部分请求出现延迟或异常。不幸的"><meta property="og:type" content="article"><meta property="og:url" content="https://www.moonkite.cn/category/java/JVM-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E9%A2%84%E9%98%B2/"><meta property="article:section" content="category"><meta property="article:published_time" content="2021-09-02T08:56:23+08:00"><meta property="article:modified_time" content="2021-09-02T08:56:23+08:00"><meta itemprop=name content="JVM 内存溢出的原因及预防"><meta itemprop=description content="我们都知道 Java 程序都是跑在 JVM 上的，一旦 JVM 有什么风吹草动，必然会影响服务的稳定性。幸运的话，服务会发生抖动，可能有部分请求出现延迟或异常。不幸的"><meta itemprop=datePublished content="2021-09-02T08:56:23+08:00"><meta itemprop=dateModified content="2021-09-02T08:56:23+08:00"><meta itemprop=wordCount content="2693"><meta itemprop=keywords content="Java,JDK,JVM,Java内存溢出,栈溢出,"><meta name=twitter:card content="summary"><meta name=twitter:title content="JVM 内存溢出的原因及预防"><meta name=twitter:description content="我们都知道 Java 程序都是跑在 JVM 上的，一旦 JVM 有什么风吹草动，必然会影响服务的稳定性。幸运的话，服务会发生抖动，可能有部分请求出现延迟或异常。不幸的"></head><body><div class=header-container style=background:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2)),url(https://www.moonkite.cn/images/background.png);background-position:top;background-size:cover><div class=container><nav class="header-nav navbar navbar-expand-md navbar-dark light-dark"><div class="header-logo navbar-brand"><a class=float-left href=https://www.moonkite.cn/></a></div><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarNav aria-controls=navbarNav aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="nav-menu collapse navbar-collapse" id=navbarNav><ul class=navbar-nav><li class=nav-item><a href=https://www.moonkite.cn/ class=nav-link><i class="fas fad fa-h-square"></i>主页</a></li><li class=nav-item><a href=https://www.moonkite.cn/category/notes class=nav-link><i class='fas fa-yin-yang'></i>生活随笔</a></li><li class=nav-item><a href=javascript:void(0) class=nav-link><i class='fas fa-laptop-code'></i>技术文章</a><div class=sub-dropdown-menu><a class=sub-nav-link href=https://www.moonkite.cn/category/java><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 48 48"><path fill="#f44336" d="M23.65 24.898c-.998-1.609-1.722-2.943-2.725-5.455C19.229 15.2 31.24 11.366 26.37 3.999c2.111 5.089-7.577 8.235-8.477 12.473-.823 3.898 5.752 8.426 5.757 8.426z"/><path fill="#f44336" d="M23.878 17.27c-.192 2.516 2.229 3.857 2.299 5.695.056 1.496-1.447 2.743-1.447 2.743s2.728-.536 3.579-2.818c.945-2.534-1.834-4.269-1.548-6.298.267-1.938 6.031-5.543 6.031-5.543S24.311 11.611 23.878 17.27z"/><g><path fill="#1565c0" d="M32.084 25.055c1.754-.394 3.233.723 3.233 2.01.0 2.901-4.021 5.643-4.021 5.643s6.225-.742 6.225-5.505c0-3.15-3.057-3.937-5.437-2.148zm-2.955 2.34s1.941-1.383 2.458-1.902c-4.763 1.011-15.638 1.147-15.638.269.0-.809 3.507-1.638 3.507-1.638s-7.773-.112-7.773 2.181C11.683 28.695 21.858 28.866 29.129 27.395z"/><path fill="#1565c0" d="M27.935 29.571c-4.509 1.499-12.814 1.02-10.354-.993-1.198.0-2.974.963-2.974 1.889.0 1.857 8.982 3.291 15.63.572l-2.302-1.468z"/><path fill="#1565c0" d="M18.686 32.739c-1.636.0-2.695 1.054-2.695 1.822.0 2.391 9.76 2.632 13.627.205l-2.458-1.632C24.271 34.404 17.014 34.579 18.686 32.739z"/><path fill="#1565c0" d="M36.281 36.632c0-.936-1.055-1.377-1.433-1.588 2.228 5.373-22.317 4.956-22.317 1.784.0-.721 1.807-1.427 3.477-1.093l-1.42-.839C11.26 34.374 9 35.837 9 37.017 9 42.52 36.281 42.255 36.281 36.632z"/><path fill="#1565c0" d="M39 38.604c-4.146 4.095-14.659 5.587-25.231 3.057C24.341 46.164 38.95 43.628 39 38.604z"/></g></svg>&nbsp;可爱的 Java</a>
<a class=sub-nav-link href=https://www.moonkite.cn/category/SpringCloud><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 48 48"><path fill="#8bc34a" d="M43.982 23.635c.069-4.261-.891-9.328-2.891-15.273L39.523 3.7l-2.13 4.433c-.114.237-.244.469-.38.698C33.514 5.827 28.974 4 24 4 12.954 4 4 12.954 4 24s8.954 20 20 20 20-8.954 20-20C44 23.877 43.984 23.758 43.982 23.635z"/><path fill="#fff" d="M39.385 32.558C36.262 36.86 30.734 37.091 25.531 37H18.75h-1.938c4.428-1.593 7.063-1.972 9.754-3.4 5.068-2.665 10.078-8.496 11.121-14.562-1.93 5.836-7.779 10.85-13.109 12.889-3.652 1.393-10.248 2.745-10.248 2.745l-.267-.145C9.573 32.268 9.437 22.214 17.6 18.968c3.574-1.423 6.993-.641 10.854-1.593 4.122-1.012 8.89-4.208 10.83-8.375C41.456 15.667 44.07 26.106 39.385 32.558zM15.668 38.445C15.386 38.795 14.955 39 14.505 39c-.823.0-1.495-.677-1.495-1.5s.677-1.5 1.495-1.5c.341.0.677.118.941.336C16.086 36.855 16.186 37.805 15.668 38.445z"/></svg>&nbsp; Spring Cloud 系列</a>
<a class=sub-nav-link href=https://www.moonkite.cn/category/other><img width=20 height=20 src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAADWElEQVR4nO2X30tTYRjH9xd4X2Dsol1EEtJdEFiSF10pldlVaVHEjiFFkKQVQeV0kfSTHdfW1pzKlpZtzXJuzp2pmzPFTdmUTdLJlEAvNKyB8MYzPG/visHZ2jxrnQc+8PCc85zz/e592XkfkUgIIYT4v2OoTVrtVFDTjILaYmgK8YqC2oproalzKZlwKqga3sXTSeFuZts9ykWcNOXnbITcTj67IRQcG1rlE5/dECK3GXcjxC8ADwqMuxGfBMeGVklNaRmZ83z0L3+ZR3ywMBfInJHQqGl07esKAmYjK6hnJoph64Ar/KsOOXmNK6HOTszKtD9uJitGQGSRcQFDiqh1RHAd8nSMWMQSDJgRjLAhrIgxta3lDvaiRlMpxvKvbi3BCNfI+xVRehdRIT2DIUWdejeH65BzMWKd1KO6jqOYLrEE46fp7Bm5bgki0Q0bhhS1t3UM1yHnYuS1XY5Oy0swD8USjPNmQ2aNfO6WO0KjphHgbrc9XNjsirGwdeAY7Vpl65CT15LRYb4VltLHYyzKAwcxgw3Xwr5BQ9D9ll53dz9d+msjfNLfWoO6GstR7/0zCXXBCJMPKxLMl3kkmC9GQsTf706znK3vyKLdhtznL2ISPm5TaqQdro8DeTJxm4EHKDZRGQfy308HtdvAcJY1I3BsII8RpAgwwB41IE9mBAwgR0EcyMlrRcTxB45DgpFUV+RbSIMxuq4kXRFyFl+3VuTeiqBtQYCDqUxqhOyJPCsTjDDCitB5urW8zS2oTSzBxNS7MB3tpeiC4kicO8azCQLJnkB9Me750Xs44b4CmQcjc4SzZwSGHXL42Xy0B6NTHMIDUp36RIJAsmeS2od7vuuKE+4TEUMbDHGZMLLBNrlUV/3u9sYRwH7vkq/nZFmUJaotwfRoK5bk6qoooNRUh9kegOyZkpUtsT3zuvKE+6qev4myKF899nkNTeMTJuWsu6spTBjZ4GzESUv7+R6qmCQ4aeoTZyPDLy4XMTS1xrdo5k/WmDbpflEq4XpJ7XbS1O0+bYvnve7JLNCnkXkZWmrYCfo0Mi9+r7bFA1pAkyjd0Ov1EZVKhQDI034Q3++1mM39H8xmBECeEZV8vNdmtRptAwMojtVqzIjKHH6vEEIIIcrt+AnU4LBcH67z1wAAAABJRU5ErkJggg=="> &nbsp; 杂七杂八</a></div></li><li class=nav-item><a href=https://www.moonkite.cn/category/network class=nav-link><i class="fas fa-network-wired"></i>轻解计算机网络</a></li><li class=nav-item><a href=https://www.moonkite.cn/category/product class=nav-link><i class="fas fab fa-medapps"></i>我的产品</a></li></ul></div></nav></div><div class="container header-wrapper"><div class=row><div class=col-lg-12><div class=header-content><h1 class=header-title>JVM 内存溢出的原因及预防</h1><p class=header-date>作者：
风筝 /
2021-09-02<div class=header-underline></div><div class=header-date>&nbsp·&nbsp
  <span id=busuanzi_container_page_pv>本文被阅读<span id=busuanzi_value_page_pv></span>次</span></div><div class=clearfix></div><p class="float-right header-tags"><i class="fas fa-tags" aria-hidden=true></i>
<a href=https://www.moonkite.cn/tag/Java/>Java</a>,
<a href=https://www.moonkite.cn/tag/Java%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/>Java内存溢出</a>,
<a href=https://www.moonkite.cn/tag/JDK/>JDK</a>,
<a href=https://www.moonkite.cn/tag/JVM/>JVM</a>,
<a href=https://www.moonkite.cn/tag/%E6%A0%88%E6%BA%A2%E5%87%BA/>栈溢出</a></p></div></div></div></div></div><main><div class="container content"><article><p>我们都知道 Java 程序都是跑在 JVM 上的，一旦 JVM 有什么风吹草动，必然会影响服务的稳定性。幸运的话，服务会发生抖动，可能有部分请求出现延迟或异常。不幸的话，JVM 直接崩溃，导致服务完全中断。</p><p>这可不是什么好事，与 JVM 一起崩溃的，除了服务，还有我们的心态。</p><p>所谓的 JVM 崩溃，一般情况下就是指内存溢出，也就是 OutOfMemoryError 和 StackOverflowError。另外还有一种情况就是堆外内存占用过大，这种情况会导致 JVM 所在机器的内存被撑爆，从而导致机器重启等异常情况发生，我们把这种情况叫做内存泄漏。</p><p>那什么情况下会造成 JVM 崩溃呢，有哪几种类型的崩溃呢？俗话说，知己知彼，方能百战不殆。了解了发生崩溃的原因，才能更好的解决 JVM 崩溃问题。</p><p><img src=//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccf8e870e83a435e9684be5527ccc7a6~tplv-k3u1fbpfcp-zoom-1.image alt=image-20201016165948638></p><p>首先还是放出 JVM 内存模型图，JVM 要理解起来是很抽象的，借助下面这张图可以具象化的了解 JVM 内存模型，而发生溢出的几个部分都可以在图中找到。在 JDK 8 中，永久代已经不存在了，取而代之的是元空间（metaspace）。</p><p><img src=//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad12b760a3e64e179acff90d4041a911~tplv-k3u1fbpfcp-zoom-1.image alt=image-20201019183925854></p><p>下面就以 Hotspot JDK 8 为背景，看一下 JVM 内存溢出和内存泄漏的几种情况。</p><p>首先设置 JVM 启动参数，限制堆空间大小，堆空间设置为 20M，其中新生代10M，元空间10M，并指定垃圾收集算法采用 CMS 算法。之后的例子都会使用这套参数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>-XX:+UseConcMarkSweepGC
</span></span><span class=line><span class=cl>-XX:+UseCMSInitiatingOccupancyOnly
</span></span><span class=line><span class=cl>-XX:CMSInitiatingOccupancyFraction<span class=o>=</span><span class=m>70</span>
</span></span><span class=line><span class=cl>-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses
</span></span><span class=line><span class=cl>-XX:+CMSClassUnloadingEnabled
</span></span><span class=line><span class=cl>-XX:+ParallelRefProcEnabled
</span></span><span class=line><span class=cl>-XX:+CMSScavengeBeforeRemark
</span></span><span class=line><span class=cl>-verbose:gc
</span></span><span class=line><span class=cl>-Xms20M
</span></span><span class=line><span class=cl>-Xmx20M
</span></span><span class=line><span class=cl>-Xmn10M
</span></span><span class=line><span class=cl>-XX:+PrintGCDetails
</span></span><span class=line><span class=cl>-XX:SurvivorRatio<span class=o>=</span><span class=m>8</span>
</span></span><span class=line><span class=cl>-XX:+HeapDumpOnOutOfMemoryError
</span></span><span class=line><span class=cl>-XX:MetaspaceSize<span class=o>=</span>10M
</span></span><span class=line><span class=cl>-XX:MaxMetaspaceSize<span class=o>=</span>10M
</span></span><span class=line><span class=cl>-XX:HeapDumpPath<span class=o>=</span>/Users/fengzheng/jvmlog
</span></span></code></pre></div><h2 id=堆溢出>堆溢出</h2><p>堆溢出，应该是最常见的一种内存溢出的场景了。JVM 中分配绝大多数对象实例和数组都存在堆上，另外堆内存也是垃圾收集器工作的主要战场。</p><p>当我们的 Java 程序启动的时候，会指定堆空间的大小，新建对象和数组的时候会分配到堆上面，当新对象申请空间的时候，如果堆内存不够了，就会发生垃圾收集动作，大多数时候会发生在新生代，叫做 Minor GC。当新生代回收完成，空间仍然不够的话，会发生一次 FullGC。FullGC 后，空间仍然不够，此时就会发生 OOM 错误，也就是堆溢出。</p><h3 id=模拟一下这个场景>模拟一下这个场景</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>final</span> <span class=kd>static</span> <span class=kt>int</span> <span class=n>_1K</span> <span class=o>=</span> <span class=mi>1024</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>){</span>
</span></span><span class=line><span class=cl>  <span class=n>List</span><span class=o>&lt;</span><span class=kt>byte</span><span class=o>[]&gt;</span> <span class=n>byteList</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>  <span class=n>quietlyWaitingForCrashHeap</span><span class=o>(</span><span class=n>byteList</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>quietlyWaitingForCrashHeap</span><span class=o>(</span><span class=n>List</span><span class=o>&lt;</span><span class=kt>byte</span><span class=o>[]&gt;</span> <span class=n>byteList</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=o>(</span><span class=kc>true</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>byteList</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=kt>byte</span><span class=o>[</span><span class=mi>500</span> <span class=o>*</span> <span class=n>_1K</span><span class=o>]);</span>
</span></span><span class=line><span class=cl>      <span class=c1>//Thread.sleep(1000);
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>Thread</span><span class=o>.</span><span class=na>sleep</span><span class=o>(</span><span class=mi>100</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>InterruptedException</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>上面的方法会持续的向<code>List&lt;byte[]></code>数组中每次添加500k的元素，整个堆只有20M，可想而知，程序一运行起来，马上就会将对空间填满，导致后面的元素加不进去，而又回收不掉，从而导致堆内存溢出。</p><p>下面是程序运行之后的结果，经过垃圾回收最终还是没有多余的空间，从而发生 <code>java.lang.OutOfMemoryError: Java heap space</code>异常。</p><p><img src=//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3771d9e922c34f38a68e7ecdd1331286~tplv-k3u1fbpfcp-zoom-1.image alt=image-20201016211017630></p><p>发生堆内存溢出的根本原因就是使用中的对象大小超过了堆内存大小。</p><p>堆内存空间设置的太小，要根据预估的实际使用堆大小合理的设置堆空间设置。</p><p>程序有漏洞导致，某些静态变量持续的增大，例如缓存数据错误的初始化，导致缓存无止境的增加，最终导致堆内存溢出。针对这种情况，恐怕没什么好方法，除了做好测试之外，就是在问题发生后做好日志分析。</p><h2 id=栈溢出>栈溢出</h2><p>虚拟机栈是用来存储局部变量表、操作数栈、动态链接、方法出口等信息的，每调用一个 Java 方法就会为此方法在虚拟机栈中生成栈帧。</p><p>栈除了包括虚拟机栈之外，还包括本地方法栈，当调用的方法是本地方法（例如 C 语言实现的方法）时，会用到本地方法栈。不过，在 HotSpot 虚拟机中，虚拟机栈和本地方法栈被合二为一了。</p><h3 id=模拟栈溢出场景>模拟栈溢出场景</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>){</span>
</span></span><span class=line><span class=cl>  <span class=n>stackOverflow</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>* stackoverflow
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>stackOverflow</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=n>stackOverflow</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>在上面的代码中，stackOverflow() 方法的调用是一个无限递归的过程，没有递归出口。前面说了，每调用一个方法就会在虚拟机栈中生成栈帧，无限的递归，必定造成无限的生成栈帧，最后导致栈空间被填满，从而发生溢出。</p><p><img src=//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0144fcce3ffb48d480f455788623e403~tplv-k3u1fbpfcp-zoom-1.image alt=image-20201019122447325></p><p>上面模拟了最常见的一种状况，产生这种状况的原因很可能是由于程序 bug 导致的，一般来说，递归必定会有递归出口，如果由于某些原因导致了程序在执行的过程中无法达到出口条件，那就会造成这种异常。还有就是循环体，循环体的循环次数如果过大，也有可能出现栈溢出。</p><p>另外还可能是其他比较不容易出现的原因，比如创建的线程数过多，线程创建要在虚拟机栈中分配空间，如果创建线程过多，可能会出现 <code>OutOfMemoryError</code>异常，但是一般来说，都会用线程池的方法代替手动创建线程的方式，所以，这种情况不容易出现。</p><h2 id=元空间溢出>元空间溢出</h2><p>用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译(JIT)后的代码等数据，在 JDK 8 中，已经用 metaSpace 代替了永久代的。默认情况下 metaSpace 的大小是没有限制的，也就是所在服务器的实际内存大小，但是，一般情况下，最好还是设置元空间的大小。</p><p>一般在产生大量动态生成类的情景中，可能会出现元空间的内存溢出。</p><h3 id=模拟元空间溢出>模拟元空间溢出</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>){</span>
</span></span><span class=line><span class=cl>  <span class=n>List</span><span class=o>&lt;</span><span class=kt>byte</span><span class=o>[]&gt;</span> <span class=n>byteList</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>  <span class=c1>//quietlyWaitingForCrashHeap(byteList);
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// stackOverflow();
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>methodAreaOverflow</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>methodAreaOverflow</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=o>(</span><span class=kc>true</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Enhancer</span> <span class=n>enhancer</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Enhancer</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>enhancer</span><span class=o>.</span><span class=na>setUseCache</span><span class=o>(</span><span class=kc>false</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>enhancer</span><span class=o>.</span><span class=na>setSuperclass</span><span class=o>(</span><span class=n>MethodOverflow</span><span class=o>.</span><span class=na>class</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>enhancer</span><span class=o>.</span><span class=na>setCallback</span><span class=o>(</span><span class=k>new</span> <span class=n>MethodInterceptor</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>      <span class=kd>public</span> <span class=n>Object</span> <span class=nf>intercept</span><span class=o>(</span><span class=n>Object</span> <span class=n>o</span><span class=o>,</span> <span class=n>Method</span> <span class=n>method</span><span class=o>,</span> <span class=n>Object</span><span class=o>[]</span> <span class=n>objects</span><span class=o>,</span> <span class=n>MethodProxy</span> <span class=n>methodProxy</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>Throwable</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>methodProxy</span><span class=o>.</span><span class=na>invokeSuper</span><span class=o>(</span><span class=n>o</span><span class=o>,</span> <span class=n>objects</span><span class=o>);</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>});</span>
</span></span><span class=line><span class=cl>    <span class=n>enhancer</span><span class=o>.</span><span class=na>create</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(++</span><span class=n>i</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>通过 CGLIB 的方式动态的创建很多个动态类，这样一来，类信息就会越来越多的存到元空间，从而导致元空间溢出。</p><p><img src=//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e20f0e634ef341ee8a0617e62c2768c0~tplv-k3u1fbpfcp-zoom-1.image alt=image-20201019163227576></p><p>例如在使用 Spring、 MyBatis 等技术框架的时候会动态创建 Bean 实例类，另外，Spring AOP 也会产生动态代理类。</p><h2 id=堆外内存溢出>堆外内存溢出</h2><p>大多数情况下，内存都会在 JVM 堆内存中分配，很少情况下需要直接在堆外分配内存空间。使用堆外内存的几个好处是：</p><ul><li>在进程间可以共享，减少虚拟机间的复制</li><li>对垃圾回收停顿的改善：如果应用某些长期存活并大量存在的对象，经常会出发YGC或者FullGC，可以考虑把这些对象放到堆外。过大的堆会影响Java应用的性能。如果使用堆外内存的话，堆外内存是直接受操作系统管理( 而不是虚拟机 )。这样做的结果就是能保持一个较小的堆内内存，以减少垃圾收集对应用的影响。</li><li>在某些场景下可以提升程序I/O操纵的性能。少去了将数据从堆内内存拷贝到堆外内存的步骤。</li></ul><p>通常在需要大量频繁的进行 IO 操作的时候会用到堆外内存，例如 Netty、RocketMQ 等使用到了堆外内存，目的就是为了加快速度。</p><p>所以，在出现系统内存占用过大的情况时，排查堆栈无果后，可以看一下堆外内存的使用情况，看看是不是堆外内存溢出了。</p><h2 id=总结>总结</h2><h3 id=事前做好配置>事前做好配置</h3><p>JVM 问题本身就是比较抽象和难以直观发现的，所以在项目上线前除了做好代码逻辑的测试外，还要对 JVM 参数进行合理配置，根据应用程序的体量和特点选择好合适的参数，比如堆栈大小、垃圾收集器种类等等。</p><p>另外，垃圾收集日志一定要有保留，还有就是发生内存溢出时要保存 dump 文件。</p><h3 id=事中做好监控>事中做好监控</h3><p>在程序上线运行的过程中，做好 JVM 的监控工作，比如用 Spring Admin 这种比较轻量的监控工具，或者大型项目用 Cat、SkyWallking 等这些分布式链路监控系统。</p><h3 id=事后做好现场保护和分析>事后做好现场保护和分析</h3><p>再合理的参数配置和监控平台，也难免不发生异常，这也是很正常的，不出现异常才有问题好吧。在发生异常之后，要及时的保留现场，如果是多实例应用，可以暂时将发生异常的实例做下线处理，然后再进行问题的排查。如果是单实例的服务，那要及时的确认最新的日志和dump已经留存好，确认完成后，再采取错误让服务重启。</p></article><div class=toc><h2>文章目录</h2><nav id=TableOfContents><ul><li><a href=#堆溢出>堆溢出</a><ul><li><a href=#模拟一下这个场景>模拟一下这个场景</a></li></ul></li><li><a href=#栈溢出>栈溢出</a><ul><li><a href=#模拟栈溢出场景>模拟栈溢出场景</a></li></ul></li><li><a href=#元空间溢出>元空间溢出</a><ul><li><a href=#模拟元空间溢出>模拟元空间溢出</a></li></ul></li><li><a href=#堆外内存溢出>堆外内存溢出</a></li><li><a href=#总结>总结</a><ul><li><a href=#事前做好配置>事前做好配置</a></li><li><a href=#事中做好监控>事中做好监控</a></li><li><a href=#事后做好现场保护和分析>事后做好现场保护和分析</a></li></ul></li></ul></nav></div><script>window.addEventListener("scroll",function(){var e=document.querySelector(".toc"),t=window.pageYOffset||document.documentElement.scrollTop,n=window.innerWidth||document.documentElement.clientWidth;t<360?e.style.top=380-t+"px":e.style.top="20px",n<1500?e.style.left="20px":e.style.left="100px"})</script><h4>相关文章</h4><dl class=row><dd class=col-md-9><a href=/category/java/JDK17/>新项目为什么决定用 JDK 17了</a></dd><dd class=col-md-9><a href=/category/java/Graalvm/>过两年 JVM 可能就要被GraalVM替代了</a></dd><dd class=col-md-9><a href=/category/java/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E8%87%AA%E5%B7%B1%E7%9A%84-JDK/>手把手教你编译属于自己的 JDK</a></dd><dd class=col-md-9><a href=/category/java/Java-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%97/>Java 字符串常量池漫游指南（图文并茂）</a></dd><dd class=col-md-9><a href=/category/java/%E7%BA%BF%E4%B8%8AJava%E7%A8%8B%E5%BA%8F%E5%8D%A0%E7%94%A8-CPU-%E8%BF%87%E9%AB%98%E8%AF%B7%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95/>线上Java程序占用 CPU 过高，请说一下排查方法？</a></dd></dl><div class=author-card><div class=underline></div><div class=author-box><div class=qr-author-image><a href=/><img src=/images/person.jpg alt=风筝></a></div><div class=author-content><p class=author-title>作者</p><p class=author-name>风筝</p><p class=author-desc>古时的风筝，一个平庸的程序员，主语言 Java，第二语言 Python，其实学 Python 的时间比 Java 还要早。喜欢写博客，写博客的过程能加深自己对一个知识点的理解，同时还可以分享给他人。喜欢做一些小东西，所以也会一些前端的东西，React、JavaScript、CSS 都会一些，做一些小工具还够用。</p></div></div></div><script src=https://utteranc.es/client.js repo=huzhicheng/blog-comment issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></main><div class="footer gradient-2"><div class="container footer-container"><div class=row><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>网站地图</div><ul class=list-unstyled><li><a href=https://www.moonkite.cn/tags/>标签</a></li><li><a href=https://www.moonkite.cn/categories/>分类</a></li><li><a rel=alternate type=application/rss+xml href=https://www.moonkite.cn/index.xml><i class="fas fa-rss-square"></i> RSS订阅</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>社群</div><ul class=list-unstyled><li><a href=https://github.com/huzhicheng rel=noopener target=_blank>GitHub</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>友链</div><ul class=list-unstyled><li><a href=https://github.com/huzhicheng rel=noopener target=_blank>关于我</a></li></ul></div><div class="col-xs-12 col-sm-3 col-md-3 col-lg-3"><p class="pull-right text-right"><small><em>Proudly powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo</a></em></small><br><small><em>Theme - <a href=https://github.com/shaform/hugo-theme-den rel=noopener target=_blank>Den</a></em></small><br><small>&copy;
风筝
2023</small></p></div></div><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?e417ddf834c7bb7411207e1fa09815aa",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-C714TFXRD4"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-C714TFXRD4")</script><div class=busuanzi-footer><span id=busuanzi_container_site_pv>本站总访问量<span id=busuanzi_value_site_pv></span>次</span>
<span id=busuanzi_container_site_uv>本站访客数<span id=busuanzi_value_site_uv></span>人次</span></div></div></div><script src=https://code.jquery.com/jquery-3.3.1.slim.min.js integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap_4.1.3_js_bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script>
<script>$(document).ready(function(){$("#load_disqus").length&&$(window).scroll(function(){if($("#load_disqus").length){var e=$("#load_disqus").offset().top,t=$(window).scrollTop(),n=t+$(window).height();t<e&&e<n&&load_disqus()}})})</script></body></html>