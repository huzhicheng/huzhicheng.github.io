<!doctype html><html lang=zh-cn itemscope itemtype=http://schema.org/WebPage><head><meta name=generator content="Hugo 0.113.0"><meta charset=utf-8><title>Java 字符串常量池漫游指南（图文并茂） · 古时的风筝</title><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=description content="之前发过这篇文章，但是文中的例子有点错误，都是用的字面量当参数，虽然结论是没有问题的，但是根据例子推导结论其实是有问题的，这里重新把有问题的"><meta name=keywords content="Hugo,theme,编程,java,ChatGPT,程序员,开发"><link rel=canonical href=https://moonkite.cn/category/java/Java-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%97/><link rel=icon href=https://moonkite.cn/images/photo.png><link rel=stylesheet href=https://cdn.usebootstrap.com/bootstrap/4.1.3/css/bootstrap.min.css><link rel=stylesheet href=https://moonkite.cn/css/den.css><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><meta name=referrer content="no-referrer-when-downgrade"><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?e417ddf834c7bb7411207e1fa09815aa",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><meta property="og:title" content="Java 字符串常量池漫游指南（图文并茂）"><meta property="og:description" content="之前发过这篇文章，但是文中的例子有点错误，都是用的字面量当参数，虽然结论是没有问题的，但是根据例子推导结论其实是有问题的，这里重新把有问题的"><meta property="og:type" content="article"><meta property="og:url" content="https://moonkite.cn/category/java/Java-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%97/"><meta property="article:section" content="category"><meta property="article:published_time" content="2021-04-02T08:56:23+08:00"><meta property="article:modified_time" content="2021-04-02T08:56:23+08:00"><meta itemprop=name content="Java 字符串常量池漫游指南（图文并茂）"><meta itemprop=description content="之前发过这篇文章，但是文中的例子有点错误，都是用的字面量当参数，虽然结论是没有问题的，但是根据例子推导结论其实是有问题的，这里重新把有问题的"><meta itemprop=datePublished content="2021-04-02T08:56:23+08:00"><meta itemprop=dateModified content="2021-04-02T08:56:23+08:00"><meta itemprop=wordCount content="3246"><meta itemprop=keywords content="Java,JDK,JVM,Java字符串,String,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java 字符串常量池漫游指南（图文并茂）"><meta name=twitter:description content="之前发过这篇文章，但是文中的例子有点错误，都是用的字面量当参数，虽然结论是没有问题的，但是根据例子推导结论其实是有问题的，这里重新把有问题的"></head><body><div class=header-container style=background:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2)),url(https://moonkite.cn/images/background.png);background-position:top;background-size:cover><div class=container><nav class="header-nav navbar navbar-expand-md navbar-dark light-dark"><div class="header-logo navbar-brand"><a class=float-left href=https://moonkite.cn/></a></div><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarNav aria-controls=navbarNav aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="nav-menu collapse navbar-collapse" id=navbarNav><ul class=navbar-nav><li class=nav-item><a href=https://moonkite.cn/ class=nav-link><i class="fas fad fa-h-square"></i>主页</a></li><li class=nav-item><a href=https://moonkite.cn/category/notes/ class=nav-link><i class='fas fa-yin-yang'></i>生活随笔</a></li><li class=nav-item><a href=javascript:void(0) class=nav-link><i class='fas fa-laptop-code'></i>技术文章</a><div class=sub-dropdown-menu><a class=sub-nav-link href=https://moonkite.cn/category/java><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 48 48"><path fill="#f44336" d="M23.65 24.898c-.998-1.609-1.722-2.943-2.725-5.455C19.229 15.2 31.24 11.366 26.37 3.999c2.111 5.089-7.577 8.235-8.477 12.473-.823 3.898 5.752 8.426 5.757 8.426z"/><path fill="#f44336" d="M23.878 17.27c-.192 2.516 2.229 3.857 2.299 5.695.056 1.496-1.447 2.743-1.447 2.743s2.728-.536 3.579-2.818c.945-2.534-1.834-4.269-1.548-6.298.267-1.938 6.031-5.543 6.031-5.543S24.311 11.611 23.878 17.27z"/><g><path fill="#1565c0" d="M32.084 25.055c1.754-.394 3.233.723 3.233 2.01.0 2.901-4.021 5.643-4.021 5.643s6.225-.742 6.225-5.505c0-3.15-3.057-3.937-5.437-2.148zm-2.955 2.34s1.941-1.383 2.458-1.902c-4.763 1.011-15.638 1.147-15.638.269.0-.809 3.507-1.638 3.507-1.638s-7.773-.112-7.773 2.181C11.683 28.695 21.858 28.866 29.129 27.395z"/><path fill="#1565c0" d="M27.935 29.571c-4.509 1.499-12.814 1.02-10.354-.993-1.198.0-2.974.963-2.974 1.889.0 1.857 8.982 3.291 15.63.572l-2.302-1.468z"/><path fill="#1565c0" d="M18.686 32.739c-1.636.0-2.695 1.054-2.695 1.822.0 2.391 9.76 2.632 13.627.205l-2.458-1.632C24.271 34.404 17.014 34.579 18.686 32.739z"/><path fill="#1565c0" d="M36.281 36.632c0-.936-1.055-1.377-1.433-1.588 2.228 5.373-22.317 4.956-22.317 1.784.0-.721 1.807-1.427 3.477-1.093l-1.42-.839C11.26 34.374 9 35.837 9 37.017 9 42.52 36.281 42.255 36.281 36.632z"/><path fill="#1565c0" d="M39 38.604c-4.146 4.095-14.659 5.587-25.231 3.057C24.341 46.164 38.95 43.628 39 38.604z"/></g></svg>&nbsp;可爱的 Java</a>
<a class=sub-nav-link href=https://moonkite.cn/category/SpringCloud><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 48 48"><path fill="#8bc34a" d="M43.982 23.635c.069-4.261-.891-9.328-2.891-15.273L39.523 3.7l-2.13 4.433c-.114.237-.244.469-.38.698C33.514 5.827 28.974 4 24 4 12.954 4 4 12.954 4 24s8.954 20 20 20 20-8.954 20-20C44 23.877 43.984 23.758 43.982 23.635z"/><path fill="#fff" d="M39.385 32.558C36.262 36.86 30.734 37.091 25.531 37H18.75h-1.938c4.428-1.593 7.063-1.972 9.754-3.4 5.068-2.665 10.078-8.496 11.121-14.562-1.93 5.836-7.779 10.85-13.109 12.889-3.652 1.393-10.248 2.745-10.248 2.745l-.267-.145C9.573 32.268 9.437 22.214 17.6 18.968c3.574-1.423 6.993-.641 10.854-1.593 4.122-1.012 8.89-4.208 10.83-8.375C41.456 15.667 44.07 26.106 39.385 32.558zM15.668 38.445C15.386 38.795 14.955 39 14.505 39c-.823.0-1.495-.677-1.495-1.5s.677-1.5 1.495-1.5c.341.0.677.118.941.336C16.086 36.855 16.186 37.805 15.668 38.445z"/></svg>&nbsp; Spring Cloud 系列</a></div></li><li class=nav-item><a href=https://moonkite.cn/category/network class=nav-link><i class="fas fa-network-wired"></i>轻解计算机网络</a></li><li class=nav-item><a href=https://moonkite.cn/category/product class=nav-link><i class="fas fab fa-medapps"></i>我的产品</a></li></ul></div></nav></div><div class="container header-wrapper"><div class=row><div class=col-lg-12><div class=header-content><h1 class=header-title>Java 字符串常量池漫游指南（图文并茂）</h1><p class=header-date>作者：
风筝 /
2021-04-02<div class=header-underline></div><div class=header-date>&nbsp·&nbsp
  <span id=busuanzi_container_page_pv>本文被阅读<span id=busuanzi_value_page_pv></span>次</span></div><div class=clearfix></div><p class="float-right header-tags"><i class="fas fa-tags" aria-hidden=true></i>
<a href=https://moonkite.cn/tag/Java/>Java</a>,
<a href=https://moonkite.cn/tag/Java%E5%AD%97%E7%AC%A6%E4%B8%B2/>Java字符串</a>,
<a href=https://moonkite.cn/tag/JDK/>JDK</a>,
<a href=https://moonkite.cn/tag/JVM/>JVM</a>,
<a href=https://moonkite.cn/tag/String/>String</a></p></div></div></div></div></div><main><div class="container content"><article><p>之前发过这篇文章，但是文中的例子有点错误，都是用的字面量当参数，虽然结论是没有问题的，但是根据例子推导结论其实是有问题的，这里重新把有问题的例子和图都替换了，因为已发送的文章只能修改几个字，所以这里重新发一遍。以免误人子弟。</p><blockquote><p>字符串问题可谓是 Java 中经久不衰的问题，尤其是字符串常量池经常作为面试题出现。可即便是看似简单而又经常被提起的问题，还是有好多同学一知半解，看上去懂了，仔细分析起来却又发现不太明白。</p></blockquote><h3 id=背景说明>背景说明</h3><p>本文以 JDK 1.8 为讨论版本，虽然现在都已经 JDK 14了，奈何我们还是钟爱 1.8。</p><h2 id=一个提问引起的讨论>一个提问引起的讨论</h2><p>为什么说到字符串常量呢，源于群里为数不多的一个程序员小姐姐的提问。</p><p><img src=https://hexo.moonkite.cn/blog/0.png alt=0></p><p>这本来和字符串常量没有关系，后来，一个同学说不只是 int ，换成 String 一样可以。</p><p><img src=https://hexo.moonkite.cn/blog/1.png alt=2></p><p>为什么会有"Java开发_北京"这么奇特的字符串乱入呢，因为提出问题的这位小姐姐的群昵称叫这个，所以群里的同学开玩笑说，以为她是某个房地产大佬，要来开发北京。</p><p><img src=https://hexo.moonkite.cn/blog/2.jpg alt=2></p><p><strong>以上是开个玩笑，好了，收。</strong></p><p>字符串用 == 比较也是 true，这就有意思了。马上有机灵的小伙伴说这和字符串常量池有关系。没错，就是因为字符串常量池的原因。</p><p>第一张图其实没什么好说的，在 JDK 1.8 之后已经不允许 Object 和 int 类型用 == 相比较了，编译直接报错。</p><p>第二张图中的代码才是重点要说的，我们可以把它简化成下面这段代码，用 == 符号比较字符串，之后的内容都从这几行代码出发。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>   <span class=n>String</span> <span class=n>s1</span> <span class=o>=</span> <span class=s>&#34;古时的风筝&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>   <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>s1</span> <span class=o>==</span> <span class=s>&#34;古时的风筝&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>当然，实际开发中强烈不推荐用 == 符号判断两个字符串是否相等，应该用 equals() 方法。</p><h2 id=字符串常量池何许人也>字符串常量池何许人也</h2><p>为什么要有字符串常量池呢，像其他对象一样直接存在堆中不行吗，这就要问 Java 语言的设计者了，当然，这么做也并不是拍脑袋想出来的。</p><p>这就要从字符串说起。</p><p>首先对象的分配要付出时间和空间上的开销，字符串可以说是和 8 个基本类型一样常用的类型，甚至比 8 个基本类型更加常用，故而频繁的创建字符串对象，对性能的影响是非常大的，所以，用常量池的方式可以很大程度上降低对象创建、分配的次数，从而提升性能。</p><p>在 JDK 1.7 之后(包括1.7)，字符串常量池已经从方法区移到了堆中。</p><h3 id=字面量赋值>字面量赋值</h3><p>我们把上面的那个实例代码拿过来</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>String</span> <span class=n>s1</span> <span class=o>=</span> <span class=s>&#34;古时的风筝&#34;</span><span class=o>;</span>
</span></span></code></pre></div><p>这是我们平时声明字符串变量的最常用的方式，这种方式叫做字面量声明，也就用把字符串用双引号引起来，然后赋值给一个变量。</p><p>这种情况下会直接将字符串放到字符串常量池中，然后返回给变量。</p><p><img src=https://hexo.moonkite.cn/blog/3.png alt=3></p><p>那这是我再声明一个内容相同的字符串，会发现字符串常量池中已经存在了，那直接指向常量池中的地址即可。</p><p><img src=https://hexo.moonkite.cn/blog/3-1.png alt=3-1></p><p>例如上图所示，声明了 s1 和 s2，到最后都是指向同一个常量池的地址，所以 s1== s2 的结果是 true。</p><h3 id=new-string-方式>new String() 方式</h3><p>与之对应的是用 new String() 的方式，但是基本上不建议这么用，除非有特殊的逻辑需要。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>String</span> <span class=n>a</span> <span class=o>=</span> <span class=s>&#34;古时的&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=n>String</span> <span class=n>s2</span> <span class=o>=</span> <span class=k>new</span> <span class=n>String</span><span class=o>(</span><span class=n>a</span> <span class=o>+</span> <span class=s>&#34;风筝&#34;</span><span class=o>);</span>
</span></span></code></pre></div><p>使用这种方式声明字符串变量的时候，会有两种情况发生。</p><h5 id=第一种情况字符串常量池之前已经存在相同字符串>第一种情况，字符串常量池之前已经存在相同字符串</h5><p>比如在使用 new 之前，已经用字面量声明的方式声明了一个变量，此时字符串常量池中已经存在了相同内容的字符串常量。</p><ol><li>首先会在堆中创建一个 s2 变量的对象引用；</li><li>然后将这个对象引用指向字符串常量池中的已经存在的常量；</li></ol><p><img src=https://hexo.moonkite.cn/blog/4.png alt=4></p><h5 id=第二种情况字符串常量池中不存在相同内容的常量>第二种情况，字符串常量池中不存在相同内容的常量</h5><p>之前没有任何地方用到了这个字符串，第一次声明这个字符串就用的是 new String() 的方式，这种情况下会直接在堆中创建一个字符串对象然后返回给变量。</p><p><img src=https://hexo.moonkite.cn/blog/5.png alt=5></p><p><strong>我看到好多地方说，如果字符串常量池中不存在的话，就先把字符串先放进去，然后再引用字符串常量池的这个常量对象，这种说法是有问题的，只是 new String() 的话，如果池中没有也不会放一份进去。</strong></p><p>基于 new String() 的这种特性，我们可以得出一个结论：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>String</span> <span class=n>s1</span> <span class=o>=</span> <span class=s>&#34;古时的风筝&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=n>String</span> <span class=n>a</span> <span class=o>=</span> <span class=s>&#34;古时的&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=n>String</span> <span class=n>s2</span> <span class=o>=</span> <span class=k>new</span> <span class=n>String</span><span class=o>(</span><span class=n>a</span> <span class=o>+</span> <span class=s>&#34;风筝&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>String</span> <span class=n>s3</span> <span class=o>=</span> <span class=k>new</span> <span class=n>String</span><span class=o>(</span><span class=n>a</span> <span class=o>+</span> <span class=s>&#34;风筝&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>s1</span><span class=o>==</span><span class=n>s2</span><span class=o>);</span> <span class=c1>// false
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>s2</span><span class=o>==</span><span class=n>s3</span><span class=o>);</span>  <span class=c1>// false 
</span></span></span></code></pre></div><p>以上代码，肯定输出的都是 false，因为 new String() 不管你常量池中有没有，我都会在堆中新建一个对象，新建出来的对象，当然不会和其他对象相等。</p><h3 id=intern-池化>intern() 池化</h3><p>那什么时候会放到字符串常量池呢，就是在使用 intern() 方法之后。</p><p>intern() 的定义：如果当前字符串内容存在于字符串常量池，存在的条件是使用 equas() 方法为ture，也就是内容是一样的，那直接返回此字符串在常量池的引用；如果之前不在字符串常量池中，那么在常量池创建一个引用并且指向堆中已存在的字符串，然后返回常量池中的地址。</p><h5 id=第一种情况准备池化的字符串与字符串常量池中的字符串有相同equas判断>第一种情况，准备池化的字符串与字符串常量池中的字符串有相同(equas()判断)</h5><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>String</span> <span class=n>s1</span> <span class=o>=</span> <span class=s>&#34;古时的风筝&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=n>String</span> <span class=n>a</span> <span class=o>=</span> <span class=s>&#34;古时的&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=n>String</span> <span class=n>s2</span> <span class=o>=</span> <span class=k>new</span> <span class=n>String</span><span class=o>(</span><span class=n>a</span> <span class=o>+</span> <span class=s>&#34;风筝&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>s2</span> <span class=o>=</span> <span class=n>s2</span><span class=o>.</span><span class=na>intern</span><span class=o>();</span>
</span></span></code></pre></div><p>这时，这个字符串常量已经在常量池存在了，这时，再 new 了一个新的对象 s2，并在堆中创建了一个相同字符串内容的对象。</p><p><img src=https://hexo.moonkite.cn/blog/5-1.png alt=5-1></p><p>这时，s1 == s2 会返回 fasle。然后我们调用 s2 = s2.intern()，将池化操作返回的结果赋值给 s2，就会发生如下的变化。</p><p><img src=https://hexo.moonkite.cn/blog/5-2.png alt=5-2></p><p>此时，再次判断 s1 == s2 ，就会返回 true，因为它们都指向了字符串常量池的同一个字符串。</p><h5 id=第二种情况字符串常量池中不存在相同内容的字符串>第二种情况，字符串常量池中不存在相同内容的字符串</h5><p>使用 new String() 在堆中创建了一个字符串对象</p><p><img src=https://hexo.moonkite.cn/blog/5.png alt=5></p><p>使用了 intern() 之后发生了什么呢，在常量池新增了一个对象，但是 <strong>并没有</strong> 将字符串复制一份到常量池，而是直接指向了之前已经存在于堆中的字符串对象。因为在 JDK 1.7 之后，字符串常量池不一定就是存字符串对象的，还有可能存储的是一个指向堆中地址的引用，现在说的就是这种情况，注意了，下图是只调用了 <code>s2.intern()</code>，并没有返回给一个变量。其中字符串常量池（0x88）指向堆中字符串对象（0x99）就是intern() 的过程。</p><p><img src=https://hexo.moonkite.cn/blog/6.png alt=6></p><p>只有当我们把 s2.intern() 的结果返回给 s2 时，s2 才真正的指向字符串常量池。</p><p><img src=https://hexo.moonkite.cn/blog/7.png alt=7></p><h3 id=我明白了>我明白了</h3><p>通过以上的介绍，我们来看下面的一段代码返回的结果是什么</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Test</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>String</span> <span class=n>s1</span> <span class=o>=</span> <span class=s>&#34;古时的风筝&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>String</span> <span class=n>s2</span> <span class=o>=</span> <span class=s>&#34;古时的风筝&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>String</span> <span class=n>a</span> <span class=o>=</span> <span class=s>&#34;古时的&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>      
</span></span><span class=line><span class=cl>        <span class=n>String</span> <span class=n>s3</span> <span class=o>=</span> <span class=k>new</span> <span class=n>String</span><span class=o>(</span><span class=n>a</span> <span class=o>+</span> <span class=s>&#34;风筝&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>String</span> <span class=n>s4</span> <span class=o>=</span> <span class=k>new</span> <span class=n>String</span><span class=o>(</span><span class=n>a</span> <span class=o>+</span> <span class=s>&#34;风筝&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>s1</span> <span class=o>==</span> <span class=n>s2</span><span class=o>);</span> <span class=c1>// 【1】 true
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>s2</span> <span class=o>==</span> <span class=n>s3</span><span class=o>);</span> <span class=c1>// 【2】 false
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>s3</span> <span class=o>==</span> <span class=n>s4</span><span class=o>);</span> <span class=c1>// 【3】 false
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>s3</span><span class=o>.</span><span class=na>intern</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>s2</span> <span class=o>==</span> <span class=n>s3</span><span class=o>);</span> <span class=c1>// 【4】 false
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>s3</span> <span class=o>=</span> <span class=n>s3</span><span class=o>.</span><span class=na>intern</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>s2</span> <span class=o>==</span> <span class=n>s3</span><span class=o>);</span> <span class=c1>// 【5】 true
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>s4</span> <span class=o>=</span> <span class=n>s4</span><span class=o>.</span><span class=na>intern</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>s3</span> <span class=o>==</span> <span class=n>s4</span><span class=o>);</span> <span class=c1>// 【6】 true
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>【1】：s1 == s2 返回 ture，因为都是字面量声明，全都指向字符串常量池中同一字符串。</p><p>【2】: s2 == s3 返回 false，因为 new String() 是在堆中新建对象，所以和常量池的常量不相同。</p><p>【3】: s3 == s4 返回 false，都是在堆中新建对象，所以是两个对象，肯定不相同。</p><p>【4】: s2 == s3 返回 false，前面虽然调用了 intern() ，但是没有返回，不起作用。</p><p>【5】: s2 == s3 返回 ture，前面调用了 intern() ，并且返回给了 s3 ，此时 s2、s3 都直接指向常量池的同一个字符串。</p><p>【6】: s3 == s4 返回 true，和 s3 相同，都指向了常量池同一个字符串。</p><h2 id=为啥我字符串就不可变>为啥我字符串就不可变</h2><p>字符串常量池的基础就是字符串的不可变性，如果字符串是可变的，那想一想，常量池就没必要存在了。假设多个变量都指向字符串常量池的同一个字符串，然后呢，突然来了一行代码，不管三七二十一，直接把字符串给变了，那岂不是 jvm 世界大乱。</p><p>字符串不可变的根本原因应该是处于安全性考虑。</p><p>我们知道 jvm 类型加载的时候会用到类名，比如加载 java.lang.String 类型，如果字符串可变的话，那我替换成其他的字符，那岂不是很危险。</p><p>项目中会用到比如数据库连接串、账号、密码等字符串，只有不可变的连接串、用户名和密码才能保证安全性。</p><p>字符串在 Java 中的使用频率可谓高之又高，那在高并发的情况下不可变性也使得对字符串的读写操作不用考虑多线程竞争的情况。</p><p>还有就是 HashCode，HashCode 是判断两个对象是否完全相等的核心条件，另外，像 Set、Map 结构中的 key 值也需要用到 HashCode 来保证唯一性和一致性，因此不可变的 HashCode 才是安全可靠的。</p><p>最后一点就是上面提到的，字符串对象的频繁创建会带来性能上的开销，所以，利用不可变性才有了字符串常量池，使得性能得以保障。</p></article><h4>相关文章</h4><dl class=row><dd class=col-md-9><a href=/category/java/Java-Stream/>8000字长文让你彻底了解 Java 8 的 Lambda、函数式接口、Stream 用法和原理</a></dd><dd class=col-md-9><a href=/category/java/JDK17/>新项目为什么决定用 JDK 17了</a></dd><dd class=col-md-9><a href=/category/java/Graalvm/>过两年 JVM 可能就要被GraalVM替代了</a></dd><dd class=col-md-9><a href=/category/java/JVM-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E9%A2%84%E9%98%B2/>JVM 内存溢出的原因及预防</a></dd><dd class=col-md-9><a href=/category/java/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E8%87%AA%E5%B7%B1%E7%9A%84-JDK/>手把手教你编译属于自己的 JDK</a></dd></dl><div class=author-card><div class=underline></div><div class=author-box><div class=qr-author-image><a href=https://www.moonkite.cn><img src=/images/person.jpg alt=风筝></a></div><div class=author-content><p class=author-title>作者</p><p class=author-name>风筝</p><p class=author-desc>古时的风筝，一个平庸的程序员，主语言 Java，第二语言 Python，其实学 Python 的时间比 Java 还要早。喜欢写博客，写博客的过程能加深自己对一个知识点的理解，同时还可以分享给他人。喜欢做一些小东西，所以也会一些前端的东西，React、JavaScript、CSS 都会一些，做一些小工具还够用。</p></div></div></div><script src=https://utteranc.es/client.js repo=huzhicheng/blog-comment issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></main><div class="footer gradient-2"><div class="container footer-container"><div class=row><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>网站地图</div><ul class=list-unstyled><li><a href=https://moonkite.cn/tags/>标签</a></li><li><a href=https://moonkite.cn/categories/>分类</a></li><li><a rel=alternate type=application/rss+xml href=https://moonkite.cn/index.xml><i class="fas fa-rss-square"></i> RSS订阅</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>社群</div><ul class=list-unstyled><li><a href=https://github.com/huzhicheng rel=noopener target=_blank>GitHub</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>友链</div><ul class=list-unstyled><li><a href=https://github.com/huzhicheng rel=noopener target=_blank>关于我</a></li></ul></div><div class="col-xs-12 col-sm-3 col-md-3 col-lg-3"><p class="pull-right text-right"><small><em>Proudly powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo</a></em></small><br><small><em>Theme - <a href=https://github.com/shaform/hugo-theme-den rel=noopener target=_blank>Den</a></em></small><br><small>&copy;
风筝
2023</small></p></div></div><div class=busuanzi-footer><span id=busuanzi_container_site_pv>本站总访问量<span id=busuanzi_value_site_pv></span>次</span>
<span id=busuanzi_container_site_uv>本站访客数<span id=busuanzi_value_site_uv></span>人次</span></div></div></div><script src=https://code.jquery.com/jquery-3.3.1.slim.min.js integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap_4.1.3_js_bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script>
<script>$(document).ready(function(){$("#load_disqus").length&&$(window).scroll(function(){if($("#load_disqus").length){var e=$("#load_disqus").offset().top,t=$(window).scrollTop(),n=t+$(window).height();t<e&&e<n&&load_disqus()}})})</script></body></html>