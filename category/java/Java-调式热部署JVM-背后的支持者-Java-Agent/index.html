<!doctype html><html lang=zh-cn itemscope itemtype=http://schema.org/WebPage><head><meta name=generator content="Hugo 0.113.0"><meta charset=utf-8><title>Java 调式、热部署、JVM 背后的支持者 Java Agent · 古时的风筝</title><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=description content="我们平时写 Java Agent 的机会确实不多，也可以说几乎用不着。但其实我们一直在用它，而且接触的机会非常多。下面这些技术都使用了 Java Agent 技术，看一下你就知道为"><meta name=keywords content="Hugo,theme,编程,java,ChatGPT,程序员,开发"><link rel=canonical href=https://moonkite.cn/category/java/Java-%E8%B0%83%E5%BC%8F%E7%83%AD%E9%83%A8%E7%BD%B2JVM-%E8%83%8C%E5%90%8E%E7%9A%84%E6%94%AF%E6%8C%81%E8%80%85-Java-Agent/><link rel=icon href=https://moonkite.cn/images/photo.png><link rel=stylesheet href=https://cdn.usebootstrap.com/bootstrap/4.1.3/css/bootstrap.min.css><link rel=stylesheet href=https://moonkite.cn/css/den.css><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><meta name=referrer content="no-referrer-when-downgrade"><meta property="og:title" content="Java 调式、热部署、JVM 背后的支持者 Java Agent"><meta property="og:description" content="我们平时写 Java Agent 的机会确实不多，也可以说几乎用不着。但其实我们一直在用它，而且接触的机会非常多。下面这些技术都使用了 Java Agent 技术，看一下你就知道为"><meta property="og:type" content="article"><meta property="og:url" content="https://moonkite.cn/category/java/Java-%E8%B0%83%E5%BC%8F%E7%83%AD%E9%83%A8%E7%BD%B2JVM-%E8%83%8C%E5%90%8E%E7%9A%84%E6%94%AF%E6%8C%81%E8%80%85-Java-Agent/"><meta property="article:section" content="category"><meta property="article:published_time" content="2019-09-11T08:56:23+08:00"><meta property="article:modified_time" content="2019-09-11T08:56:23+08:00"><meta itemprop=name content="Java 调式、热部署、JVM 背后的支持者 Java Agent"><meta itemprop=description content="我们平时写 Java Agent 的机会确实不多，也可以说几乎用不着。但其实我们一直在用它，而且接触的机会非常多。下面这些技术都使用了 Java Agent 技术，看一下你就知道为"><meta itemprop=datePublished content="2019-09-11T08:56:23+08:00"><meta itemprop=dateModified content="2019-09-11T08:56:23+08:00"><meta itemprop=wordCount content="3400"><meta itemprop=keywords content="Java,JDK,Java锁,Java多线程,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java 调式、热部署、JVM 背后的支持者 Java Agent"><meta name=twitter:description content="我们平时写 Java Agent 的机会确实不多，也可以说几乎用不着。但其实我们一直在用它，而且接触的机会非常多。下面这些技术都使用了 Java Agent 技术，看一下你就知道为"></head><body><div class=header-container style=background:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2)),url(https://moonkite.cn/images/background.png);background-position:top;background-size:cover><div class=container><nav class="header-nav navbar navbar-expand-md navbar-dark light-dark"><div class="header-logo navbar-brand"><a class=float-left href=https://moonkite.cn/></a></div><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarNav aria-controls=navbarNav aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="nav-menu collapse navbar-collapse" id=navbarNav><ul class=navbar-nav><li class=nav-item><a href=https://moonkite.cn/ class=nav-link><i class="fas fad fa-h-square"></i>主页</a></li><li class=nav-item><a href=https://moonkite.cn/category/notes/ class=nav-link><i class='fas fa-yin-yang'></i>生活随笔</a></li><li class=nav-item><a href=javascript:void(0) class=nav-link><i class='fas fa-laptop-code'></i>技术文章</a><div class=sub-dropdown-menu><a class=sub-nav-link href=https://moonkite.cn/category/java><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 48 48"><path fill="#f44336" d="M23.65 24.898c-.998-1.609-1.722-2.943-2.725-5.455C19.229 15.2 31.24 11.366 26.37 3.999c2.111 5.089-7.577 8.235-8.477 12.473-.823 3.898 5.752 8.426 5.757 8.426z"/><path fill="#f44336" d="M23.878 17.27c-.192 2.516 2.229 3.857 2.299 5.695.056 1.496-1.447 2.743-1.447 2.743s2.728-.536 3.579-2.818c.945-2.534-1.834-4.269-1.548-6.298.267-1.938 6.031-5.543 6.031-5.543S24.311 11.611 23.878 17.27z"/><g><path fill="#1565c0" d="M32.084 25.055c1.754-.394 3.233.723 3.233 2.01.0 2.901-4.021 5.643-4.021 5.643s6.225-.742 6.225-5.505c0-3.15-3.057-3.937-5.437-2.148zm-2.955 2.34s1.941-1.383 2.458-1.902c-4.763 1.011-15.638 1.147-15.638.269.0-.809 3.507-1.638 3.507-1.638s-7.773-.112-7.773 2.181C11.683 28.695 21.858 28.866 29.129 27.395z"/><path fill="#1565c0" d="M27.935 29.571c-4.509 1.499-12.814 1.02-10.354-.993-1.198.0-2.974.963-2.974 1.889.0 1.857 8.982 3.291 15.63.572l-2.302-1.468z"/><path fill="#1565c0" d="M18.686 32.739c-1.636.0-2.695 1.054-2.695 1.822.0 2.391 9.76 2.632 13.627.205l-2.458-1.632C24.271 34.404 17.014 34.579 18.686 32.739z"/><path fill="#1565c0" d="M36.281 36.632c0-.936-1.055-1.377-1.433-1.588 2.228 5.373-22.317 4.956-22.317 1.784.0-.721 1.807-1.427 3.477-1.093l-1.42-.839C11.26 34.374 9 35.837 9 37.017 9 42.52 36.281 42.255 36.281 36.632z"/><path fill="#1565c0" d="M39 38.604c-4.146 4.095-14.659 5.587-25.231 3.057C24.341 46.164 38.95 43.628 39 38.604z"/></g></svg>&nbsp;可爱的 Java</a>
<a class=sub-nav-link href=https://moonkite.cn/category/SpringCloud><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 48 48"><path fill="#8bc34a" d="M43.982 23.635c.069-4.261-.891-9.328-2.891-15.273L39.523 3.7l-2.13 4.433c-.114.237-.244.469-.38.698C33.514 5.827 28.974 4 24 4 12.954 4 4 12.954 4 24s8.954 20 20 20 20-8.954 20-20C44 23.877 43.984 23.758 43.982 23.635z"/><path fill="#fff" d="M39.385 32.558C36.262 36.86 30.734 37.091 25.531 37H18.75h-1.938c4.428-1.593 7.063-1.972 9.754-3.4 5.068-2.665 10.078-8.496 11.121-14.562-1.93 5.836-7.779 10.85-13.109 12.889-3.652 1.393-10.248 2.745-10.248 2.745l-.267-.145C9.573 32.268 9.437 22.214 17.6 18.968c3.574-1.423 6.993-.641 10.854-1.593 4.122-1.012 8.89-4.208 10.83-8.375C41.456 15.667 44.07 26.106 39.385 32.558zM15.668 38.445C15.386 38.795 14.955 39 14.505 39c-.823.0-1.495-.677-1.495-1.5s.677-1.5 1.495-1.5c.341.0.677.118.941.336C16.086 36.855 16.186 37.805 15.668 38.445z"/></svg>&nbsp; Spring Cloud 系列</a></div></li><li class=nav-item><a href=https://moonkite.cn/category/network class=nav-link><i class="fas fa-network-wired"></i>轻解计算机网络</a></li><li class=nav-item><a href=https://moonkite.cn/category/product class=nav-link><i class="fas fab fa-medapps"></i>我的产品</a></li></ul></div></nav></div><div class="container header-wrapper"><div class=row><div class=col-lg-12><div class=header-content><h1 class=header-title>Java 调式、热部署、JVM 背后的支持者 Java Agent</h1><p class=header-date>作者：
风筝 /
2019-09-11<div class=header-underline></div><div class=header-date>&nbsp·&nbsp
  <span id=busuanzi_container_page_pv>本文被阅读<span id=busuanzi_value_page_pv></span>次</span></div><div class=clearfix></div><p class="float-right header-tags"><i class="fas fa-tags" aria-hidden=true></i>
<a href=https://moonkite.cn/tag/Java/>Java</a>,
<a href=https://moonkite.cn/tag/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/>Java多线程</a>,
<a href=https://moonkite.cn/tag/Java%E9%94%81/>Java锁</a>,
<a href=https://moonkite.cn/tag/JDK/>JDK</a></p></div></div></div></div></div><main><div class="container content"><article><p>我们平时写 Java Agent 的机会确实不多，也可以说几乎用不着。但其实我们一直在用它，而且接触的机会非常多。下面这些技术都使用了 Java Agent 技术，看一下你就知道为什么了。</p><p><em>-</em> 各个 Java IDE 的调试功能，例如 eclipse、IntelliJ ；</p><p><em>-</em> 热部署功能，例如 JRebel、XRebel、 spring-loaded；</p><p><em>-</em> 各种线上诊断工具，例如 Btrace、Greys，还有阿里的 Arthas；</p><p><em>-</em> 各种性能分析工具，例如 Visual VM、JConsole 等；</p><p>Java Agent 直译过来叫做 Java 代理，还有另一种称呼叫做 Java 探针。首先说 Java Agent 是一个 jar 包，只不过这个 jar 包不能独立运行，它需要依附到我们的目标 JVM 进程中。我们来理解一下这两种叫法。</p><p><strong>代理</strong>：比方说我们需要了解目标 JVM 的一些运行指标，我们可以通过 Java Agent 来实现，这样看来它就是一个代理的效果，我们最后拿到的指标是目标 JVM ,但是我们是通过 Java Agent 来获取的，对于目标 JVM 来说，它就像是一个代理；</p><p><strong>探针</strong>：这个说法我感觉非常形象，JVM 一旦跑起来，对于外界来说，它就是一个黑盒。而 Java Agent 可以像一支针一样插到 JVM 内部，探到我们想要的东西，并且可以注入东西进去。</p><p>拿上面的几个我们平时会用到的技术举例子。拿 IDEA 调试器来说吧，当开启调试功能后，在 debugger 面板中可以看到当前上下文变量的结构和内容，还可以在 watches 面板中运行一些简单的代码，比如取值赋值等操作。还有 Btrace、Arthas 这些线上排查问题的工具，比方说有接口没有按预期的返回结果，但日志又没有错误，这时，我们只要清楚方法的所在包名、类名、方法名等，不用修改部署服务，就能查到调用的参数、返回值、异常等信息。</p><p>上面只是说到了探测的功能，而热部署功能那就不仅仅是探测这么简单了。热部署的意思就是说再不重启服务的情况下，保证最新的代码逻辑在服务生效。当我们修改某个类后，通过 Java Agent 的 instrument 机制，把之前的字节码替换为新代码所对应的字节码。</p><h3 id=java-agent-结构><em>Java Agent 结构</em></h3><p><img src=https://hexo.moonkite.cn/blog/273364-20190910210612067-2063509134.png alt>
Java Agent 最终以 jar 包的形式存在。主要包含两个部分，一部分是实现代码，一部分是配置文件。</p><p><em>配置文件</em>放在 META-INF 目录下，文件名为 MANIFEST.MF 。包括以下配置项：</p><p>Manifest-Version: 版本号
Created-By: 创作者
Agent-Class: agentmain 方法所在类
Can-Redefine-Classes: 是否可以实现类的重定义
Can-Retransform-Classes: 是否可以实现字节码替换
Premain-Class: premain 方法所在类</p><p><em>入口类</em>实现 <code>agentmain</code> 和 <code>premain</code> 两个方法即可，方法要实现什么功能就由你的需求决定了。</p><p>###<em>Java Agent 实现和使用</em></p><p>接下来就来实现一个简单的 Java Agent，基于 Java 1.8，主要实现两点简单的功能：</p><p>1、打印当前加载的所有类的名称；</p><p>2、监控一个特定的方法，在方法中动态插入简单的代码并获取方法返回值；</p><p>在方法中插入代码主要是用到了字节码修改技术，字节码修改技术主要有 javassist、ASM，已经 ASM 的高级封装可扩展 cglib，这个例子中用的是 javassist。所以需要引入相关的 maven 包。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl><span class=nt>&lt;dependency&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;groupId&gt;</span>javassist<span class=nt>&lt;/groupId&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;artifactId&gt;</span>javassist<span class=nt>&lt;/artifactId&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;version&gt;</span>3.12.1.GA<span class=nt>&lt;/version&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;/dependency&gt;</span>
</span></span></code></pre></div><p><em>实现入口类和功能逻辑</em></p><p>入口类上面也说了，要实现 <code>agentmain</code> 和 <code>premain</code> 两个方法。这两个方法的运行时机不一样。这要从 Java Agent 的使用方式来说了，Java Agent 有两种启动方式，一种是以 JVM 启动参数 <code>-javaagent:xxx.jar</code> 的形式随着 JVM 一起启动，这种情况下，会调用 <code>premain</code>方法，并且是在主进程的 <code>main</code>方法之前执行。另外一种是以 loadAgent 方法动态 attach 到目标 JVM 上，这种情况下，会执行 <code>agentmain</code>方法。</p><table><thead><tr><th>加载方式</th><th>执行方法</th></tr></thead><tbody><tr><td>-javaagent:xxx.jar 参数形式</td><td>premain</td></tr><tr><td>动态 attach</td><td>agentmain</td></tr></tbody></table><p>代码实现如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>package</span> <span class=nn>kite.lab.custom.agent</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.lang.instrument.Instrumentation</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>MyCustomAgent</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * jvm 参数形式启动，运行此方法
</span></span></span><span class=line><span class=cl><span class=cm>     * @param agentArgs
</span></span></span><span class=line><span class=cl><span class=cm>     * @param inst
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>premain</span><span class=o>(</span><span class=n>String</span> <span class=n>agentArgs</span><span class=o>,</span> <span class=n>Instrumentation</span> <span class=n>inst</span><span class=o>){</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;premain&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>customLogic</span><span class=o>(</span><span class=n>inst</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 动态 attach 方式启动，运行此方法
</span></span></span><span class=line><span class=cl><span class=cm>     * @param agentArgs
</span></span></span><span class=line><span class=cl><span class=cm>     * @param inst
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>agentmain</span><span class=o>(</span><span class=n>String</span> <span class=n>agentArgs</span><span class=o>,</span> <span class=n>Instrumentation</span> <span class=n>inst</span><span class=o>){</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;agentmain&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>customLogic</span><span class=o>(</span><span class=n>inst</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 打印所有已加载的类名称
</span></span></span><span class=line><span class=cl><span class=cm>     * 修改字节码
</span></span></span><span class=line><span class=cl><span class=cm>     * @param inst
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>customLogic</span><span class=o>(</span><span class=n>Instrumentation</span> <span class=n>inst</span><span class=o>){</span>
</span></span><span class=line><span class=cl>        <span class=n>inst</span><span class=o>.</span><span class=na>addTransformer</span><span class=o>(</span><span class=k>new</span> <span class=n>MyTransformer</span><span class=o>(),</span> <span class=kc>true</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Class</span><span class=o>[]</span> <span class=n>classes</span> <span class=o>=</span> <span class=n>inst</span><span class=o>.</span><span class=na>getAllLoadedClasses</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=o>(</span><span class=n>Class</span> <span class=n>cls</span> <span class=o>:</span><span class=n>classes</span><span class=o>){</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>cls</span><span class=o>.</span><span class=na>getName</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>我们看到这两个方法都有参数 agentArgs 和 inst，其中 agentArgs 是我们启动 Java Agent 时带进来的参数，比如<code>-javaagent:xxx.jar agentArgs</code>。Instrumentation Java 开放出来的专门用于字节码修改和程序监控的实现。我们要实现的打印已加载类和修改字节码也就是基于它来实现的。其中 <code>inst.getAllLoadedClasses()</code>一个方法就实现了获取所以已加载类的功能。</p><p><code>inst.addTransformer</code>方法则是实现字节码修改的关键，后面的参数就是实现字节码修改的实现类，代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>MyTransformer</span> <span class=kd>implements</span> <span class=n>ClassFileTransformer</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>byte</span><span class=o>[]</span> <span class=nf>transform</span><span class=o>(</span><span class=n>ClassLoader</span> <span class=n>loader</span><span class=o>,</span> <span class=n>String</span> <span class=n>className</span><span class=o>,</span> <span class=n>Class</span><span class=o>&lt;?&gt;</span> <span class=n>classBeingRedefined</span><span class=o>,</span> <span class=n>ProtectionDomain</span> <span class=n>protectionDomain</span><span class=o>,</span> <span class=kt>byte</span><span class=o>[]</span> <span class=n>classfileBuffer</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>IllegalClassFormatException</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;正在加载类：&#34;</span><span class=o>+</span> <span class=n>className</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(!</span><span class=s>&#34;kite/attachapi/Person&#34;</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>className</span><span class=o>)){</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>classfileBuffer</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>CtClass</span> <span class=n>cl</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>ClassPool</span> <span class=n>classPool</span> <span class=o>=</span> <span class=n>ClassPool</span><span class=o>.</span><span class=na>getDefault</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=n>cl</span> <span class=o>=</span> <span class=n>classPool</span><span class=o>.</span><span class=na>makeClass</span><span class=o>(</span><span class=k>new</span> <span class=n>ByteArrayInputStream</span><span class=o>(</span><span class=n>classfileBuffer</span><span class=o>));</span>
</span></span><span class=line><span class=cl>            <span class=n>CtMethod</span> <span class=n>ctMethod</span> <span class=o>=</span> <span class=n>cl</span><span class=o>.</span><span class=na>getDeclaredMethod</span><span class=o>(</span><span class=s>&#34;test&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;获取方法名称：&#34;</span><span class=o>+</span> <span class=n>ctMethod</span><span class=o>.</span><span class=na>getName</span><span class=o>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>ctMethod</span><span class=o>.</span><span class=na>insertBefore</span><span class=o>(</span><span class=s>&#34;System.out.println(\&#34; 动态插入的打印语句 \&#34;);&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=n>ctMethod</span><span class=o>.</span><span class=na>insertAfter</span><span class=o>(</span><span class=s>&#34;System.out.println($_);&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=kt>byte</span><span class=o>[]</span> <span class=n>transformed</span> <span class=o>=</span> <span class=n>cl</span><span class=o>.</span><span class=na>toBytecode</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>transformed</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span><span class=k>catch</span> <span class=o>(</span><span class=n>Exception</span> <span class=n>e</span><span class=o>){</span>
</span></span><span class=line><span class=cl>            <span class=n>e</span><span class=o>.</span><span class=na>printStackTrace</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>classfileBuffer</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>以上代码的逻辑就是当碰到加载的类是 <code>kite.attachapi.Person</code>的时候，在其中的 <code>test</code> 方法开始时插入一条打印语句，打印内容是"动态插入的打印语句"，在<code>test</code>方法结尾处，打印返回值，其中<code>$_</code>就是返回值，这是 javassist 里特定的标示符。</p><p><em>MANIFEST.MF 配置文件</em></p><p>在目录 resources/META-INF/ 下创建文件名为 MANIFEST.MF 的文件，在其中加入如下的配置内容：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-properties data-lang=properties><span class=line><span class=cl><span class=na>Manifest-Version</span><span class=o>:</span> <span class=s>1.0</span>
</span></span><span class=line><span class=cl><span class=na>Created-By</span><span class=o>:</span> <span class=s>fengzheng</span>
</span></span><span class=line><span class=cl><span class=na>Agent-Class</span><span class=o>:</span> <span class=s>kite.lab.custom.agent.MyCustomAgent</span>
</span></span><span class=line><span class=cl><span class=na>Can-Redefine-Classes</span><span class=o>:</span> <span class=s>true</span>
</span></span><span class=line><span class=cl><span class=na>Can-Retransform-Classes</span><span class=o>:</span> <span class=s>true</span>
</span></span><span class=line><span class=cl><span class=na>Premain-Class</span><span class=o>:</span> <span class=s>kite.lab.custom.agent.MyCustomAgent</span>
</span></span></code></pre></div><p><em>配置打包所需的 pom 设置</em></p><p>最后 Java Agent 是以 jar 包的形式存在，所以最后一步就是将上面的内容打到一个 jar 包里。</p><p>在 pom 文件中加入以下配置</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl><span class=nt>&lt;build&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;plugins&gt;</span>
</span></span><span class=line><span class=cl>        <span class=nt>&lt;plugin&gt;</span>
</span></span><span class=line><span class=cl>            <span class=nt>&lt;groupId&gt;</span>org.apache.maven.plugins<span class=nt>&lt;/groupId&gt;</span>
</span></span><span class=line><span class=cl>            <span class=nt>&lt;artifactId&gt;</span>maven-assembly-plugin<span class=nt>&lt;/artifactId&gt;</span>
</span></span><span class=line><span class=cl>            <span class=nt>&lt;configuration&gt;</span>
</span></span><span class=line><span class=cl>                <span class=nt>&lt;archive&gt;</span>
</span></span><span class=line><span class=cl>                    <span class=nt>&lt;manifestFile&gt;</span>src/main/resources/META-INF/MANIFEST.MF<span class=nt>&lt;/manifestFile&gt;</span>
</span></span><span class=line><span class=cl>                <span class=nt>&lt;/archive&gt;</span>
</span></span><span class=line><span class=cl>                <span class=nt>&lt;descriptorRefs&gt;</span>
</span></span><span class=line><span class=cl>                    <span class=nt>&lt;descriptorRef&gt;</span>jar-with-dependencies<span class=nt>&lt;/descriptorRef&gt;</span>
</span></span><span class=line><span class=cl>                <span class=nt>&lt;/descriptorRefs&gt;</span>
</span></span><span class=line><span class=cl>            <span class=nt>&lt;/configuration&gt;</span>
</span></span><span class=line><span class=cl>        <span class=nt>&lt;/plugin&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;/plugins&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;/build&gt;</span>
</span></span></code></pre></div><p>用的是 maven 的 maven-assembly-plugin 插件，注意其中要用 manifestFile 指定 MANIFEST.MF 所在路径，然后指定 jar-with-dependencies ，将依赖包打进去。</p><p>上面这是一种打包方式，需要单独的 MANIFEST.MF 配合，<em>还有一种方式</em>，不需要在项目中单独的添加 MANIFEST.MF 配置文件，完全在 pom 文件中配置上即可。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl><span class=nt>&lt;build&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;plugins&gt;</span>
</span></span><span class=line><span class=cl>        <span class=nt>&lt;plugin&gt;</span>
</span></span><span class=line><span class=cl>            <span class=nt>&lt;groupId&gt;</span>org.apache.maven.plugins<span class=nt>&lt;/groupId&gt;</span>
</span></span><span class=line><span class=cl>            <span class=nt>&lt;artifactId&gt;</span>maven-assembly-plugin<span class=nt>&lt;/artifactId&gt;</span>
</span></span><span class=line><span class=cl>            <span class=nt>&lt;executions&gt;</span>
</span></span><span class=line><span class=cl>                <span class=nt>&lt;execution&gt;</span>
</span></span><span class=line><span class=cl>                    <span class=nt>&lt;goals&gt;</span>
</span></span><span class=line><span class=cl>                        <span class=nt>&lt;goal&gt;</span>attached<span class=nt>&lt;/goal&gt;</span>
</span></span><span class=line><span class=cl>                    <span class=nt>&lt;/goals&gt;</span>
</span></span><span class=line><span class=cl>                    <span class=nt>&lt;phase&gt;</span>package<span class=nt>&lt;/phase&gt;</span>
</span></span><span class=line><span class=cl>                    <span class=nt>&lt;configuration&gt;</span>
</span></span><span class=line><span class=cl>                        <span class=nt>&lt;descriptorRefs&gt;</span>
</span></span><span class=line><span class=cl>                            <span class=nt>&lt;descriptorRef&gt;</span>jar-with-dependencies<span class=nt>&lt;/descriptorRef&gt;</span>
</span></span><span class=line><span class=cl>                        <span class=nt>&lt;/descriptorRefs&gt;</span>
</span></span><span class=line><span class=cl>                        <span class=nt>&lt;archive&gt;</span>
</span></span><span class=line><span class=cl>                            <span class=nt>&lt;manifestEntries&gt;</span>
</span></span><span class=line><span class=cl>                                <span class=nt>&lt;Premain-Class&gt;</span>kite.agent.vmargsmethod.MyAgent<span class=nt>&lt;/Premain-Class&gt;</span>
</span></span><span class=line><span class=cl>                                <span class=nt>&lt;Agent-Class&gt;</span>kite.agent.vmargsmethod.MyAgent<span class=nt>&lt;/Agent-Class&gt;</span>
</span></span><span class=line><span class=cl>                                <span class=nt>&lt;Can-Redefine-Classes&gt;</span>true<span class=nt>&lt;/Can-Redefine-Classes&gt;</span>
</span></span><span class=line><span class=cl>                                <span class=nt>&lt;Can-Retransform-Classes&gt;</span>true<span class=nt>&lt;/Can-Retransform-Classes&gt;</span>
</span></span><span class=line><span class=cl>                            <span class=nt>&lt;/manifestEntries&gt;</span>
</span></span><span class=line><span class=cl>                        <span class=nt>&lt;/archive&gt;</span>
</span></span><span class=line><span class=cl>                    <span class=nt>&lt;/configuration&gt;</span>
</span></span><span class=line><span class=cl>                <span class=nt>&lt;/execution&gt;</span>
</span></span><span class=line><span class=cl>            <span class=nt>&lt;/executions&gt;</span>
</span></span><span class=line><span class=cl>        <span class=nt>&lt;/plugin&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;/plugins&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;/build&gt;</span>
</span></span></code></pre></div><p>这种方式是将 MANIFEST.MF 的内容全部写作 pom 配置中，打包的时候就会自动将配置信息生成 MANIFEST.MF 配置文件打进包里。</p><p><em>运行打包命令</em></p><p>接下来就简单了，执行一条 maven 命令即可。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mvn assembly:assembly
</span></span></code></pre></div><p>最后打出来的 jar 包默认是以「项目名称-版本号-jar-with-dependencies.jar」这样的格式生成到 target 目录下。</p><p><em>运行打包好的 Java Agent</em></p><p>首先写一个简单的测试项目，用来作为目标 JVM，稍后会以两种方式将 Java Agent 挂到这个测试项目上。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>package</span> <span class=nn>kite.attachapi</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.Scanner</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>RunJvm</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>){</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;按数字键 1 调用测试方法&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=o>(</span><span class=kc>true</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Scanner</span> <span class=n>reader</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Scanner</span><span class=o>(</span><span class=n>System</span><span class=o>.</span><span class=na>in</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>number</span> <span class=o>=</span> <span class=n>reader</span><span class=o>.</span><span class=na>nextInt</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=o>(</span><span class=n>number</span><span class=o>==</span><span class=mi>1</span><span class=o>){</span>
</span></span><span class=line><span class=cl>                <span class=n>Person</span> <span class=n>person</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Person</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                <span class=n>person</span><span class=o>.</span><span class=na>test</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>以上只有一个简单的 main 方法，用 while 的方式保证线程不退出，并且在输入数字 1 的时候，调用 <code>person.test()</code>方法。</p><p>以下是 Person 类</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>package</span> <span class=nn>kite.attachapi</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Person</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>String</span> <span class=nf>test</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;执行测试方法&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s>&#34;I&#39;m ok&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p><strong>以命令行的方式运行</strong></p><p>因为项目是在 IDEA 里创建的，为了省事儿，我就直接在 IDEA 的 「Run/Debug Configurations」里加参数了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>-javaagent:/java-agent路径/lab-custom-agent-1.0-SNAPSHOT-jar-with-dependencies.jar
</span></span></code></pre></div><p><img src=https://hexo.moonkite.cn/blog/273364-20190910210651368-483816243.png alt></p><p>然后直接运行就可以看到效果了，会看到加载的类名称。然后输入数字键 &ldquo;1&rdquo;，会看到字节码修改后的内容。</p><p><img src=https://hexo.moonkite.cn/blog/273364-20190910210707816-1948213087.png alt></p><p><strong>以动态 attach 的方式运行</strong></p><p>测试之前先要把这个测试项目跑起来，并把之前的参数去掉。运行后，找到这个它的进程id，一般利用<code>jps -l</code>即可。</p><p>动态 attach 的方式是需要代码实现的，实现代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>AttachAgent</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>Exception</span><span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>VirtualMachine</span> <span class=n>vm</span> <span class=o>=</span> <span class=n>VirtualMachine</span><span class=o>.</span><span class=na>attach</span><span class=o>(</span><span class=s>&#34;pid(进程号)&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>vm</span><span class=o>.</span><span class=na>loadAgent</span><span class=o>(</span><span class=s>&#34;java-agent路径/lab-custom-agent-1.0-SNAPSHOT-jar-with-dependencies.jar&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>运行上面的 main 方法 并在测试程序中输入“1”，会得到上图同样的结果。</p><blockquote><p>发现了没，我们到这里实现的简单的功能是不是和 BTrace 和 Arthas 有点像呢。我们拦截了指定的一个方法，并在这个方法里插入了代码而且拿到了返回结果。如果把方法名称变成可配置项，并且把返回结果保存到一个公共位置，例如一个内存数据库，是不是我们就可以像 Arthas 那样轻松的检测线上问题了呢。当然了，Arthas 要复杂的多，但原理是一样的。</p></blockquote><p>###<em>sun.management.Agent 的实现</em></p><p>不知道你平时有没有用过 visualVM 或者 JConsole 之类的工具，其实，它们就是用了 management-agent.jar 这个Java Agent 来实现的。如果我们希望 Java 服务允许远程查看 JVM 信息，往往会配置上一下这些参数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-properties data-lang=properties><span class=line><span class=cl><span class=err>-Dcom.sun.management.jmxremote</span>
</span></span><span class=line><span class=cl><span class=na>-Djava.rmi.server.hostname</span><span class=o>=</span><span class=s>192.168.1.1</span>
</span></span><span class=line><span class=cl><span class=na>-Dcom.sun.management.jmxremote.port</span><span class=o>=</span><span class=s>9999</span>
</span></span><span class=line><span class=cl><span class=na>-Dcom.sun.management.jmxremote.rmi.port</span><span class=o>=</span><span class=s>9999</span>
</span></span><span class=line><span class=cl><span class=na>-Dcom.sun.management.jmxremote.authenticate</span><span class=o>=</span><span class=s>false</span>
</span></span><span class=line><span class=cl><span class=na>-Dcom.sun.management.jmxremote.ssl</span><span class=o>=</span><span class=s>false</span>
</span></span></code></pre></div><p>这些参数都是 management-agent.jar 定义的。</p><p>我们进到 management-agent.jar 包下，看到只有一个 MANIFEST.MF 配置文件，配置内容为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-properties data-lang=properties><span class=line><span class=cl><span class=na>Manifest-Version</span><span class=o>:</span> <span class=s>1.0</span>
</span></span><span class=line><span class=cl><span class=na>Created-By</span><span class=o>:</span> <span class=s>1.7.0_07 (Oracle Corporation)</span>
</span></span><span class=line><span class=cl><span class=na>Agent-Class</span><span class=o>:</span> <span class=s>sun.management.Agent</span>
</span></span><span class=line><span class=cl><span class=na>Premain-Class</span><span class=o>:</span> <span class=s>sun.management.Agent</span>
</span></span></code></pre></div><p>可以看到入口 class 为 sun.management.Agent，进到这个类里面可以找到 agentmain 和 premain，并可以看到它们的逻辑。在这个类的开始，能看到我们前面对服务开启远程 JVM 监控需要开启的那些参数定义。</p></article><h4>相关文章</h4><dl class=row><dd class=col-md-9><a href=/category/java/%E7%B1%BB%E9%94%81%E5%92%8C%E5%AF%B9%E8%B1%A1%E9%94%81%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/>类锁和对象锁到底有什么区别</a></dd><dd class=col-md-9><a href=/category/java/Java-%E5%BC%80%E5%8F%91-volatile-%E4%BD%A0%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B/>Java 开发， volatile 你必须了解一下</a></dd><dd class=col-md-9><a href=/category/java/Synchronized/>synchronized 到底该不该用？</a></dd><dd class=col-md-9><a href=/category/SpringCloud/0-Srping-Cloud-%E5%BC%80%E7%AF%87/>0. Spring Cloud 是什么</a></dd><dd class=col-md-9><a href=/category/SpringCloud/1-Spring-Cloud-Eureka-%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/>1. Spring Cloud Eureka 实现服务注册与发现</a></dd></dl><div class=author-card><div class=underline></div><div class=author-box><div class=qr-author-image><a href=https://www.moonkite.cn><img src=/images/person.jpg alt=风筝></a></div><div class=author-content><p class=author-title>作者</p><p class=author-name>风筝</p><p class=author-desc>古时的风筝，一个平庸的程序员，主语言 Java，第二语言 Python，其实学 Python 的时间比 Java 还要早。喜欢写博客，写博客的过程能加深自己对一个知识点的理解，同时还可以分享给他人。喜欢做一些小东西，所以也会一些前端的东西，React、JavaScript、CSS 都会一些，做一些小工具还够用。</p></div></div></div><script src=https://utteranc.es/client.js repo=huzhicheng/blog-comment issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></main><div class="footer gradient-2"><div class="container footer-container"><div class=row><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>网站地图</div><ul class=list-unstyled><li><a href=https://moonkite.cn/tags/>标签</a></li><li><a href=https://moonkite.cn/categories/>分类</a></li><li><a rel=alternate type=application/rss+xml href=https://moonkite.cn/index.xml><i class="fas fa-rss-square"></i> RSS订阅</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>社群</div><ul class=list-unstyled><li><a href=https://github.com/huzhicheng rel=noopener target=_blank>GitHub</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>友链</div><ul class=list-unstyled><li><a href=https://github.com/huzhicheng rel=noopener target=_blank>关于我</a></li></ul></div><div class="col-xs-12 col-sm-3 col-md-3 col-lg-3"><p class="pull-right text-right"><small><em>Proudly powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo</a></em></small><br><small><em>Theme - <a href=https://github.com/shaform/hugo-theme-den rel=noopener target=_blank>Den</a></em></small><br><small>&copy;
风筝
2023</small></p></div></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-C714TFXRD4"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-C714TFXRD4")</script><div class=busuanzi-footer><span id=busuanzi_container_site_pv>本站总访问量<span id=busuanzi_value_site_pv></span>次</span>
<span id=busuanzi_container_site_uv>本站访客数<span id=busuanzi_value_site_uv></span>人次</span></div></div></div><script src=https://code.jquery.com/jquery-3.3.1.slim.min.js integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap_4.1.3_js_bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script>
<script>$(document).ready(function(){$("#load_disqus").length&&$(window).scroll(function(){if($("#load_disqus").length){var e=$("#load_disqus").offset().top,t=$(window).scrollTop(),n=t+$(window).height();t<e&&e<n&&load_disqus()}})})</script></body></html>