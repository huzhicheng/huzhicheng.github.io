<!doctype html><html lang=zh-cn itemscope itemtype=http://schema.org/WebPage><head><meta name=generator content="Hugo 0.121.0"><meta charset=utf-8><title>什么是零拷贝|Java中的零拷贝 · 古时的风筝</title>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=description content="零拷贝是什么"><meta name=360-site-verification content="e75339f1cfcde17f66f71aaf8b6983e9"><meta name=keywords content="Hugo,theme,编程,java,ChatGPT,程序员,开发"><link rel=canonical href=https://www.moonkite.cn/category/java/%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%B6%E6%8B%B7%E8%B4%9D/><link rel=icon href=https://www.moonkite.cn/images/photo.png><link rel=stylesheet href=https://cdn.staticfile.org/twitter-bootstrap/4.1.3/css/bootstrap.min.css><link rel=stylesheet href=https://www.moonkite.cn/css/den.css><link href=https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.7.0/style.min.css rel=stylesheet><link href=https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.7.0/lxgwwenkaigbscreen.min.css rel=stylesheet><link href=https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/lxgwwenkaiscreen.min.css rel=stylesheet><meta property="og:title" content="什么是零拷贝|Java中的零拷贝"><meta property="og:description" content="零拷贝是什么"><meta property="og:type" content="article"><meta property="og:url" content="https://www.moonkite.cn/category/java/%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%B6%E6%8B%B7%E8%B4%9D/"><meta property="article:section" content="category"><meta property="article:published_time" content="2018-05-10T08:56:23+08:00"><meta property="article:modified_time" content="2018-05-10T08:56:23+08:00"><meta itemprop=name content="什么是零拷贝|Java中的零拷贝"><meta itemprop=description content="零拷贝是什么"><meta itemprop=datePublished content="2018-05-10T08:56:23+08:00"><meta itemprop=dateModified content="2018-05-10T08:56:23+08:00"><meta itemprop=wordCount content="4628"><meta itemprop=keywords content="Java,JDK,零拷贝,"><meta name=twitter:card content="summary"><meta name=twitter:title content="什么是零拷贝|Java中的零拷贝"><meta name=twitter:description content="零拷贝是什么"></head><body><div class=header-container style=background:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2)),url(https://hexo.moonkite.cn/blog/background.png);background-position:top;background-size:cover><div class=container><nav class="header-nav navbar navbar-expand-md navbar-dark light-dark"><div class="header-logo navbar-brand"><a class=float-left href=https://www.moonkite.cn/></a></div><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarNav aria-controls=navbarNav aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="nav-menu collapse navbar-collapse" id=navbarNav><ul class=navbar-nav><li class=nav-item><a href=https://www.moonkite.cn/ class=nav-link><i class="fas fad fa-h-square"></i>主页</a></li><li class=nav-item><a href=https://www.moonkite.cn/category/notes class=nav-link><i class='fas fa-yin-yang'></i>生活随笔</a></li><li class=nav-item><a href=javascript:void(0) class=nav-link><i class='fas fa-laptop-code'></i>技术文章</a><div class=sub-dropdown-menu><a class=sub-nav-link href=https://www.moonkite.cn/category/java><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 48 48"><path fill="#f44336" d="M23.65 24.898c-.998-1.609-1.722-2.943-2.725-5.455C19.229 15.2 31.24 11.366 26.37 3.999c2.111 5.089-7.577 8.235-8.477 12.473-.823 3.898 5.752 8.426 5.757 8.426z"/><path fill="#f44336" d="M23.878 17.27c-.192 2.516 2.229 3.857 2.299 5.695.056 1.496-1.447 2.743-1.447 2.743s2.728-.536 3.579-2.818c.945-2.534-1.834-4.269-1.548-6.298.267-1.938 6.031-5.543 6.031-5.543S24.311 11.611 23.878 17.27z"/><g><path fill="#1565c0" d="M32.084 25.055c1.754-.394 3.233.723 3.233 2.01.0 2.901-4.021 5.643-4.021 5.643s6.225-.742 6.225-5.505c0-3.15-3.057-3.937-5.437-2.148zm-2.955 2.34s1.941-1.383 2.458-1.902c-4.763 1.011-15.638 1.147-15.638.269.0-.809 3.507-1.638 3.507-1.638s-7.773-.112-7.773 2.181C11.683 28.695 21.858 28.866 29.129 27.395z"/><path fill="#1565c0" d="M27.935 29.571c-4.509 1.499-12.814 1.02-10.354-.993-1.198.0-2.974.963-2.974 1.889.0 1.857 8.982 3.291 15.63.572l-2.302-1.468z"/><path fill="#1565c0" d="M18.686 32.739c-1.636.0-2.695 1.054-2.695 1.822.0 2.391 9.76 2.632 13.627.205l-2.458-1.632C24.271 34.404 17.014 34.579 18.686 32.739z"/><path fill="#1565c0" d="M36.281 36.632c0-.936-1.055-1.377-1.433-1.588 2.228 5.373-22.317 4.956-22.317 1.784.0-.721 1.807-1.427 3.477-1.093l-1.42-.839C11.26 34.374 9 35.837 9 37.017 9 42.52 36.281 42.255 36.281 36.632z"/><path fill="#1565c0" d="M39 38.604c-4.146 4.095-14.659 5.587-25.231 3.057C24.341 46.164 38.95 43.628 39 38.604z"/></g></svg>&nbsp;可爱的 Java</a>
<a class=sub-nav-link href=https://www.moonkite.cn/category/SpringCloud><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 48 48"><path fill="#8bc34a" d="M43.982 23.635c.069-4.261-.891-9.328-2.891-15.273L39.523 3.7l-2.13 4.433c-.114.237-.244.469-.38.698C33.514 5.827 28.974 4 24 4 12.954 4 4 12.954 4 24s8.954 20 20 20 20-8.954 20-20C44 23.877 43.984 23.758 43.982 23.635z"/><path fill="#fff" d="M39.385 32.558C36.262 36.86 30.734 37.091 25.531 37H18.75h-1.938c4.428-1.593 7.063-1.972 9.754-3.4 5.068-2.665 10.078-8.496 11.121-14.562-1.93 5.836-7.779 10.85-13.109 12.889-3.652 1.393-10.248 2.745-10.248 2.745l-.267-.145C9.573 32.268 9.437 22.214 17.6 18.968c3.574-1.423 6.993-.641 10.854-1.593 4.122-1.012 8.89-4.208 10.83-8.375C41.456 15.667 44.07 26.106 39.385 32.558zM15.668 38.445C15.386 38.795 14.955 39 14.505 39c-.823.0-1.495-.677-1.495-1.5s.677-1.5 1.495-1.5c.341.0.677.118.941.336C16.086 36.855 16.186 37.805 15.668 38.445z"/></svg>&nbsp; Spring Cloud 系列</a>
<a class=sub-nav-link href=https://www.moonkite.cn/category/other><img width=20 height=20 src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAADWElEQVR4nO2X30tTYRjH9xd4X2Dsol1EEtJdEFiSF10pldlVaVHEjiFFkKQVQeV0kfSTHdfW1pzKlpZtzXJuzp2pmzPFTdmUTdLJlEAvNKyB8MYzPG/visHZ2jxrnQc+8PCc85zz/e592XkfkUgIIYT4v2OoTVrtVFDTjILaYmgK8YqC2oproalzKZlwKqga3sXTSeFuZts9ykWcNOXnbITcTj67IRQcG1rlE5/dECK3GXcjxC8ADwqMuxGfBMeGVklNaRmZ83z0L3+ZR3ywMBfInJHQqGl07esKAmYjK6hnJoph64Ar/KsOOXmNK6HOTszKtD9uJitGQGSRcQFDiqh1RHAd8nSMWMQSDJgRjLAhrIgxta3lDvaiRlMpxvKvbi3BCNfI+xVRehdRIT2DIUWdejeH65BzMWKd1KO6jqOYLrEE46fp7Bm5bgki0Q0bhhS1t3UM1yHnYuS1XY5Oy0swD8USjPNmQ2aNfO6WO0KjphHgbrc9XNjsirGwdeAY7Vpl65CT15LRYb4VltLHYyzKAwcxgw3Xwr5BQ9D9ll53dz9d+msjfNLfWoO6GstR7/0zCXXBCJMPKxLMl3kkmC9GQsTf706znK3vyKLdhtznL2ISPm5TaqQdro8DeTJxm4EHKDZRGQfy308HtdvAcJY1I3BsII8RpAgwwB41IE9mBAwgR0EcyMlrRcTxB45DgpFUV+RbSIMxuq4kXRFyFl+3VuTeiqBtQYCDqUxqhOyJPCsTjDDCitB5urW8zS2oTSzBxNS7MB3tpeiC4kicO8azCQLJnkB9Me750Xs44b4CmQcjc4SzZwSGHXL42Xy0B6NTHMIDUp36RIJAsmeS2od7vuuKE+4TEUMbDHGZMLLBNrlUV/3u9sYRwH7vkq/nZFmUJaotwfRoK5bk6qoooNRUh9kegOyZkpUtsT3zuvKE+6qev4myKF899nkNTeMTJuWsu6spTBjZ4GzESUv7+R6qmCQ4aeoTZyPDLy4XMTS1xrdo5k/WmDbpflEq4XpJ7XbS1O0+bYvnve7JLNCnkXkZWmrYCfo0Mi9+r7bFA1pAkyjd0Ov1EZVKhQDI034Q3++1mM39H8xmBECeEZV8vNdmtRptAwMojtVqzIjKHH6vEEIIIcrt+AnU4LBcH67z1wAAAABJRU5ErkJggg=="> &nbsp; 杂七杂八</a></div></li><li class=nav-item><a href=https://www.moonkite.cn/category/network class=nav-link><i class="fas fa-network-wired"></i>轻解计算机网络</a></li><li class=nav-item><a href=https://www.moonkite.cn/category/product class=nav-link><i class="fas fab fa-medapps"></i>我的产品</a></li></ul></div></nav></div><div class="container header-wrapper"><div class=row><div class=col-lg-12><div class=header-content><h1 class=header-title>什么是零拷贝|Java中的零拷贝</h1><p class=header-date>作者：
风筝 /
2018-05-10<div class=header-underline></div><div class=clearfix></div><p class="float-right header-tags"><i class="fas fa-tags" aria-hidden=true></i>
<a href=https://www.moonkite.cn/tag/Java/>Java</a>,
<a href=https://www.moonkite.cn/tag/JDK/>JDK</a>,
<a href=https://www.moonkite.cn/tag/%E9%9B%B6%E6%8B%B7%E8%B4%9D/>零拷贝</a></p></div></div></div></div></div><main><div class="container content"><article><p><strong>大家好，我是风筝</strong></p><p>我们总会在各种地方看到零拷贝，那零拷贝到底是个什么东西。</p><p>接下来，让我们来理一理啊。</p><p>拷贝说的是计算机里的 I/O 操作，也就是数据的读写操作。计算机可是一个复杂的家伙，包括软件和硬件两大部分，软件主要指操作系统、驱动程序和应用程序。硬件那就多了，CPU、内存、硬盘等等一大堆东西。</p><p>这么复杂的设备要进行读写操作，其中繁琐和复杂程度可想而知。</p><h2 id=传统-io-的读写过程>传统 I/O 的读写过程</h2><p>如果要了解零拷贝，那就必须要知道一般情况下，计算机是如何读写数据的，我把这种情况称为传统 I/O。</p><p>数据读写的发起者是计算机中的应用程序，比如我们常用的浏览器、办公软件、音视频软件等。</p><p>而数据的来源呢，一般是硬盘、外部存储设备或者是网络套接字（也就是网络上的数据通过网口+网卡的处理）。</p><p>过程本来是很复杂的，所以大学课程里要通过《操作系统》、《计算机组成原理》来专门讲计算机的软硬件。</p><h3 id=简化版读操作流程>简化版读操作流程</h3><p>那么细的没办法讲来，所以，我们把这个读写过程简化一下，忽略大多数细节，只讲流程。</p><p><img src=https://hexo.moonkite.cn/blog/image-20230719182852190.png alt></p><p>上图是应用程序进行一次读操作的过程。</p><ol><li>应用程序先发起读操作，准备读取数据了；</li><li>内核将数据从硬盘或外部存储读取到内核缓冲区；</li><li>内核将数据从内核缓冲区拷贝到用户缓冲区；</li><li>应用程序读取用户缓冲区的数据进行处理加工；</li></ol><h3 id=详细的读写操作流程>详细的读写操作流程</h3><p>下面是一个更详细的 I/O 读写过程。这个图可好用极了，我会借助这个图来厘清 I/O 操作的一些基础但非常重要的概念。</p><p><img src=https://hexo.moonkite.cn/blog/%E4%BC%A0%E7%BB%9FIO%E8%AF%BB%E5%86%992.png alt></p><p>先看一下这个图，上面红粉色部分是读操作，下面蓝色部分是写操作。</p><p>如果一下子看着有点儿迷糊的话，没关系，看看下面几个概念就清楚了。</p><h4 id=应用程序>应用程序</h4><p>就是安装在操作系统上的各种应用。</p><h4 id=系统内核>系统内核</h4><p>系统内核是一些列计算机的核心资源的集合，不仅包括 CPU、总线这些硬件设备，也包括进程管理、文件管理、内存管理、设备驱动、系统调用等一些列功能。</p><h4 id=外部存储>外部存储</h4><p>外部存储就是指硬盘、U 盘等外部存储介质。</p><h4 id=内核态>内核态</h4><ul><li>内核态是操作系统内核运行的模式，当操作系统内核执行特权指令时，处于内核态。</li><li>在内核态下，操作系统内核拥有最高权限，可以访问计算机的所有硬件资源和敏感数据，执行特权指令，控制系统的整体运行。</li><li>内核态提供了操作系统管理和控制计算机硬件的能力，它负责处理系统调用、中断、硬件异常等核心任务。</li></ul><h4 id=用户态>用户态</h4><p>这里的用户可以理解为应用程序，这个用户是对于计算机的内核而言的，对于内核来说，系统上的各种应用程序会发出指令来调用内核的资源，这时候，应用程序就是内核的用户。</p><ul><li>用户态是应用程序运行的模式，当应用程序执行普通的指令时，处于用户态。</li><li>在用户态下，应用程序只能访问自己的内存空间和受限的硬件资源，无法直接访问操作系统的敏感数据或控制计算机的硬件设备。</li><li>用户态提供了一种安全的运行环境，确保应用程序之间相互隔离，防止恶意程序对系统造成影响。</li></ul><h4 id=模式切换>模式切换</h4><p>计算机为了安全性考虑，区分了内核态和用户态，应用程序不能直接调用内核资源，必须要切换到内核态之后，让内核来调用，内核调用完资源，再返回给应用程序，这个时候，系统在切换会用户态，应用程序在用户态下才能处理数据。</p><p>上述过程其实一次读和一次写都分别发生了两次模式切换。</p><p><img src=https://hexo.moonkite.cn/blog/%E6%A8%A1%E6%80%81%E5%88%87%E6%8D%A2.png alt></p><h4 id=内核缓冲区>内核缓冲区</h4><p>内核缓冲区指内存中专门用来给内核直接使用的内存空间。可以把它理解为应用程序和外部存储进行数据交互的一个中间介质。</p><p>应用程序想要读外部数据，要从这里读。应用程序想要写入外部存储，要通过内核缓冲区。</p><h4 id=用户缓冲区>用户缓冲区</h4><p>用户缓冲区可以理解为应用程序可以直接读写的内存空间。因为应用程序没法直接到内核读写数据， 所以应用程序想要处理数据，必须先通过用户缓冲区。</p><h4 id=磁盘缓冲区>磁盘缓冲区</h4><p>磁盘缓冲区是计算机内存中用于暂存从磁盘读取的数据或将数据写入磁盘之前的临时存储区域。它是一种优化磁盘 I/O 操作的机制，通过利用内存的快速访问速度，减少对慢速磁盘的频繁访问，提高数据读取和写入的性能和效率。</p><h4 id=pagecache>PageCache</h4><ul><li>PageCache 是 Linux 内核对文件系统进行缓存的一种机制。它使用空闲内存来缓存从文件系统读取的数据块，加速文件的读取和写入操作。</li><li>当应用程序或进程读取文件时，数据会首先从文件系统读取到 PageCache 中。如果之后再次读取相同的数据，就可以直接从 PageCache 中获取，避免了再次访问文件系统。</li><li>同样，当应用程序或进程将数据写入文件时，数据会先暂存到 PageCache 中，然后由 Linux 内核异步地将数据写入磁盘，从而提高写入操作的效率。</li></ul><h4 id=再说数据读写操作流程>再说数据读写操作流程</h4><p>上面弄明白了这几个概念后，再回过头看一下那个流程图，是不是就清楚多了。</p><h5 id=读操作>读操作</h5><ol><li>首先应用程序向内核发起读请求，这时候进行一次模式切换了，从用户态切换到内核态；</li><li>内核向外部存储或网络套接字发起读操作；</li><li>将数据写入磁盘缓冲区；</li><li>系统内核将数据从磁盘缓冲区拷贝到内核缓冲区，顺便再将一份（或者一部分）拷贝到 PageCache；</li><li>内核将数据拷贝到用户缓冲区，供应用程序处理。此时又进行一次模态切换，从内核态切换回用户态；</li></ol><h5 id=写操作>写操作</h5><ol><li>应用程序向内核发起写请求，这时候进行一次模式切换了，从用户态切换到内核态；</li><li>内核将要写入的数据从用户缓冲区拷贝到 PageCache，同时将数据拷贝到内核缓冲区；</li><li>然后内核将数据写入到磁盘缓冲区，从而写入磁盘，或者直接写入网络套接字。</li></ol><h2 id=瓶颈在哪里>瓶颈在哪里</h2><p>但是传统 I/O 有它的瓶颈，这才是零拷贝技术出现的缘由。瓶颈是啥呢，当然是性能问题，太慢了。尤其是在高并发场景下，I/O 性能经常会卡脖子。</p><p>那是什么地方耗时了呢？</p><h3 id=数据拷贝>数据拷贝</h3><p>在传统 I/O 中，数据的传输通常涉及多次数据拷贝。数据需要从应用程序的用户缓冲区复制到内核缓冲区，然后再从内核缓冲区复制到设备或网络缓冲区。这些数据拷贝过程导致了多次内存访问和数据复制，消耗了大量的 CPU 时间和内存带宽。</p><h3 id=用户态和内核态的切换>用户态和内核态的切换</h3><p>由于数据要经过内核缓冲区，导致数据在用户态和内核态之间来回切换，切换过程中会有上下文的切换，如此一来，大大增加了处理数据的复杂性和时间开销。</p><p>每一次操作耗费的时间虽然很小，但是当并发量高了以后，积少成多，也是不小的开销。所以要提高性能、减少开销就要从以上两个问题下手了。</p><p>这时候，零拷贝技术就出来解决问题了。</p><h2 id=什么是零拷贝>什么是零拷贝</h2><p>问题出来数据拷贝和模态切换上。</p><p>但既然是 I/O 操作，不可能没有数据拷贝的，只能减少拷贝的次数，还有就是尽量将数据存储在离应用程序（用户缓冲区）更近的地方。</p><p>而区分用户态和内核态有其他更重要的原因，不可能单纯为了 I/O 效率就改变这种设计吧。那也只能尽量减少切换的次数。</p><p>零拷贝的理想状态就是操作数据不用拷贝，但是显示情况下并不一定真的就是一次复制操作都没有，而是尽量减少拷贝操作的次数。</p><p>要实现零拷贝，应该从下面这三个方面入手：</p><ol><li>尽量减少数据在各个存储区域的复制操作，例如从磁盘缓冲区到内核缓冲区等；</li><li>尽量减少用户态和内核态的切换次数及上下文切换；</li><li>使用一些优化手段，例如对需要操作的数据先缓存起来，内核中的 PageCache 就是这个作用；</li></ol><h2 id=实现零拷贝方案>实现零拷贝方案</h2><h3 id=直接内存访问dma>直接内存访问（DMA）</h3><p>DMA 是一种硬件特性，允许外设（如网络适配器、磁盘控制器等）直接访问系统内存，而无需通过 CPU 的介入。在数据传输时，DMA 可以直接将数据从内存传输到外设，或者从外设传输数据到内存，避免了数据在用户态和内核态之间的多次拷贝。</p><p><img src=https://hexo.moonkite.cn/blog/DMA1.png alt=DMA1></p><p>如上图所示，内核将数据读取的大部分数据读取操作都交个了 DMA 控制器，而空出来的资源就可以去处理其他的任务了。</p><h3 id=sendfile>sendfile</h3><p>一些操作系统（例如 Linux）提供了特殊的系统调用，如 sendfile，在网络传输文件时实现零拷贝。通过 sendfile，应用程序可以直接将文件数据从文件系统传输到网络套接字或者目标文件，而无需经过用户缓冲区和内核缓冲区。</p><p>如果不用 sendfile，如果将 A 文件写入 B 文件。</p><ol><li>需要先将 A 文件的数据拷贝到内核缓冲区，再从内核缓冲区拷贝到用户缓冲区；</li><li>然后内核再将用户缓冲区的数据拷贝到内核缓冲区，之后才能写入到 B 文件；</li></ol><p>而用了 sendfile，用户缓冲区和内核缓冲区的拷贝都不用了，节省了一大部分的开销。</p><h3 id=共享内存>共享内存</h3><p>使用共享内存技术，应用程序和内核可以共享同一块内存区域，避免在用户态和内核态之间进行数据拷贝。应用程序可以直接将数据写入共享内存，然后内核可以直接从共享内存中读取数据进行传输，或者反之。</p><p><img src=https://hexo.moonkite.cn/blog/image-20230721145324364.png alt></p><p>通过共享一块儿内存区域，实现数据的共享。就像程序中的引用对象一样，实际上就是一个指针、一个地址。</p><h3 id=内存映射文件memory-mapped-files>内存映射文件（Memory-mapped Files）</h3><p>内存映射文件直接将磁盘文件映射到应用程序的地址空间，使得应用程序可以直接在内存中读取和写入文件数据，这样一来，对映射内容的修改就是直接的反应到实际的文件中。</p><p>当文件数据需要传输时，内核可以直接从内存映射区域读取数据进行传输，避免了数据在用户态和内核态之间的额外拷贝。</p><p>虽然看上去感觉和共享内存没什么差别，但是两者的实现方式完全不同，一个是共享地址，一个是映射文件内容。</p><h2 id=java-实现零拷贝的方式>Java 实现零拷贝的方式</h2><p>Java 标准的 IO 库是没有零拷贝方式的实现的，标准 IO 就相当于上面所说的传统模式。只是在 Java 推出的 NIO 中，才包含了一套新的 I/O 类，如 <code>ByteBuffer</code> 和 <code>Channel</code>，它们可以在一定程度上实现零拷贝。</p><p><code>ByteBuffer</code>：可以直接操作字节数据，避免了数据在用户态和内核态之间的复制。</p><p><code>Channel</code>：支持直接将数据从文件通道或网络通道传输到另一个通道，实现文件和网络的零拷贝传输。</p><p>借助这两种对象，结合 NIO 中的 API，我们就能在 Java 中实现零拷贝了。</p><p>首先我们先用传统 IO 写一个方法，用来和后面的 NIO 作对比，这个程序的目的很简单，就是将一个 100M 左右的 PDF 文件从一个目录拷贝到另一个目录。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>ioCopy</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>File</span><span class=w> </span><span class=n>sourceFile</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>File</span><span class=p>(</span><span class=n>SOURCE_FILE_PATH</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>File</span><span class=w> </span><span class=n>targetFile</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>File</span><span class=p>(</span><span class=n>TARGET_FILE_PATH</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>try</span><span class=w> </span><span class=p>(</span><span class=n>FileInputStream</span><span class=w> </span><span class=n>fis</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>FileInputStream</span><span class=p>(</span><span class=n>sourceFile</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=n>FileOutputStream</span><span class=w> </span><span class=n>fos</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>FileOutputStream</span><span class=p>(</span><span class=n>targetFile</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=kt>byte</span><span class=o>[]</span><span class=w> </span><span class=n>buffer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>byte</span><span class=o>[</span><span class=n>1024</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=kt>int</span><span class=w> </span><span class=n>bytesRead</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>while</span><span class=w> </span><span class=p>((</span><span class=n>bytesRead</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>fis</span><span class=p>.</span><span class=na>read</span><span class=p>(</span><span class=n>buffer</span><span class=p>))</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=o>-</span><span class=n>1</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>fos</span><span class=p>.</span><span class=na>write</span><span class=p>(</span><span class=n>buffer</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=n>bytesRead</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;传输 &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>formatFileSize</span><span class=p>(</span><span class=n>sourceFile</span><span class=p>.</span><span class=na>length</span><span class=p>())</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34; 字节到目标文件&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>IOException</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>e</span><span class=p>.</span><span class=na>printStackTrace</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>下面是这个拷贝程序的执行结果，109.92M，耗时 1.29 秒。</p><blockquote><p>传输 109.92 M 字节到目标文件
耗时: 1.290 秒</p></blockquote><h3 id=filechanneltransferto-和-transferfrom>FileChannel.transferTo() 和 transferFrom()</h3><p>FileChannel 是一个用于文件读写、映射和操作的通道，同时它在并发环境下是线程安全的，基于 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 getChannel() 方法可以创建并打开一个文件通道。FileChannel 定义了 transferFrom() 和 transferTo() 两个抽象方法，它通过在通道和通道之间建立连接实现数据传输的。</p><p>这两个方法首选用 sendfile 方式，只要当前操作系统支持，就用 sendfile，例如 Linux 或 MacOS。如果系统不支持，例如 windows，则采用内存映射文件的方式实现。</p><h4 id=transferto>transferTo()</h4><p>下面是一个 transferTo 的例子，仍然是拷贝那个 100M 左右的 PDF，我的系统是 MacOS。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>nioTransferTo</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>File</span><span class=w> </span><span class=n>sourceFile</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>File</span><span class=p>(</span><span class=n>SOURCE_FILE_PATH</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>File</span><span class=w> </span><span class=n>targetFile</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>File</span><span class=p>(</span><span class=n>TARGET_FILE_PATH</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>try</span><span class=w> </span><span class=p>(</span><span class=n>FileChannel</span><span class=w> </span><span class=n>sourceChannel</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>RandomAccessFile</span><span class=p>(</span><span class=n>sourceFile</span><span class=p>,</span><span class=w> </span><span class=s>&#34;r&#34;</span><span class=p>).</span><span class=na>getChannel</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=n>FileChannel</span><span class=w> </span><span class=n>targetChannel</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>RandomAccessFile</span><span class=p>(</span><span class=n>targetFile</span><span class=p>,</span><span class=w> </span><span class=s>&#34;rw&#34;</span><span class=p>).</span><span class=na>getChannel</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=kt>long</span><span class=w> </span><span class=n>transferredBytes</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>sourceChannel</span><span class=p>.</span><span class=na>transferTo</span><span class=p>(</span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=n>sourceChannel</span><span class=p>.</span><span class=na>size</span><span class=p>(),</span><span class=w> </span><span class=n>targetChannel</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;传输 &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>formatFileSize</span><span class=p>(</span><span class=n>transferredBytes</span><span class=p>)</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34; 字节到目标文件&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>IOException</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>e</span><span class=p>.</span><span class=na>printStackTrace</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>只耗时 0.536 秒，快了一倍。</p><blockquote><p>传输 109.92 M 字节到目标文件
耗时: 0.536 秒</p></blockquote><h4 id=transferfrom>transferFrom()</h4><p>下面是一个 transferFrom 的例子，仍然是拷贝那个 100M 左右的 PDF，我的系统是 MacOS。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>nioTransferFrom</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>File</span><span class=w> </span><span class=n>sourceFile</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>File</span><span class=p>(</span><span class=n>SOURCE_FILE_PATH</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>File</span><span class=w> </span><span class=n>targetFile</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>File</span><span class=p>(</span><span class=n>TARGET_FILE_PATH</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>try</span><span class=w> </span><span class=p>(</span><span class=n>FileChannel</span><span class=w> </span><span class=n>sourceChannel</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>RandomAccessFile</span><span class=p>(</span><span class=n>sourceFile</span><span class=p>,</span><span class=w> </span><span class=s>&#34;r&#34;</span><span class=p>).</span><span class=na>getChannel</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=n>FileChannel</span><span class=w> </span><span class=n>targetChannel</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>RandomAccessFile</span><span class=p>(</span><span class=n>targetFile</span><span class=p>,</span><span class=w> </span><span class=s>&#34;rw&#34;</span><span class=p>).</span><span class=na>getChannel</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=kt>long</span><span class=w> </span><span class=n>transferredBytes</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>targetChannel</span><span class=p>.</span><span class=na>transferFrom</span><span class=p>(</span><span class=n>sourceChannel</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=n>sourceChannel</span><span class=p>.</span><span class=na>size</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;传输 &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>formatFileSize</span><span class=p>(</span><span class=n>transferredBytes</span><span class=p>)</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34; 字节到目标文件&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>IOException</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>e</span><span class=p>.</span><span class=na>printStackTrace</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>执行时间：</p><blockquote><p>传输 109.92 M 字节到目标文件
耗时: 0.603 秒</p></blockquote><h3 id=memory-mapped-files><strong>Memory-Mapped Files</strong></h3><p>Java 的 NIO 也支持内存映射文件（Memory-mapped Files），通过 <code>FileChannel.map()</code> 实现。</p><p>下面是一个 <code>FileChannel.map()</code>的例子，仍然是拷贝那个 100M 左右的 PDF，我的系统是 MacOS。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>nioMap</span><span class=p>(){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>File</span><span class=w> </span><span class=n>sourceFile</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>File</span><span class=p>(</span><span class=n>SOURCE_FILE_PATH</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>File</span><span class=w> </span><span class=n>targetFile</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>File</span><span class=p>(</span><span class=n>TARGET_FILE_PATH</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>try</span><span class=w> </span><span class=p>(</span><span class=n>FileChannel</span><span class=w> </span><span class=n>sourceChannel</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>RandomAccessFile</span><span class=p>(</span><span class=n>sourceFile</span><span class=p>,</span><span class=w> </span><span class=s>&#34;r&#34;</span><span class=p>).</span><span class=na>getChannel</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                 </span><span class=n>FileChannel</span><span class=w> </span><span class=n>targetChannel</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>RandomAccessFile</span><span class=p>(</span><span class=n>targetFile</span><span class=p>,</span><span class=w> </span><span class=s>&#34;rw&#34;</span><span class=p>).</span><span class=na>getChannel</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kt>long</span><span class=w> </span><span class=n>fileSize</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>sourceChannel</span><span class=p>.</span><span class=na>size</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>MappedByteBuffer</span><span class=w> </span><span class=n>buffer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>sourceChannel</span><span class=p>.</span><span class=na>map</span><span class=p>(</span><span class=n>FileChannel</span><span class=p>.</span><span class=na>MapMode</span><span class=p>.</span><span class=na>READ_ONLY</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=n>fileSize</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>targetChannel</span><span class=p>.</span><span class=na>write</span><span class=p>(</span><span class=n>buffer</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;传输 &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>formatFileSize</span><span class=p>(</span><span class=n>fileSize</span><span class=p>)</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34; 字节到目标文件&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>IOException</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>e</span><span class=p>.</span><span class=na>printStackTrace</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>执行时间：</p><blockquote><p>传输 109.92 M 字节到目标文件
耗时: 0.663 秒</p></blockquote></article><div class=toc><h2>文章目录</h2><nav id=TableOfContents><ul><li><a href=#传统-io-的读写过程>传统 I/O 的读写过程</a><ul><li><a href=#简化版读操作流程>简化版读操作流程</a></li><li><a href=#详细的读写操作流程>详细的读写操作流程</a></li></ul></li><li><a href=#瓶颈在哪里>瓶颈在哪里</a><ul><li><a href=#数据拷贝>数据拷贝</a></li><li><a href=#用户态和内核态的切换>用户态和内核态的切换</a></li></ul></li><li><a href=#什么是零拷贝>什么是零拷贝</a></li><li><a href=#实现零拷贝方案>实现零拷贝方案</a><ul><li><a href=#直接内存访问dma>直接内存访问（DMA）</a></li><li><a href=#sendfile>sendfile</a></li><li><a href=#共享内存>共享内存</a></li><li><a href=#内存映射文件memory-mapped-files>内存映射文件（Memory-mapped Files）</a></li></ul></li><li><a href=#java-实现零拷贝的方式>Java 实现零拷贝的方式</a><ul><li><a href=#filechanneltransferto-和-transferfrom>FileChannel.transferTo() 和 transferFrom()</a></li><li><a href=#memory-mapped-files><strong>Memory-Mapped Files</strong></a></li></ul></li></ul></nav></div><script>window.addEventListener("scroll",function(){var e=document.querySelector(".toc"),t=window.pageYOffset||document.documentElement.scrollTop,n=window.innerWidth||document.documentElement.clientWidth;t<360?e.style.top=380-t+"px":e.style.top="20px"})</script><h4>相关文章</h4><dl class=row><dd class=col-md-9><a href=/category/java/RPC-%E6%A6%82%E8%A7%88/>RPC框架的核心是什么？</a></dd><dd class=col-md-9><a href=/category/SpringCloud/0-Srping-Cloud-%E5%BC%80%E7%AF%87/>0. Spring Cloud 是什么</a></dd><dd class=col-md-9><a href=/category/SpringCloud/1-Spring-Cloud-Eureka-%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/>1. Spring Cloud Eureka 实现服务注册与发现</a></dd><dd class=col-md-9><a href=/category/SpringCloud/2-Spring-Cloud-Eureka-%E5%AE%9E%E7%8E%B0%E5%AE%89%E5%85%A8%E6%8E%A7%E5%88%B6/>2. Spring Cloud Eureka 实现安全控制</a></dd><dd class=col-md-9><a href=/category/SpringCloud/3-Spring-Cloud-Eureka-%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/>3. Spring Cloud Eureka 实现高可用服务发现注册中心</a></dd></dl><div class=author-card><div class=underline></div><div class=author-box><div class=qr-author-image><a href=/><img src=/images/person.jpg alt=风筝></a></div><div class=author-content><p class=author-title>作者</p><p class=author-name>风筝</p><p class=author-desc>古时的风筝，一个平庸的程序员，主语言 Java，第二语言 Python，其实学 Python 的时间比 Java 还要早。喜欢写博客，写博客的过程能加深自己对一个知识点的理解，同时还可以分享给他人。喜欢做一些小东西，所以也会一些前端的东西，React、JavaScript、CSS 都会一些，做一些小工具还够用。</p></div></div></div><script src=https://utteranc.es/client.js repo=huzhicheng/blog-comment issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></main><div class="footer gradient-2"><div class="container footer-container"><div class=row><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>网站地图</div><ul class=list-unstyled><li><a href=https://www.moonkite.cn/tags/>标签</a></li><li><a href=https://www.moonkite.cn/categories/>分类</a></li><li><a rel=alternate type=application/rss+xml href=https://www.moonkite.cn/index.xml><i class="fas fa-rss-square"></i> RSS订阅</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>社群</div><ul class=list-unstyled><li><a href=https://github.com/huzhicheng rel=noopener target=_blank>GitHub</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>友链</div><ul class=list-unstyled><li><a href=https://github.com/huzhicheng rel=noopener target=_blank>关于我</a></li></ul></div><div class="col-xs-12 col-sm-3 col-md-3 col-lg-3"><p class="pull-right text-right"><small><em>Proudly powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo</a></em></small><br><small><em>Theme - <a href=https://github.com/shaform/hugo-theme-den rel=noopener target=_blank>Den</a></em></small><br><small>&copy;
风筝
2023</small></p></div></div><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?e417ddf834c7bb7411207e1fa09815aa",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></div></div><script src=https://cdn.staticfile.org/jquery/3.3.1/jquery.slim.min.js integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script><script src=https://cdn.staticfile.org/popper.js/1.14.3/umd/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script><script src=https://cdn.staticfile.org/twitter-bootstrap/4.1.3/js/bootstrap.js></script><script>$(document).ready(function(){$("#load_disqus").length&&$(window).scroll(function(){if($("#load_disqus").length){var e=$("#load_disqus").offset().top,t=$(window).scrollTop(),n=t+$(window).height();t<e&&e<n&&load_disqus()}})})</script></body></html>