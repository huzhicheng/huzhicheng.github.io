<!doctype html><html lang=zh-cn itemscope itemtype=http://schema.org/WebPage><head><meta name=generator content="Hugo 0.119.0"><meta charset=utf-8><title>7000 字说清楚 HashMap，面试点都在里面了 · 古时的风筝</title><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=description content="这是上篇文章有趣的图说 HashMap，普通人也能看懂的文字版，其实是这篇先写完，然后画了不少图片，所以就写了一篇图片版的。图片版虽然读起来比"><meta name=360-site-verification content="e75339f1cfcde17f66f71aaf8b6983e9"><meta name=keywords content="Hugo,theme,编程,java,ChatGPT,程序员,开发"><link rel=canonical href=https://www.moonkite.cn/category/java/HashMap/><link rel=icon href=https://www.moonkite.cn/images/photo.png><link rel=stylesheet href=https://cdn.staticfile.org/twitter-bootstrap/4.1.3/css/bootstrap.min.css><link rel=stylesheet href=https://www.moonkite.cn/css/den.css><link href=https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/lxgwwenkaiscreen.min.css rel=stylesheet><meta property="og:title" content="7000 字说清楚 HashMap，面试点都在里面了"><meta property="og:description" content="这是上篇文章有趣的图说 HashMap，普通人也能看懂的文字版，其实是这篇先写完，然后画了不少图片，所以就写了一篇图片版的。图片版虽然读起来比"><meta property="og:type" content="article"><meta property="og:url" content="https://www.moonkite.cn/category/java/HashMap/"><meta property="article:section" content="category"><meta property="article:published_time" content="2020-06-21T08:56:23+08:00"><meta property="article:modified_time" content="2020-06-21T08:56:23+08:00"><meta itemprop=name content="7000 字说清楚 HashMap，面试点都在里面了"><meta itemprop=description content="这是上篇文章有趣的图说 HashMap，普通人也能看懂的文字版，其实是这篇先写完，然后画了不少图片，所以就写了一篇图片版的。图片版虽然读起来比"><meta itemprop=datePublished content="2020-06-21T08:56:23+08:00"><meta itemprop=dateModified content="2020-06-21T08:56:23+08:00"><meta itemprop=wordCount content="8358"><meta itemprop=keywords content="Java,JDK,HashMap,"><meta name=twitter:card content="summary"><meta name=twitter:title content="7000 字说清楚 HashMap，面试点都在里面了"><meta name=twitter:description content="这是上篇文章有趣的图说 HashMap，普通人也能看懂的文字版，其实是这篇先写完，然后画了不少图片，所以就写了一篇图片版的。图片版虽然读起来比"></head><body><div class=header-container style=background:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2)),url(https://hexo.moonkite.cn/blog/background.png);background-position:top;background-size:cover><div class=container><nav class="header-nav navbar navbar-expand-md navbar-dark light-dark"><div class="header-logo navbar-brand"><a class=float-left href=https://www.moonkite.cn/></a></div><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarNav aria-controls=navbarNav aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="nav-menu collapse navbar-collapse" id=navbarNav><ul class=navbar-nav><li class=nav-item><a href=https://www.moonkite.cn/ class=nav-link><i class="fas fad fa-h-square"></i>主页</a></li><li class=nav-item><a href=https://www.moonkite.cn/category/notes class=nav-link><i class='fas fa-yin-yang'></i>生活随笔</a></li><li class=nav-item><a href=javascript:void(0) class=nav-link><i class='fas fa-laptop-code'></i>技术文章</a><div class=sub-dropdown-menu><a class=sub-nav-link href=https://www.moonkite.cn/category/java><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 48 48"><path fill="#f44336" d="M23.65 24.898c-.998-1.609-1.722-2.943-2.725-5.455C19.229 15.2 31.24 11.366 26.37 3.999c2.111 5.089-7.577 8.235-8.477 12.473-.823 3.898 5.752 8.426 5.757 8.426z"/><path fill="#f44336" d="M23.878 17.27c-.192 2.516 2.229 3.857 2.299 5.695.056 1.496-1.447 2.743-1.447 2.743s2.728-.536 3.579-2.818c.945-2.534-1.834-4.269-1.548-6.298.267-1.938 6.031-5.543 6.031-5.543S24.311 11.611 23.878 17.27z"/><g><path fill="#1565c0" d="M32.084 25.055c1.754-.394 3.233.723 3.233 2.01.0 2.901-4.021 5.643-4.021 5.643s6.225-.742 6.225-5.505c0-3.15-3.057-3.937-5.437-2.148zm-2.955 2.34s1.941-1.383 2.458-1.902c-4.763 1.011-15.638 1.147-15.638.269.0-.809 3.507-1.638 3.507-1.638s-7.773-.112-7.773 2.181C11.683 28.695 21.858 28.866 29.129 27.395z"/><path fill="#1565c0" d="M27.935 29.571c-4.509 1.499-12.814 1.02-10.354-.993-1.198.0-2.974.963-2.974 1.889.0 1.857 8.982 3.291 15.63.572l-2.302-1.468z"/><path fill="#1565c0" d="M18.686 32.739c-1.636.0-2.695 1.054-2.695 1.822.0 2.391 9.76 2.632 13.627.205l-2.458-1.632C24.271 34.404 17.014 34.579 18.686 32.739z"/><path fill="#1565c0" d="M36.281 36.632c0-.936-1.055-1.377-1.433-1.588 2.228 5.373-22.317 4.956-22.317 1.784.0-.721 1.807-1.427 3.477-1.093l-1.42-.839C11.26 34.374 9 35.837 9 37.017 9 42.52 36.281 42.255 36.281 36.632z"/><path fill="#1565c0" d="M39 38.604c-4.146 4.095-14.659 5.587-25.231 3.057C24.341 46.164 38.95 43.628 39 38.604z"/></g></svg>&nbsp;可爱的 Java</a>
<a class=sub-nav-link href=https://www.moonkite.cn/category/SpringCloud><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 48 48"><path fill="#8bc34a" d="M43.982 23.635c.069-4.261-.891-9.328-2.891-15.273L39.523 3.7l-2.13 4.433c-.114.237-.244.469-.38.698C33.514 5.827 28.974 4 24 4 12.954 4 4 12.954 4 24s8.954 20 20 20 20-8.954 20-20C44 23.877 43.984 23.758 43.982 23.635z"/><path fill="#fff" d="M39.385 32.558C36.262 36.86 30.734 37.091 25.531 37H18.75h-1.938c4.428-1.593 7.063-1.972 9.754-3.4 5.068-2.665 10.078-8.496 11.121-14.562-1.93 5.836-7.779 10.85-13.109 12.889-3.652 1.393-10.248 2.745-10.248 2.745l-.267-.145C9.573 32.268 9.437 22.214 17.6 18.968c3.574-1.423 6.993-.641 10.854-1.593 4.122-1.012 8.89-4.208 10.83-8.375C41.456 15.667 44.07 26.106 39.385 32.558zM15.668 38.445C15.386 38.795 14.955 39 14.505 39c-.823.0-1.495-.677-1.495-1.5s.677-1.5 1.495-1.5c.341.0.677.118.941.336C16.086 36.855 16.186 37.805 15.668 38.445z"/></svg>&nbsp; Spring Cloud 系列</a>
<a class=sub-nav-link href=https://www.moonkite.cn/category/other><img width=20 height=20 src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAADWElEQVR4nO2X30tTYRjH9xd4X2Dsol1EEtJdEFiSF10pldlVaVHEjiFFkKQVQeV0kfSTHdfW1pzKlpZtzXJuzp2pmzPFTdmUTdLJlEAvNKyB8MYzPG/visHZ2jxrnQc+8PCc85zz/e592XkfkUgIIYT4v2OoTVrtVFDTjILaYmgK8YqC2oproalzKZlwKqga3sXTSeFuZts9ykWcNOXnbITcTj67IRQcG1rlE5/dECK3GXcjxC8ADwqMuxGfBMeGVklNaRmZ83z0L3+ZR3ywMBfInJHQqGl07esKAmYjK6hnJoph64Ar/KsOOXmNK6HOTszKtD9uJitGQGSRcQFDiqh1RHAd8nSMWMQSDJgRjLAhrIgxta3lDvaiRlMpxvKvbi3BCNfI+xVRehdRIT2DIUWdejeH65BzMWKd1KO6jqOYLrEE46fp7Bm5bgki0Q0bhhS1t3UM1yHnYuS1XY5Oy0swD8USjPNmQ2aNfO6WO0KjphHgbrc9XNjsirGwdeAY7Vpl65CT15LRYb4VltLHYyzKAwcxgw3Xwr5BQ9D9ll53dz9d+msjfNLfWoO6GstR7/0zCXXBCJMPKxLMl3kkmC9GQsTf706znK3vyKLdhtznL2ISPm5TaqQdro8DeTJxm4EHKDZRGQfy308HtdvAcJY1I3BsII8RpAgwwB41IE9mBAwgR0EcyMlrRcTxB45DgpFUV+RbSIMxuq4kXRFyFl+3VuTeiqBtQYCDqUxqhOyJPCsTjDDCitB5urW8zS2oTSzBxNS7MB3tpeiC4kicO8azCQLJnkB9Me750Xs44b4CmQcjc4SzZwSGHXL42Xy0B6NTHMIDUp36RIJAsmeS2od7vuuKE+4TEUMbDHGZMLLBNrlUV/3u9sYRwH7vkq/nZFmUJaotwfRoK5bk6qoooNRUh9kegOyZkpUtsT3zuvKE+6qev4myKF899nkNTeMTJuWsu6spTBjZ4GzESUv7+R6qmCQ4aeoTZyPDLy4XMTS1xrdo5k/WmDbpflEq4XpJ7XbS1O0+bYvnve7JLNCnkXkZWmrYCfo0Mi9+r7bFA1pAkyjd0Ov1EZVKhQDI034Q3++1mM39H8xmBECeEZV8vNdmtRptAwMojtVqzIjKHH6vEEIIIcrt+AnU4LBcH67z1wAAAABJRU5ErkJggg=="> &nbsp; 杂七杂八</a></div></li><li class=nav-item><a href=https://www.moonkite.cn/category/network class=nav-link><i class="fas fa-network-wired"></i>轻解计算机网络</a></li><li class=nav-item><a href=https://www.moonkite.cn/category/product class=nav-link><i class="fas fab fa-medapps"></i>我的产品</a></li></ul></div></nav></div><div class="container header-wrapper"><div class=row><div class=col-lg-12><div class=header-content><h1 class=header-title>7000 字说清楚 HashMap，面试点都在里面了</h1><p class=header-date>作者：
风筝 /
2020-06-21<div class=header-underline></div><div class=clearfix></div><p class="float-right header-tags"><i class="fas fa-tags" aria-hidden=true></i>
<a href=https://www.moonkite.cn/tag/HashMap/>HashMap</a>,
<a href=https://www.moonkite.cn/tag/Java/>Java</a>,
<a href=https://www.moonkite.cn/tag/JDK/>JDK</a></p></div></div></div></div></div><main><div class="container content"><article><p>这是上篇文章<a href=https://www.moonkite.cn/category/java/HashMap%E6%BC%AB%E7%94%BB%E7%89%88/>有趣的图说 HashMap，普通人也能看懂</a>的文字版，其实是这篇先写完，然后画了不少图片，所以就写了一篇图片版的。图片版虽然读起来比较轻松，但是没有文字版的详细，本篇 7000 多字，建议三连。</p><p>在 Java 中，最常用的数据类型是 8 中基本类型以及他们的包装类型以及字符串类型，其次应该就是 <code>ArrayList</code>和<code>HashMap</code>了吧。<code>HashMap</code>存的是键值对类型的数据，其存储和获取的速度快、性能高，是非常好用的一个数据结构，每一个 Java 开发者都肯定用过它。</p><p>而且 <code>HashMap</code>的设计巧妙，其结构和原理也经常被拿去当做面试题。其中有很多巧妙的算法和设计，比如 Hash 算法、拉链法、红黑树设计等，值得每一个开发者借鉴学习。</p><p>想了老半天，怎么才能简单易懂的把 <code>HashMap</code>说明白呢，那就从我理解它的思路和过程去说吧。要理解一个事物最好的方式就是先了解整体结构，再去追究细节。所以，我们先从结构谈起。</p><h2 id=先从结构说起>先从结构说起</h2><p>拿我自身的一个体会来说吧，风筝我作为一个专业路痴，对于迷路这件事儿绝不含糊，虽然在北京混迹多年，但是只在中关村能分清南北，其他地方，哪怕是我每天住的小区、每天工作的公司也分不太清方向，回家只能认一条路，要是打车换条路回家，也得迷糊一阵，这么说吧，在小区前面能回家，小区后面找不到家。去个新地方，得盯着地图看半天。这时，我就在想啊，要是我能在城市上空俯瞰下面的街道，那我就再也不怕找不到回家的路了。这不就是三体里的降维打击吗，站在高维的立场，理解低维的事物，那就简单多了。</p><p>理解数据结构也是一个道理，大多数时候，我们都是停留在会用的层面上，理解一些原理也只是支离破碎的，困在数据机构的迷宫里跌跌撞撞，迫切的需要一张地图或者一架直升机。</p><p>先来看一下整个 <code>Map</code>家族的集成关系图，一看东西还不少，但其他的可能都没怎么用过，只有 <code>HashMap</code>最熟悉。</p><p><img src=https://hexo.moonkite.cn/blog/640.jpeg alt></p><p>以下描述可能不够专业，只为简单的描述 <code>HashMap</code>的结构，请结合下图进行理解。</p><p><img src=https://hexo.moonkite.cn/blog/640-20230607151814343.jpeg alt></p><p><code>HashMap</code>主体上就是一个数组结构，每一个索引位置英文叫做一个 bin，我们这里先管它叫做桶，比如你定义一个长度为 8 的 <code>HashMap</code>，那就可以说这是一个由 8 个桶组成的数组。当我们像数组中插入数据的时候，大多数时候存的都是一个一个 Node 类型的元素，Node 是 <code>HashMap</code>中定义的静态内部类。</p><p>当插入数据（也就是调用 put 方法）的时候，并不是按顺序一个一个向后存储的，<code>HashMap</code>中定义了一套专门的索引选择算法，叫做散列计算，但散列计算存在一种情况，叫哈希碰撞，也就是两个不一样的 key 散列计算出来的 hash 值是一致的，这种情况怎么办呢，采用拉链法进行扩展，比如图中蓝色的链表部分，这样一来，具有相同 hash 值的不同 key 即可以落到相同的桶中，又保证不会覆盖之前的内容。</p><p>但随着插入的元素越来越多，发生碰撞的概率就越大，某个桶中的链表就会越来越长，直到达到一个阈值，<code>HashMap</code>就受不了了，为了提升性能，会将超过阈值的链表转换形态，转换成红黑树的结构，这个阈值是 8 。也就是单个桶内的链表节点数大于 8 ，就会将链表变身为红黑树。</p><p>以上概括性的描述就是 <code>HashMap</code>的整体结构，也是我们进一步研究细节的蓝图。我们将从中抽取出几个关键点一一解释，从整体到细节，降维打击 <code>HashMap</code>。</p><p>接下来就是说明为什么会设计成这样的结构以及从单纯数组到桶内链表产生，接着把链表转换成红黑树的详细过程。</p><h2 id=认清几个关键概念>认清几个关键概念</h2><h3 id=存储容器>存储容器</h3><p>因为<code>HashMap</code>内部是用一个数组来保存内容的，数组定义如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>transient</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;[]</span> <span class=n>table</span><span class=o>;</span>
</span></span></code></pre></div><h3 id=node-类型>Node 类型</h3><p>table 是一个 <code>Node</code>类型的数组，<code>Node</code>是其中定义的静态内部类，主要包括 hash、key、value 和 next 的属性。比如之后我们使用 put 方法像其中加键值对的时候，就会转换成 Node 类型。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>static</span> <span class=kd>class</span> <span class=nc>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=kd>implements</span> <span class=n>Map</span><span class=o>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>final</span> <span class=kt>int</span> <span class=n>hash</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=kd>final</span> <span class=n>K</span> <span class=n>key</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=n>V</span> <span class=n>value</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>next</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=treenode>TreeNode</h3><p>前面说了，当桶内链表到达 8 的时候，会将链表转换成红黑树，就是 <code>TreeNode</code>类型，它也是 <code>HashMap</code>中定义的静态内部类。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>static</span> <span class=kd>final</span> <span class=kd>class</span> <span class=nc>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=kd>extends</span> <span class=n>LinkedHashMap</span><span class=o>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>parent</span><span class=o>;</span>  <span class=c1>// red-black tree links
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>left</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>right</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>prev</span><span class=o>;</span>    <span class=c1>// needed to unlink next upon deletion
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>boolean</span> <span class=n>red</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=容量和默认容量>容量和默认容量</h3><p>容量就是 table 数组的长度，也就是我们所说的桶的个数。其定义如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kt>int</span> <span class=n>threshold</span><span class=o>;</span>
</span></span></code></pre></div><p>默认是 16，如果我们在初始化的时候没有指定大小，那就是 16。当然我们也可以自己指定初始大小，而 <code>HashMap</code> 要求初始大小必须是 2 的 幂次方。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>DEFAULT_INITIAL_CAPACITY</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>4</span><span class=o>;</span> <span class=c1>// aka 16
</span></span></span></code></pre></div><h3 id=元素个数>元素个数</h3><p>容量是指定了桶的个数，而 size 是说 <code>HashMap</code>中实际存了多少个键值对。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>transient</span> <span class=kt>int</span> <span class=n>size</span><span class=o>;</span>
</span></span></code></pre></div><h3 id=最大容量>最大容量</h3><p>table 的长度也是有限制的，不能无限大，<code>HashMap</code>规定最大长度为 2 的30次方。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>MAXIMUM_CAPACITY</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>30</span><span class=o>;</span>
</span></span></code></pre></div><h3 id=负载因子>负载因子</h3><p>这是一个系数，它和 threshold 结合起作用，默认是 0.75。一般情况下不要改。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>final</span> <span class=kt>float</span> <span class=n>loadFactor</span><span class=o>;</span>
</span></span></code></pre></div><h3 id=扩容阈值>扩容阈值</h3><p><code>阈值 = 容量 x 负载因子</code>，假设当前 <code>HashMap</code>的容量是 16，负载因子是默认值 0.75，那么当 size 到达 <code>16 x 0.75=</code> 12 的时候，就会触发扩容。</p><h2 id=初始化-hashmap>初始化 HashMap</h2><p>使用 <code>HashMap</code>肯定要初始化吧，很多情况下都是用无参构造方法创建。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Map</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>map</span> <span class=o>=</span> <span class=k>new</span> <span class=n>HashMap</span><span class=o>&lt;&gt;();</span>
</span></span></code></pre></div><p>这种情况下所有属性都是默认值，比如容量是 16，负载因子是 0.75。</p><p>另外推荐的一种初始化方式，就是给定一个默认容量，比如指定默认容量是 32。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Map</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>map</span> <span class=o>=</span> <span class=k>new</span> <span class=n>HashMap</span><span class=o>&lt;&gt;(</span><span class=mi>32</span><span class=o>);</span>
</span></span></code></pre></div><p>但是 <code>HashMap</code> 要求初始大小必须是 2 的 n 次方，但是又不能要求每个开发人员指定初始容量的时候都按要求来，比如我们指定初始大小为为 7、18 这种会怎么样呢？</p><p>没关系，<code>HashMap</code>中有个方法专门负责将传过来的参数值转换为最接近、且大于等于指定参数的 2 的 n 次方的值，比如指定大小为 7 的话，最后实际的容量就是 8 ，如果指定大小为 18的话，那最后实际的容量就是 32 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=nf>HashMap</span><span class=o>(</span><span class=kt>int</span> <span class=n>initialCapacity</span><span class=o>,</span> <span class=kt>float</span> <span class=n>loadFactor</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>initialCapacity</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=o>(</span><span class=s>&#34;Illegal initial capacity: &#34;</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>                                       <span class=n>initialCapacity</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>initialCapacity</span> <span class=o>&gt;</span> <span class=n>MAXIMUM_CAPACITY</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=n>initialCapacity</span> <span class=o>=</span> <span class=n>MAXIMUM_CAPACITY</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>loadFactor</span> <span class=o>&lt;=</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>Float</span><span class=o>.</span><span class=na>isNaN</span><span class=o>(</span><span class=n>loadFactor</span><span class=o>))</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=o>(</span><span class=s>&#34;Illegal load factor: &#34;</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>                                       <span class=n>loadFactor</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=k>this</span><span class=o>.</span><span class=na>loadFactor</span> <span class=o>=</span> <span class=n>loadFactor</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=k>this</span><span class=o>.</span><span class=na>threshold</span> <span class=o>=</span> <span class=n>tableSizeFor</span><span class=o>(</span><span class=n>initialCapacity</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>执行这个转换动作的就是 <code>tableSizeFor</code>方法，经过转换后，将最终的结果赋值给 <code>threshold</code>变量，也就是初始容量，也就是本篇中所说的桶个数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=nf>tableSizeFor</span><span class=o>(</span><span class=kt>int</span> <span class=n>cap</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>cap</span> <span class=o>-</span> <span class=mi>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=n>n</span> <span class=o>|=</span> <span class=n>n</span> <span class=o>&gt;&gt;&gt;</span> <span class=mi>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=n>n</span> <span class=o>|=</span> <span class=n>n</span> <span class=o>&gt;&gt;&gt;</span> <span class=mi>2</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=n>n</span> <span class=o>|=</span> <span class=n>n</span> <span class=o>&gt;&gt;&gt;</span> <span class=mi>4</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=n>n</span> <span class=o>|=</span> <span class=n>n</span> <span class=o>&gt;&gt;&gt;</span> <span class=mi>8</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=n>n</span> <span class=o>|=</span> <span class=n>n</span> <span class=o>&gt;&gt;&gt;</span> <span class=mi>16</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>(</span><span class=n>n</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=o>)</span> <span class=o>?</span> <span class=mi>1</span> <span class=o>:</span> <span class=o>(</span><span class=n>n</span> <span class=o>&gt;=</span> <span class=n>MAXIMUM_CAPACITY</span><span class=o>)</span> <span class=o>?</span> <span class=n>MAXIMUM_CAPACITY</span> <span class=o>:</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p><code>tableSizeFor</code>这个方法就有意思了，先把初始参数减 1，然后连着做<code>或等于</code>和<code>无符号右移</code>操作，最后算出一个接近的 2 的幂次方，下图演示了初始参数为 18 时的一系列操作，最后得出的初始大小为 32。</p><p><img src=https://hexo.moonkite.cn/blog/640-20230607151924028.jpeg alt></p><p>这个算法很有意思了，比如你给的初始大小是 63，那得到的结果就是 64，如果初始大小给定 65 ，那得到的结果就是 128，总是能得出<strong>不小于给定初始大小，并且最接近的2的n次方</strong>的最终值。</p><h2 id=从-put-方法解密核心原理>从 put 方法解密核心原理</h2><p><code>put</code>方法是增加键值对最常用的方法，也是最复杂的过程，增加键值对的过程涉及了 <code>HashMap</code>最核心的原理，主要包括以下几点：</p><ol><li>什么情况下会扩容，扩容的规则是什么？</li><li>插入键值对的时候如何确定索引，<code>HashMap</code>可不是按顺序插入的，那样不就真成了数组了吗。</li><li>如何确保 key 的唯一性？</li><li>发生哈希碰撞怎么处理？</li><li>拉链法是什么？</li><li>单桶内的链表如何转变成红黑树？</li></ol><p>以下是 put 方法的源码，我在其中做了注释。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>V</span> <span class=nf>put</span><span class=o>(</span><span class=n>K</span> <span class=n>key</span><span class=o>,</span> <span class=n>V</span> <span class=n>value</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>putVal</span><span class=o>(</span><span class=n>hash</span><span class=o>(</span><span class=n>key</span><span class=o>),</span> <span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>,</span> <span class=kc>false</span><span class=o>,</span> <span class=kc>true</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>final</span> <span class=n>V</span> <span class=nf>putVal</span><span class=o>(</span><span class=kt>int</span> <span class=n>hash</span><span class=o>,</span> <span class=n>K</span> <span class=n>key</span><span class=o>,</span> <span class=n>V</span> <span class=n>value</span><span class=o>,</span> <span class=kt>boolean</span> <span class=n>onlyIfAbsent</span><span class=o>,</span>
</span></span><span class=line><span class=cl>               <span class=kt>boolean</span> <span class=n>evict</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=n>HashMap</span><span class=o>.</span><span class=na>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;[]</span> <span class=n>tab</span><span class=o>;</span> <span class=c1>// 声明 Node 数组 tab
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>HashMap</span><span class=o>.</span><span class=na>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>p</span><span class=o>;</span>    <span class=c1>// 声明一个 Node 变量 p
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>n</span><span class=o>,</span> <span class=n>i</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>  * table 定义 transient Node&lt;K,V&gt;[] table; 用来存储 Node 节点
</span></span></span><span class=line><span class=cl><span class=cm>  * 如果 当前table为空，则调用resize() 方法分配数组空间
</span></span></span><span class=line><span class=cl><span class=cm>  */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>((</span><span class=n>tab</span> <span class=o>=</span> <span class=n>table</span><span class=o>)</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=o>(</span><span class=n>n</span> <span class=o>=</span> <span class=n>tab</span><span class=o>.</span><span class=na>length</span><span class=o>)</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=o>(</span><span class=n>tab</span> <span class=o>=</span> <span class=n>resize</span><span class=o>()).</span><span class=na>length</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// n 总是为 2 的幂次方，(n-1) &amp; hash 可确定 tab.length （也就是table数组长度）内的索引
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 然后 创建一个 Node 节点赋给当前索引
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=o>((</span><span class=n>p</span> <span class=o>=</span> <span class=n>tab</span><span class=o>[</span><span class=n>i</span> <span class=o>=</span> <span class=o>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=o>)</span> <span class=o>&amp;</span> <span class=n>hash</span><span class=o>])</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=n>tab</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>newNode</span><span class=o>(</span><span class=n>hash</span><span class=o>,</span> <span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>,</span> <span class=kc>null</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//如果当前索引位置已经有值了，怎么办
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 拉链法出场
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>HashMap</span><span class=o>.</span><span class=na>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>e</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>K</span> <span class=n>k</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 判断 key 值唯一性
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// p 是当前待插入索引处的值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 哈希值一致并且（当前位置的 key == 待插入的key(注意 == 符号)，或者key 不为null 并且 key.equals(k)）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>p</span><span class=o>.</span><span class=na>hash</span> <span class=o>==</span> <span class=n>hash</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>        <span class=o>((</span><span class=n>k</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=na>key</span><span class=o>)</span> <span class=o>==</span> <span class=n>key</span> <span class=o>||</span> <span class=o>(</span><span class=n>key</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>key</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>k</span><span class=o>))))</span> <span class=c1>//如果当前节点只有一个元素，且和待插入key一样 则覆盖
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// 将 p（当前索引）节点临时赋予 e
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>e</span> <span class=o>=</span> <span class=n>p</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>p</span> <span class=k>instanceof</span> <span class=n>HashMap</span><span class=o>.</span><span class=na>TreeNode</span><span class=o>)</span> <span class=c1>// 如果当前索引节点是一颗树节点
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>//插入节点树中 并返回
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>e</span> <span class=o>=</span> <span class=o>((</span><span class=n>HashMap</span><span class=o>.</span><span class=na>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;)</span><span class=n>p</span><span class=o>).</span><span class=na>putTreeVal</span><span class=o>(</span><span class=k>this</span><span class=o>,</span> <span class=n>tab</span><span class=o>,</span> <span class=n>hash</span><span class=o>,</span> <span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 当前索引节点即不是只有一个节点，也不是一颗树，说明是一个链表
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>binCount</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=o>;</span> <span class=o>++</span><span class=n>binCount</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>((</span><span class=n>e</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=na>next</span><span class=o>)</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span> <span class=c1>//找到没有 next 的节点，也就是最后一个
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=c1>// 创建一个 node 赋给 p.next
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=n>p</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>newNode</span><span class=o>(</span><span class=n>hash</span><span class=o>,</span> <span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>,</span> <span class=kc>null</span><span class=o>);</span>
</span></span><span class=line><span class=cl>          <span class=c1>// 如果当前位置+1之后大于 TREEIFY_THRESHOLD 则要进行树化
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=k>if</span> <span class=o>(</span><span class=n>binCount</span> <span class=o>&gt;=</span> <span class=n>TREEIFY_THRESHOLD</span> <span class=o>-</span> <span class=mi>1</span><span class=o>)</span> <span class=c1>// -1 for 1st
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>//执行树化操作
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>treeifyBin</span><span class=o>(</span><span class=n>tab</span><span class=o>,</span> <span class=n>hash</span><span class=o>);</span>
</span></span><span class=line><span class=cl>          <span class=k>break</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>//如果又发生key冲突则停止 后续这个节点会被相同的key覆盖
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>e</span><span class=o>.</span><span class=na>hash</span> <span class=o>==</span> <span class=n>hash</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>            <span class=o>((</span><span class=n>k</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>key</span><span class=o>)</span> <span class=o>==</span> <span class=n>key</span> <span class=o>||</span> <span class=o>(</span><span class=n>key</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>key</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>k</span><span class=o>))))</span>
</span></span><span class=line><span class=cl>          <span class=k>break</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span> <span class=o>=</span> <span class=n>e</span><span class=o>;</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>e</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span> <span class=c1>// existing mapping for key
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>V</span> <span class=n>oldValue</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>value</span><span class=o>;</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=o>(!</span><span class=n>onlyIfAbsent</span> <span class=o>||</span> <span class=n>oldValue</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=n>e</span><span class=o>.</span><span class=na>value</span> <span class=o>=</span> <span class=n>value</span><span class=o>;</span>
</span></span><span class=line><span class=cl>      <span class=n>afterNodeAccess</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>oldValue</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>++</span><span class=n>modCount</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 当实际长度大于 threshold 时 resize
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=o>(++</span><span class=n>size</span> <span class=o>&gt;</span> <span class=n>threshold</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=n>resize</span><span class=o>();</span>
</span></span><span class=line><span class=cl>  <span class=n>afterNodeInsertion</span><span class=o>(</span><span class=n>evict</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=首次初始化数组和扩容>首次初始化数组和扩容</h3><p>在执行 <code>put</code>方法时，第一步要检查 table 数组是否为空或者长度是否为 0，如果是这样的，说明这是首次插入键值对，需要执行 table 数组初始化操作。</p><p>另外，随之键值对添加的越来越多，<code>HashMap</code>的 size 越来越大，注意 size 前面说了，是实际的键值对数量，那么 size 到了多少就要扩容了呢，并不是等 size 和 threshold（容量）一样大了才扩容，而是到了阈值就开始扩容，阈值上面也说了，是<code>容量 x 负载因子</code>。</p><p>为什么放在一起说呢，因为首次初始化和扩容都是用的同一个方法，叫做 <code>resize()</code>。以下是我注释的 <code>resize()</code>方法。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>final</span> <span class=n>HashMap</span><span class=o>.</span><span class=na>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;[]</span> <span class=nf>resize</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 保存 table 副本，接下来 copy 到新数组用
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>HashMap</span><span class=o>.</span><span class=na>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;[]</span> <span class=n>oldTab</span> <span class=o>=</span> <span class=n>table</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 当前 table 的容量，是 length 而不是 size
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>oldCap</span> <span class=o>=</span> <span class=o>(</span><span class=n>oldTab</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>?</span> <span class=mi>0</span> <span class=o>:</span> <span class=n>oldTab</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 当前桶大小
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>oldThr</span> <span class=o>=</span> <span class=n>threshold</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>newCap</span><span class=o>,</span> <span class=n>newThr</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>oldCap</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span> <span class=c1>//如果当前容量大于 0，也就是非第一次初始化的情况（扩容场景下）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>oldCap</span> <span class=o>&gt;=</span> <span class=n>MAXIMUM_CAPACITY</span><span class=o>)</span> <span class=o>{</span> <span class=c1>//不能超过最大允许容量
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>threshold</span> <span class=o>=</span> <span class=n>Integer</span><span class=o>.</span><span class=na>MAX_VALUE</span><span class=o>;</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>oldTab</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=o>((</span><span class=n>newCap</span> <span class=o>=</span> <span class=n>oldCap</span> <span class=o>&lt;&lt;</span> <span class=mi>1</span><span class=o>)</span> <span class=o>&lt;</span> <span class=n>MAXIMUM_CAPACITY</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>             <span class=n>oldCap</span> <span class=o>&gt;=</span> <span class=n>DEFAULT_INITIAL_CAPACITY</span><span class=o>)</span> <span class=c1>// 双倍扩容
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>newThr</span> <span class=o>=</span> <span class=n>oldThr</span> <span class=o>&lt;&lt;</span> <span class=mi>1</span><span class=o>;</span> <span class=c1>// double threshold
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>oldThr</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>)</span> <span class=c1>// 初始化的场景（给定默认容量），比如 new HashMap(32)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>newCap</span> <span class=o>=</span> <span class=n>oldThr</span><span class=o>;</span> <span class=c1>//将容量设置为 threshold 的值
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>else</span> <span class=o>{</span>               <span class=c1>// 无参数初始化场景，new HashMap()
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 容量设置为 DEFAULT_INITIAL_CAPACITY
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>newCap</span> <span class=o>=</span> <span class=n>DEFAULT_INITIAL_CAPACITY</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 阈值 超过阈值会触发扩容
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>newThr</span> <span class=o>=</span> <span class=o>(</span><span class=kt>int</span><span class=o>)(</span><span class=n>DEFAULT_LOAD_FACTOR</span> <span class=o>*</span> <span class=n>DEFAULT_INITIAL_CAPACITY</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>newThr</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span> <span class=c1>//给定默认容量的初始化情况
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>float</span> <span class=n>ft</span> <span class=o>=</span> <span class=o>(</span><span class=kt>float</span><span class=o>)</span><span class=n>newCap</span> <span class=o>*</span> <span class=n>loadFactor</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>newThr</span> <span class=o>=</span> <span class=o>(</span><span class=n>newCap</span> <span class=o>&lt;</span> <span class=n>MAXIMUM_CAPACITY</span> <span class=o>&amp;&amp;</span> <span class=n>ft</span> <span class=o>&lt;</span> <span class=o>(</span><span class=kt>float</span><span class=o>)</span><span class=n>MAXIMUM_CAPACITY</span> <span class=o>?</span>
</span></span><span class=line><span class=cl>              <span class=o>(</span><span class=kt>int</span><span class=o>)</span><span class=n>ft</span> <span class=o>:</span> <span class=n>Integer</span><span class=o>.</span><span class=na>MAX_VALUE</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 保存新的阈值
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>threshold</span> <span class=o>=</span> <span class=n>newThr</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 创建新的扩容后数组，然后将旧的元素复制过去
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nd>@SuppressWarnings</span><span class=o>({</span><span class=s>&#34;rawtypes&#34;</span><span class=o>,</span><span class=s>&#34;unchecked&#34;</span><span class=o>})</span>
</span></span><span class=line><span class=cl>  <span class=n>HashMap</span><span class=o>.</span><span class=na>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;[]</span> <span class=n>newTab</span> <span class=o>=</span> <span class=o>(</span><span class=n>HashMap</span><span class=o>.</span><span class=na>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;[])</span><span class=k>new</span> <span class=n>HashMap</span><span class=o>.</span><span class=na>Node</span><span class=o>[</span><span class=n>newCap</span><span class=o>];</span>
</span></span><span class=line><span class=cl>  <span class=n>table</span> <span class=o>=</span> <span class=n>newTab</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>oldTab</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>oldCap</span><span class=o>;</span> <span class=o>++</span><span class=n>j</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>HashMap</span><span class=o>.</span><span class=na>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>e</span><span class=o>;</span>
</span></span><span class=line><span class=cl>      <span class=c1>//遍历 获得得到元素 赋给 e
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>if</span> <span class=o>((</span><span class=n>e</span> <span class=o>=</span> <span class=n>oldTab</span><span class=o>[</span><span class=n>j</span><span class=o>])</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span> <span class=c1>//如果当前桶不为空
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>oldTab</span><span class=o>[</span><span class=n>j</span><span class=o>]</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span> <span class=c1>// 置空回收
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>e</span><span class=o>.</span><span class=na>next</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=c1>//节点 next为空的话 重新寻找落点 
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=n>newTab</span><span class=o>[</span><span class=n>e</span><span class=o>.</span><span class=na>hash</span> <span class=o>&amp;</span> <span class=o>(</span><span class=n>newCap</span> <span class=o>-</span> <span class=mi>1</span><span class=o>)]</span> <span class=o>=</span> <span class=n>e</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>e</span> <span class=k>instanceof</span> <span class=n>HashMap</span><span class=o>.</span><span class=na>TreeNode</span><span class=o>)</span> <span class=c1>//如果是树节点
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=c1>//红黑树节点单独处理
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=o>((</span><span class=n>HashMap</span><span class=o>.</span><span class=na>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;)</span><span class=n>e</span><span class=o>).</span><span class=na>split</span><span class=o>(</span><span class=k>this</span><span class=o>,</span> <span class=n>newTab</span><span class=o>,</span> <span class=n>j</span><span class=o>,</span> <span class=n>oldCap</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=o>{</span> <span class=c1>// 保持原顺序
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=n>HashMap</span><span class=o>.</span><span class=na>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>loHead</span> <span class=o>=</span> <span class=kc>null</span><span class=o>,</span> <span class=n>loTail</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>          <span class=n>HashMap</span><span class=o>.</span><span class=na>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>hiHead</span> <span class=o>=</span> <span class=kc>null</span><span class=o>,</span> <span class=n>hiTail</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>          <span class=n>HashMap</span><span class=o>.</span><span class=na>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>next</span><span class=o>;</span>
</span></span><span class=line><span class=cl>          <span class=k>do</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>next</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>((</span><span class=n>e</span><span class=o>.</span><span class=na>hash</span> <span class=o>&amp;</span> <span class=n>oldCap</span><span class=o>)</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>              <span class=k>if</span> <span class=o>(</span><span class=n>loTail</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=n>loHead</span> <span class=o>=</span> <span class=n>e</span><span class=o>;</span>
</span></span><span class=line><span class=cl>              <span class=k>else</span>
</span></span><span class=line><span class=cl>                <span class=n>loTail</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>e</span><span class=o>;</span>
</span></span><span class=line><span class=cl>              <span class=n>loTail</span> <span class=o>=</span> <span class=n>e</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>              <span class=k>if</span> <span class=o>(</span><span class=n>hiTail</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=n>hiHead</span> <span class=o>=</span> <span class=n>e</span><span class=o>;</span>
</span></span><span class=line><span class=cl>              <span class=k>else</span>
</span></span><span class=line><span class=cl>                <span class=n>hiTail</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>e</span><span class=o>;</span>
</span></span><span class=line><span class=cl>              <span class=n>hiTail</span> <span class=o>=</span> <span class=n>e</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>          <span class=o>}</span> <span class=k>while</span> <span class=o>((</span><span class=n>e</span> <span class=o>=</span> <span class=n>next</span><span class=o>)</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>);</span>
</span></span><span class=line><span class=cl>          <span class=k>if</span> <span class=o>(</span><span class=n>loTail</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>loTail</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=n>newTab</span><span class=o>[</span><span class=n>j</span><span class=o>]</span> <span class=o>=</span> <span class=n>loHead</span><span class=o>;</span>
</span></span><span class=line><span class=cl>          <span class=o>}</span>
</span></span><span class=line><span class=cl>          <span class=k>if</span> <span class=o>(</span><span class=n>hiTail</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>hiTail</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=n>newTab</span><span class=o>[</span><span class=n>j</span> <span class=o>+</span> <span class=n>oldCap</span><span class=o>]</span> <span class=o>=</span> <span class=n>hiHead</span><span class=o>;</span>
</span></span><span class=line><span class=cl>          <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>newTab</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p><strong>首次初始化</strong></p><p><code>put</code>方法中先检查 table 数组是否为空，如果为空就初始化。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=k>if</span> <span class=o>((</span><span class=n>tab</span> <span class=o>=</span> <span class=n>table</span><span class=o>)</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=o>(</span><span class=n>n</span> <span class=o>=</span> <span class=n>tab</span><span class=o>.</span><span class=na>length</span><span class=o>)</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=o>(</span><span class=n>tab</span> <span class=o>=</span> <span class=n>resize</span><span class=o>()).</span><span class=na>length</span><span class=o>;</span>
</span></span></code></pre></div><p>首次初始化分为无参初始化和有参初始化两种情况，前面在讲 <code>HashMap</code>初始化的时候说了，无参情况默认就是 16，也就是 table 的长度为 16。有参初始化的时候，首先使用 <code>tableSizeFor()</code>方法确定实际容量，最后 new 一个 Node 数组出来。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>HashMap</span><span class=o>.</span><span class=na>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;[]</span> <span class=n>newTab</span> <span class=o>=</span> <span class=o>(</span><span class=n>HashMap</span><span class=o>.</span><span class=na>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;[])</span><span class=k>new</span> <span class=n>HashMap</span><span class=o>.</span><span class=na>Node</span><span class=o>[</span><span class=n>newCap</span><span class=o>];</span>
</span></span></code></pre></div><p>其中 <code>newCap</code>就是容量，默认16或者自定义的。</p><p>而这个过程中还有很重要的一步，就是维护<code>扩容阈值</code>。</p><p><strong>扩容</strong></p><p><code>put</code>方法中，判断当 size（实际键值对个数）到达 <code>threshold</code> （阈值）时，触发扩容操作。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 当实际长度大于 threshold 时 resize
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=o>(++</span><span class=n>size</span> <span class=o>&gt;</span> <span class=n>threshold</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=n>resize</span><span class=o>();</span>
</span></span></code></pre></div><p><code>HashMap</code>遵循两倍扩容规则，每次扩容之后的大小是扩容前的两倍。另外，说到底，底层的存储还是一个数组，Java 中没有真正的动态数组这一说，数组初始化的时候是多大，那它就一直是这么大，那扩容是怎么来的呢，答案就是创建一个新数组，然后将老数组的数据拷贝过去。</p><p>拷贝的时候可能会有如下几种情况：</p><ol><li>如果节点 next 属性为空，说明这是一个最正常的节点，不是桶内链表，也不是红黑树，这样的节点会重新计算索引位置，然后插入。</li><li>如果是一颗红黑树，则使用 <code>split</code>方法处理，原理就是将红黑树拆分成两个 TreeNode 链表，然后判断每个链表的长度是否小于等于 6，如果是就将 TreeNode 转换成桶内链表，否则再转换成红黑树。</li><li>如果是桶内链表，则判断 (e.hash & oldCap) 的值，如果是0，就放到原索引位置，如果是1，就放到原索引+扩容前长度的索引位置(j + oldCap)，而链表的顺序仍然保持不变，这样的结果和「扰动函数」中 (n - 1) & hash 的计算结果是一样的。</li></ol><h3 id=确定插入点>确定插入点</h3><p>当我们调用 <code>put</code>方法时，第一步是对 key 进行 hash 计算，计算这个值是为了之后寻找落点，也就是究竟要插入到 table 数组的哪个桶中。</p><p>hash 算法是这样的，拿到 key 的 hashCode，将 hashCode 做一次16位右位移，然后将右移的结果和 hashCode 做异或运算，这段代码叫做「<strong>扰动函数</strong>」，之所以不直接拿 hashCode 是为了增加随机性，减少哈希碰撞次数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>* 用来计算 key 的 hash 值
</span></span></span><span class=line><span class=cl><span class=cm>**/</span>
</span></span><span class=line><span class=cl><span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=nf>hash</span><span class=o>(</span><span class=n>Object</span> <span class=n>key</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>h</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>(</span><span class=n>key</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>?</span> <span class=mi>0</span> <span class=o>:</span> <span class=o>(</span><span class=n>h</span> <span class=o>=</span> <span class=n>key</span><span class=o>.</span><span class=na>hashCode</span><span class=o>())</span> <span class=o>^</span> <span class=o>(</span><span class=n>h</span> <span class=o>&gt;&gt;&gt;</span> <span class=mi>16</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>拿到这个 hash 值之后，会进行这样的运算 <code>i = (n - 1) & hash</code>，其中 <code>i</code>就是最终计算出来的索引位置。</p><p>有两个场景用到了这个索引计算公式，第一个场景就是 <code>put</code>方法插入键值对的时候。第二个场景是在 resize 扩容的时候，new 出来新数组之后，将已经存在的节点移动到新数组的时候，如果节点不是链表，也不是红黑树，而是一个普通的 Node 节点，会重新计算，找到在新数组中的索引位置。</p><p>接着看图，还是图说的清楚。</p><p><code>HashMap</code> 要求容量必须是 2 的 n 次方，2的 n 次方的二进制表示大家肯定都很清楚，2的6次方，就是从右向左 6 个 0，然后第 7 位是 1，下图展示了 2 的 6 次方的二进制表示。</p><p><img src=https://hexo.moonkite.cn/blog/640-20230607151955196.jpeg alt></p><p>然后这个 <code>n-1</code>的操作就厉害了，减一之后，后面之前二进制表示中 1 后面的 0 全都变成了 1，1 所在的位变为 0。比如 64-1 变为 63，其二进制表示是下面这样的。</p><p><img src=https://hexo.moonkite.cn/blog/640-20230607152013884.jpeg alt></p><p>下图中，前面 4 行分别列出了当 map 的容量为 8、16、32、64的时候，假设容量为 n，则对应的 <code>n-1</code> 的二进制表示是下面这样的，尾部一片红，都是 1 ，能预感到将要有什么骚操作。</p><p>没错，将这样的二进制表示代入这个公式 <code>(n - 1) & hash</code>中，最终就能确定待插入的索引位了。接着看图最下面的三行，演示了假设当前 <code>HashMap</code>的容量为 64 ，而待插入的一个 key 经过 hash 计算后得到的结果是 99 时，代入公式计算 index 的值，也就是 <code>（64-1）& 99</code>，最终的计算结果是 35，也就是这个 key 会落到 table[35] 这个位置。</p><p>为什么 <code>HashMap</code>一定要保证容量是 2 的幂次方呢，通过二进制表示可以看出，如果有多位是 1 ，那与 hash 值进行<code>与运算</code>的时候，更能保证最后散列的结果均匀，这样很大程度上由 hash 的值来决定。</p><p><img src=https://hexo.moonkite.cn/blog/640-20230607152028529.jpeg alt></p><h3 id=如何确保-key-的唯一性>如何确保 key 的唯一性</h3><p><code>HashMap</code>中不允许存在相同的 key 的，那怎么保证 key 的唯一性呢，判断的代码如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=k>if</span> <span class=o>(</span><span class=n>p</span><span class=o>.</span><span class=na>hash</span> <span class=o>==</span> <span class=n>hash</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>        <span class=o>((</span><span class=n>k</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=na>key</span><span class=o>)</span> <span class=o>==</span> <span class=n>key</span> <span class=o>||</span> <span class=o>(</span><span class=n>key</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>key</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>k</span><span class=o>))))</span>
</span></span></code></pre></div><p>首先通过 hash 算法算出的值必须相等，算出的结果是 int，所以可以用 == 符号判断。只是这个条件可不行，要知道哈希碰撞是什么意思，有可能两个不一样的 key 最后产生的 hash 值是相同的。</p><p>并且待插入的 key == 当前索引已存在的 key，或者 待插入的 key.equals(当前索引已存在的key)，注意<code>==</code> 和 equals 是或的关系。== 符号意味着这是同一个对象， equals 用来确定两个对象内容相同。</p><p>如果 key 是基本数据类型，比如 int，那相同的值肯定是相等的，并且产生的 hashCode 也是一致的。</p><p><code>String</code> 类型算是最常用的 key 类型了，我们都知道相同的字符串产生的 hashCode 也是一样的，并且字符串可以用 equals 判断相等。</p><p>但是如果用引用类型当做 key 呢，比如我定义了一个 <code>MoonKey</code> 作为 key 值类型</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>MoonKey</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>String</span> <span class=n>keyTile</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>String</span> <span class=nf>getKeyTile</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>keyTile</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>setKeyTile</span><span class=o>(</span><span class=n>String</span> <span class=n>keyTile</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>keyTile</span> <span class=o>=</span> <span class=n>keyTile</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>equals</span><span class=o>(</span><span class=n>Object</span> <span class=n>o</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=k>this</span> <span class=o>==</span> <span class=n>o</span><span class=o>)</span> <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>o</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>getClass</span><span class=o>()</span> <span class=o>!=</span> <span class=n>o</span><span class=o>.</span><span class=na>getClass</span><span class=o>())</span> <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>MoonKey</span> <span class=n>moonKey</span> <span class=o>=</span> <span class=o>(</span><span class=n>MoonKey</span><span class=o>)</span> <span class=n>o</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>Objects</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>keyTile</span><span class=o>,</span> <span class=n>moonKey</span><span class=o>.</span><span class=na>keyTile</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>然后用下面的代码进行两次添加，你说 size 的长度是 1 还是 2 呢？</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Map</span><span class=o>&lt;</span><span class=n>MoonKey</span><span class=o>,</span> <span class=n>String</span><span class=o>&gt;</span> <span class=n>m</span> <span class=o>=</span> <span class=k>new</span> <span class=n>HashMap</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl><span class=n>MoonKey</span> <span class=n>moonKey</span> <span class=o>=</span> <span class=k>new</span> <span class=n>MoonKey</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=n>moonKey</span><span class=o>.</span><span class=na>setKeyTile</span><span class=o>(</span><span class=s>&#34;1&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>MoonKey</span> <span class=n>moonKey1</span> <span class=o>=</span> <span class=k>new</span> <span class=n>MoonKey</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=n>moonKey1</span><span class=o>.</span><span class=na>setKeyTile</span><span class=o>(</span><span class=s>&#34;1&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>m</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=n>moonKey</span><span class=o>,</span> <span class=s>&#34;1&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>m</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=n>moonKey1</span><span class=o>,</span> <span class=s>&#34;2&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>hash</span><span class=o>(</span><span class=n>moonKey</span><span class=o>));</span>
</span></span><span class=line><span class=cl><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>hash</span><span class=o>(</span><span class=n>moonKey1</span><span class=o>));</span>
</span></span><span class=line><span class=cl><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>m</span><span class=o>.</span><span class=na>size</span><span class=o>());</span>
</span></span></code></pre></div><p>答案是 2 ，为什么呢，因为 <code>MoonKey</code> 没有重写 <code>hashCode</code> 方法，导致 moonkey 和 moonKey1 的 hash 值不可能一样，当不重写 <code>hashCode</code> 方法时，默认继承自 <code>Object</code>的 hashCode 方法，而每个 <code>Object</code>对象的 hash 值都是独一无二的。</p><p><strong>划重点</strong>，正确的做法应该是加上 <code>hashCode</code>的重写。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>int</span> <span class=nf>hashCode</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>Objects</span><span class=o>.</span><span class=na>hash</span><span class=o>(</span><span class=n>keyTile</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>这也是为什么要求重写 <code>equals</code> 方法的同时，也必须重写 <code>hashCode</code>方法的原因之一。 如果两个对象通过调用equals方法是相等的，那么这两个对象调用hashCode方法必须返回相同的整数。有了这个基础才能保证 <code>HashMap</code>或者<code>HashSet</code>的 key 唯一。</p><h3 id=发生哈希碰撞怎么办>发生哈希碰撞怎么办</h3><p>前面刚说了相等的对象产生的 hashCode 也要相等，但是不相等的对象使用 <code>hash</code>方法计算之后也有可能产生相同的值，这就叫做哈希碰撞。虽然通过算法已经很大程度上避免碰撞的发生，但是却无法避免。</p><p>产生碰撞之后，自然得出的在 table 数组的索引（也就是桶）也是一样的，这时，怎么办呢，一个桶里怎么放多个键值对？</p><p><strong>拉链法</strong></p><p>文章刚开头就提到了，<code>HashMap</code>可不是简单的数组而已。当碰撞发生就坦然接收。有一种方法叫做拉链法，不是衣服上那种拉链。而是，当碰撞发生了，就在当前桶上拉一条链表出来，这样解释就合理了。</p><p>前面介绍关键概念的时候提到了 <code>Node</code>类型，里面有个属性叫做 <code>next</code>，它就是为了这种链表设计的，如下图所示。node1、node2、node3都落在了同一个桶中，这时候就得用链表的方式处理了，node1.next = node2，node2.next = node3，这样将链表串起来。而 node3.next = null，则说明这是链表的尾巴。</p><p>当有新元素准备插入到链表的时候，采用的是尾插法，而不是头插法了，JDK 1.7 的版本采用的是头插法，但是头插法有个问题，就是在两个线程执行 resize() 扩容的时候，很可能造成环形链表，导致 get 方法出现死循环。</p><p><img src=https://hexo.moonkite.cn/blog/640-20230607152049455.jpeg alt=图片></p><p><strong>链表转换成树</strong></p><p>链表不是碰撞处理的终极结构，终极结构是红黑树，当链表长度到达 8 之后，再有新元素进来，那就要开始由链表到红黑树的转换了。方法 <code>treeifyBin</code>是完成这个过程的。</p><p>使用红黑树是出于性能方面的考虑，红黑树的查找速度要优于链表。那为什么不是一开始就直接生成红黑树，而是链表长度大于 8 之后才升级成树呢？</p><p>首先来说，哈希碰撞的概率还是很小的，大部分情况下都是一个桶装一个 <code>Node</code>，即便发生碰撞，都碰撞到一个桶的概率那就更是少之又少了，所以链表长度很少有机会能到 8 ，如果链表长度到 8 了，那说明当前 <code>HashMap</code>中的元素数量已经非常大了，那这时候用红黑树来提高性能是可取的。而反过来，如果 <code>HashMap</code>总的元素很少，即便用红黑树对性能的提升也不大，况且红黑树对空间的使用要比链表大很多。</p><h2 id=get-方法>get 方法</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>T</span> <span class=n>value</span> <span class=o>=</span> <span class=n>map</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>key</span><span class=o>);</span>
</span></span></code></pre></div><p>例如通过上面的语句通过 key 获取 value 值，是我们最常用到的方法了。</p><p><img src=https://hexo.moonkite.cn/blog/640-20230607152049455-20230607152100936.jpeg alt></p><p>看图理解，当调用 <code>get</code>方法后，第一步还是要确定索引位置，也就是我们所说的桶的位置，方法和 <code>put</code>方法时一样，都是先使用 <code>hash</code>这个<strong>扰动函数</strong>确定 hash 值，然后用 <code>(n-1) & hash</code>获取索引。这不废话吗，当然得和 <code>put</code>的时候一样了，不一样还怎么找到正确的位置。</p><p>确定桶的位置后，会出现三种情况：</p><p>**单节点类型：**也就是这个桶内只有一个键值对，这也在 <code>HashMap</code>中存在最多的类型，只要不发生哈希碰撞都是这种类型。其实 <code>HashMap</code>最理想的情况就是这样，全都是这种类型就完美了。</p><p>**链表类型：**如果发现 get 的 key 所在的是一个链表结构，就需要遍历链表，知道找到 key 相等的 Node。</p><p>**红黑树类型：**当链表长度超过 8 就转变成红黑树，如果发现找到的桶是一颗红黑树，就使用红黑树专有的快速查找法查找。</p><p>另外，<code>Map.containsKey</code>方法其实用的就是 <code>get</code>方法。</p><h2 id=remove-方法>remove 方法</h2><p><code>remove</code>与<code>put</code>、<code>get</code>方法类似，都是先求出 key 的 hash 值，然后 <code>(n-1) & hash</code>获取索引位置，之后根据节点的类型采取不同的措施。</p><p>**单节点类型：**直接将当前桶元素替换为被删除 node.next ，其实就是 null。</p><p><strong>链表类型：</strong> 如果是链表类型，就将被删除 node 的前一个节点的 next 属性设置为 node.next。</p><p>**红黑树类型：**如果是一棵红黑树，就调用红黑树节点删除法，这里，如果节点数在 2~6之间，就将树结构简化为链表结构。</p><h2 id=非线程安全>非线程安全</h2><p><code>HashMap</code>没有做并发控制，如果想在多线程高并发环境下使用，请用 <code>ConcurrentHashMap</code>。同一时刻如果有多个线程同时执行 put 操作，如果计算出来的索引（桶）位置是相同的，那会造成前一个 key 被后一个 key 覆盖。</p><p>比如下图线程 A 和 线程 B 同时执行 put 操作，很巧的是计算出的索引都是 2，而此时，线程A 和 线程B都判断出索引为 2 的桶是空的，然后就是插入值了，线程A先 put 进去了 key1 = 1的键值对，但是，紧接着线程B 又 put 进去了 key2 = 2，线程A 表示痛哭流涕，白忙活一场。最后索引为2的桶内的值是 key2=2，也就是线程A的存进去的值被覆盖了。</p><p><img src=https://hexo.moonkite.cn/blog/640-20230607152049455-20230607152100936-20230607152114731.jpeg alt></p><h2 id=总结>总结</h2><p>前面没说，<code>HashMap</code>搞的这么复杂不是白搞的，它的最大优点就是快，尤其是 <code>get</code>数据，是 O(1)级别的，直接定位索引位置。</p><p><code>HashMap</code>不是单纯的数组结构，当发生哈希碰撞时，会采用拉链法生成链表，当链表大于 8 的时候会转换成红黑树，红黑树可以很大程度上提高性能。</p><p><code>HashMap</code>容量必须是 2 的 n 次方，这样设计是为了保证寻找索引的散列计算更加均匀，计算索引的公式为 <code>(n - 1) & hash</code>。</p><p><code>HashMap</code>在键值对数量达到扩容阈值「<code>容量 x 负载因子</code>」的时候进行扩容，每次扩容为之前的两倍。扩容的过程中会对单节点类型元素进行重新计算索引位置，如果是红黑树节点则使用 <code>split</code>方法重新考量，是否将红黑树变为链表。</p></article><div class=toc><h2>文章目录</h2><nav id=TableOfContents><ul><li><a href=#先从结构说起>先从结构说起</a></li><li><a href=#认清几个关键概念>认清几个关键概念</a><ul><li><a href=#存储容器>存储容器</a></li><li><a href=#node-类型>Node 类型</a></li><li><a href=#treenode>TreeNode</a></li><li><a href=#容量和默认容量>容量和默认容量</a></li><li><a href=#元素个数>元素个数</a></li><li><a href=#最大容量>最大容量</a></li><li><a href=#负载因子>负载因子</a></li><li><a href=#扩容阈值>扩容阈值</a></li></ul></li><li><a href=#初始化-hashmap>初始化 HashMap</a></li><li><a href=#从-put-方法解密核心原理>从 put 方法解密核心原理</a><ul><li><a href=#首次初始化数组和扩容>首次初始化数组和扩容</a></li><li><a href=#确定插入点>确定插入点</a></li><li><a href=#如何确保-key-的唯一性>如何确保 key 的唯一性</a></li><li><a href=#发生哈希碰撞怎么办>发生哈希碰撞怎么办</a></li></ul></li><li><a href=#get-方法>get 方法</a></li><li><a href=#remove-方法>remove 方法</a></li><li><a href=#非线程安全>非线程安全</a></li><li><a href=#总结>总结</a></li></ul></nav></div><script>window.addEventListener("scroll",function(){var e=document.querySelector(".toc"),t=window.pageYOffset||document.documentElement.scrollTop,n=window.innerWidth||document.documentElement.clientWidth;t<360?e.style.top=380-t+"px":e.style.top="20px"})</script><h4>相关文章</h4><dl class=row><dd class=col-md-9><a href=/category/java/HashMap%E6%BC%AB%E7%94%BB%E7%89%88/>有趣的条漫版 HashMap，25岁大爷都能看懂</a></dd><dd class=col-md-9><a href=/category/java/RPC-%E6%A6%82%E8%A7%88/>RPC框架的核心是什么？</a></dd><dd class=col-md-9><a href=/category/SpringCloud/0-Srping-Cloud-%E5%BC%80%E7%AF%87/>0. Spring Cloud 是什么</a></dd><dd class=col-md-9><a href=/category/SpringCloud/1-Spring-Cloud-Eureka-%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/>1. Spring Cloud Eureka 实现服务注册与发现</a></dd><dd class=col-md-9><a href=/category/SpringCloud/2-Spring-Cloud-Eureka-%E5%AE%9E%E7%8E%B0%E5%AE%89%E5%85%A8%E6%8E%A7%E5%88%B6/>2. Spring Cloud Eureka 实现安全控制</a></dd></dl><div class=author-card><div class=underline></div><div class=author-box><div class=qr-author-image><a href=/><img src=/images/person.jpg alt=风筝></a></div><div class=author-content><p class=author-title>作者</p><p class=author-name>风筝</p><p class=author-desc>古时的风筝，一个平庸的程序员，主语言 Java，第二语言 Python，其实学 Python 的时间比 Java 还要早。喜欢写博客，写博客的过程能加深自己对一个知识点的理解，同时还可以分享给他人。喜欢做一些小东西，所以也会一些前端的东西，React、JavaScript、CSS 都会一些，做一些小工具还够用。</p></div></div></div><script src=https://utteranc.es/client.js repo=huzhicheng/blog-comment issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></main><div class="footer gradient-2"><div class="container footer-container"><div class=row><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>网站地图</div><ul class=list-unstyled><li><a href=https://www.moonkite.cn/tags/>标签</a></li><li><a href=https://www.moonkite.cn/categories/>分类</a></li><li><a rel=alternate type=application/rss+xml href=https://www.moonkite.cn/index.xml><i class="fas fa-rss-square"></i> RSS订阅</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>社群</div><ul class=list-unstyled><li><a href=https://github.com/huzhicheng rel=noopener target=_blank>GitHub</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>友链</div><ul class=list-unstyled><li><a href=https://github.com/huzhicheng rel=noopener target=_blank>关于我</a></li></ul></div><div class="col-xs-12 col-sm-3 col-md-3 col-lg-3"><p class="pull-right text-right"><small><em>Proudly powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo</a></em></small><br><small><em>Theme - <a href=https://github.com/shaform/hugo-theme-den rel=noopener target=_blank>Den</a></em></small><br><small>&copy;
风筝
2023</small></p></div></div><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?e417ddf834c7bb7411207e1fa09815aa",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-C714TFXRD4"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-C714TFXRD4")</script></div></div><script src=https://cdn.staticfile.org/jquery/3.3.1/jquery.slim.min.js integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script>
<script src=https://cdn.staticfile.org/popper.js/1.14.3/umd/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=https://cdn.staticfile.org/twitter-bootstrap/4.1.3/js/bootstrap.js></script>
<script>$(document).ready(function(){$("#load_disqus").length&&$(window).scroll(function(){if($("#load_disqus").length){var e=$("#load_disqus").offset().top,t=$(window).scrollTop(),n=t+$(window).height();t<e&&e<n&&load_disqus()}})})</script></body></html>