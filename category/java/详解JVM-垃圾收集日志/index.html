<!doctype html><html lang=zh-cn itemscope itemtype=http://schema.org/WebPage><head><meta name=generator content="Hugo 0.115.2"><meta charset=utf-8><title>详解JVM 垃圾收集日志 · 古时的风筝</title><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=description content="下图是本篇的写作大纲，将从以下四个方面介绍怎么样处理 JVM 日志。 有准备才能不慌 想要分析日志，首先你得有日志呀，对不对。凡是未雨绸蒙总是没错的。所"><meta name=keywords content="Hugo,theme,编程,java,ChatGPT,程序员,开发"><link rel=canonical href=https://www.moonkite.cn/category/java/%E8%AF%A6%E8%A7%A3JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%97%A5%E5%BF%97/><link rel=icon href=https://www.moonkite.cn/images/photo.png><link rel=stylesheet href=https://cdn.usebootstrap.com/bootstrap/4.1.3/css/bootstrap.min.css><link rel=stylesheet href=https://www.moonkite.cn/css/den.css><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-tc-webfont@1.0.0/style.css><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><meta name=referrer content="no-referrer-when-downgrade"><meta property="og:title" content="详解JVM 垃圾收集日志"><meta property="og:description" content="下图是本篇的写作大纲，将从以下四个方面介绍怎么样处理 JVM 日志。 有准备才能不慌 想要分析日志，首先你得有日志呀，对不对。凡是未雨绸蒙总是没错的。所"><meta property="og:type" content="article"><meta property="og:url" content="https://www.moonkite.cn/category/java/%E8%AF%A6%E8%A7%A3JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%97%A5%E5%BF%97/"><meta property="article:section" content="category"><meta property="article:published_time" content="2019-12-13T08:56:23+08:00"><meta property="article:modified_time" content="2019-12-13T08:56:23+08:00"><meta itemprop=name content="详解JVM 垃圾收集日志"><meta itemprop=description content="下图是本篇的写作大纲，将从以下四个方面介绍怎么样处理 JVM 日志。 有准备才能不慌 想要分析日志，首先你得有日志呀，对不对。凡是未雨绸蒙总是没错的。所"><meta itemprop=datePublished content="2019-12-13T08:56:23+08:00"><meta itemprop=dateModified content="2019-12-13T08:56:23+08:00"><meta itemprop=wordCount content="6251"><meta itemprop=keywords content="Java,JDK,JVM,jvm垃圾收集日志,"><meta name=twitter:card content="summary"><meta name=twitter:title content="详解JVM 垃圾收集日志"><meta name=twitter:description content="下图是本篇的写作大纲，将从以下四个方面介绍怎么样处理 JVM 日志。 有准备才能不慌 想要分析日志，首先你得有日志呀，对不对。凡是未雨绸蒙总是没错的。所"></head><body><div class=header-container style=background:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2)),url(https://www.moonkite.cn/images/background.png);background-position:top;background-size:cover><div class=container><nav class="header-nav navbar navbar-expand-md navbar-dark light-dark"><div class="header-logo navbar-brand"><a class=float-left href=https://www.moonkite.cn/></a></div><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarNav aria-controls=navbarNav aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="nav-menu collapse navbar-collapse" id=navbarNav><ul class=navbar-nav><li class=nav-item><a href=https://www.moonkite.cn/ class=nav-link><i class="fas fad fa-h-square"></i>主页</a></li><li class=nav-item><a href=https://www.moonkite.cn/category/notes class=nav-link><i class='fas fa-yin-yang'></i>生活随笔</a></li><li class=nav-item><a href=javascript:void(0) class=nav-link><i class='fas fa-laptop-code'></i>技术文章</a><div class=sub-dropdown-menu><a class=sub-nav-link href=https://www.moonkite.cn/category/java><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 48 48"><path fill="#f44336" d="M23.65 24.898c-.998-1.609-1.722-2.943-2.725-5.455C19.229 15.2 31.24 11.366 26.37 3.999c2.111 5.089-7.577 8.235-8.477 12.473-.823 3.898 5.752 8.426 5.757 8.426z"/><path fill="#f44336" d="M23.878 17.27c-.192 2.516 2.229 3.857 2.299 5.695.056 1.496-1.447 2.743-1.447 2.743s2.728-.536 3.579-2.818c.945-2.534-1.834-4.269-1.548-6.298.267-1.938 6.031-5.543 6.031-5.543S24.311 11.611 23.878 17.27z"/><g><path fill="#1565c0" d="M32.084 25.055c1.754-.394 3.233.723 3.233 2.01.0 2.901-4.021 5.643-4.021 5.643s6.225-.742 6.225-5.505c0-3.15-3.057-3.937-5.437-2.148zm-2.955 2.34s1.941-1.383 2.458-1.902c-4.763 1.011-15.638 1.147-15.638.269.0-.809 3.507-1.638 3.507-1.638s-7.773-.112-7.773 2.181C11.683 28.695 21.858 28.866 29.129 27.395z"/><path fill="#1565c0" d="M27.935 29.571c-4.509 1.499-12.814 1.02-10.354-.993-1.198.0-2.974.963-2.974 1.889.0 1.857 8.982 3.291 15.63.572l-2.302-1.468z"/><path fill="#1565c0" d="M18.686 32.739c-1.636.0-2.695 1.054-2.695 1.822.0 2.391 9.76 2.632 13.627.205l-2.458-1.632C24.271 34.404 17.014 34.579 18.686 32.739z"/><path fill="#1565c0" d="M36.281 36.632c0-.936-1.055-1.377-1.433-1.588 2.228 5.373-22.317 4.956-22.317 1.784.0-.721 1.807-1.427 3.477-1.093l-1.42-.839C11.26 34.374 9 35.837 9 37.017 9 42.52 36.281 42.255 36.281 36.632z"/><path fill="#1565c0" d="M39 38.604c-4.146 4.095-14.659 5.587-25.231 3.057C24.341 46.164 38.95 43.628 39 38.604z"/></g></svg>&nbsp;可爱的 Java</a>
<a class=sub-nav-link href=https://www.moonkite.cn/category/SpringCloud><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 48 48"><path fill="#8bc34a" d="M43.982 23.635c.069-4.261-.891-9.328-2.891-15.273L39.523 3.7l-2.13 4.433c-.114.237-.244.469-.38.698C33.514 5.827 28.974 4 24 4 12.954 4 4 12.954 4 24s8.954 20 20 20 20-8.954 20-20C44 23.877 43.984 23.758 43.982 23.635z"/><path fill="#fff" d="M39.385 32.558C36.262 36.86 30.734 37.091 25.531 37H18.75h-1.938c4.428-1.593 7.063-1.972 9.754-3.4 5.068-2.665 10.078-8.496 11.121-14.562-1.93 5.836-7.779 10.85-13.109 12.889-3.652 1.393-10.248 2.745-10.248 2.745l-.267-.145C9.573 32.268 9.437 22.214 17.6 18.968c3.574-1.423 6.993-.641 10.854-1.593 4.122-1.012 8.89-4.208 10.83-8.375C41.456 15.667 44.07 26.106 39.385 32.558zM15.668 38.445C15.386 38.795 14.955 39 14.505 39c-.823.0-1.495-.677-1.495-1.5s.677-1.5 1.495-1.5c.341.0.677.118.941.336C16.086 36.855 16.186 37.805 15.668 38.445z"/></svg>&nbsp; Spring Cloud 系列</a>
<a class=sub-nav-link href=https://www.moonkite.cn/category/other><img width=20 height=20 src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAADWElEQVR4nO2X30tTYRjH9xd4X2Dsol1EEtJdEFiSF10pldlVaVHEjiFFkKQVQeV0kfSTHdfW1pzKlpZtzXJuzp2pmzPFTdmUTdLJlEAvNKyB8MYzPG/visHZ2jxrnQc+8PCc85zz/e592XkfkUgIIYT4v2OoTVrtVFDTjILaYmgK8YqC2oproalzKZlwKqga3sXTSeFuZts9ykWcNOXnbITcTj67IRQcG1rlE5/dECK3GXcjxC8ADwqMuxGfBMeGVklNaRmZ83z0L3+ZR3ywMBfInJHQqGl07esKAmYjK6hnJoph64Ar/KsOOXmNK6HOTszKtD9uJitGQGSRcQFDiqh1RHAd8nSMWMQSDJgRjLAhrIgxta3lDvaiRlMpxvKvbi3BCNfI+xVRehdRIT2DIUWdejeH65BzMWKd1KO6jqOYLrEE46fp7Bm5bgki0Q0bhhS1t3UM1yHnYuS1XY5Oy0swD8USjPNmQ2aNfO6WO0KjphHgbrc9XNjsirGwdeAY7Vpl65CT15LRYb4VltLHYyzKAwcxgw3Xwr5BQ9D9ll53dz9d+msjfNLfWoO6GstR7/0zCXXBCJMPKxLMl3kkmC9GQsTf706znK3vyKLdhtznL2ISPm5TaqQdro8DeTJxm4EHKDZRGQfy308HtdvAcJY1I3BsII8RpAgwwB41IE9mBAwgR0EcyMlrRcTxB45DgpFUV+RbSIMxuq4kXRFyFl+3VuTeiqBtQYCDqUxqhOyJPCsTjDDCitB5urW8zS2oTSzBxNS7MB3tpeiC4kicO8azCQLJnkB9Me750Xs44b4CmQcjc4SzZwSGHXL42Xy0B6NTHMIDUp36RIJAsmeS2od7vuuKE+4TEUMbDHGZMLLBNrlUV/3u9sYRwH7vkq/nZFmUJaotwfRoK5bk6qoooNRUh9kegOyZkpUtsT3zuvKE+6qev4myKF899nkNTeMTJuWsu6spTBjZ4GzESUv7+R6qmCQ4aeoTZyPDLy4XMTS1xrdo5k/WmDbpflEq4XpJ7XbS1O0+bYvnve7JLNCnkXkZWmrYCfo0Mi9+r7bFA1pAkyjd0Ov1EZVKhQDI034Q3++1mM39H8xmBECeEZV8vNdmtRptAwMojtVqzIjKHH6vEEIIIcrt+AnU4LBcH67z1wAAAABJRU5ErkJggg=="> &nbsp; 杂七杂八</a></div></li><li class=nav-item><a href=https://www.moonkite.cn/category/network class=nav-link><i class="fas fa-network-wired"></i>轻解计算机网络</a></li><li class=nav-item><a href=https://www.moonkite.cn/category/product class=nav-link><i class="fas fab fa-medapps"></i>我的产品</a></li></ul></div></nav></div><div class="container header-wrapper"><div class=row><div class=col-lg-12><div class=header-content><h1 class=header-title>详解JVM 垃圾收集日志</h1><p class=header-date>作者：
风筝 /
2019-12-13<div class=header-underline></div><div class=header-date>&nbsp·&nbsp
  <span id=busuanzi_container_page_pv>本文被阅读<span id=busuanzi_value_page_pv></span>次</span></div><div class=clearfix></div><p class="float-right header-tags"><i class="fas fa-tags" aria-hidden=true></i>
<a href=https://www.moonkite.cn/tag/Java/>Java</a>,
<a href=https://www.moonkite.cn/tag/JDK/>JDK</a>,
<a href=https://www.moonkite.cn/tag/JVM/>JVM</a>,
<a href=https://www.moonkite.cn/tag/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%97%A5%E5%BF%97/>jvm垃圾收集日志</a></p></div></div></div></div></div><main><div class="container content"><article><p>下图是本篇的写作大纲，将从以下四个方面介绍怎么样处理 JVM 日志。
<img src=https://hexo.moonkite.cn/blog/273364-20191212212145883-688816701.png alt></p><h2 id=有准备才能不慌>有准备才能不慌</h2><p>想要分析日志，首先你得有日志呀，对不对。凡是未雨绸蒙总是没错的。所谓有日志的意思，你要把 JVM 参数配置好，日志格式、日志存储位置等参数，当然了，除了日志相关参数外，其他的一些必要参数最好也配置上，比如 HeapDump 。</p><p>我相信大部分成熟的项目都会配置 JVM 参数。但是还是有一些小项目真的会忽略。以至于 JVM 崩溃的时候不方便查找问题原因而追悔莫及。比如下面这位同学（纯属虚构），虽然对话是虚构，但是是真的有不配置参数的。
<img src=https://hexo.moonkite.cn/blog/273364-20191212212205326-1571529648.png alt></p><p><strong>要配置，有防备，不后悔；不配置，不准备，会追悔。</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-properties data-lang=properties><span class=line><span class=cl><span class=na>-XX</span><span class=o>:</span><span class=s>+PrintGCDetails</span>
</span></span><span class=line><span class=cl><span class=na>-XX</span><span class=o>:</span><span class=s>+PrintGCDateStamps</span>
</span></span><span class=line><span class=cl><span class=na>-Xloggc</span><span class=o>:</span><span class=s>/Users/fengzheng/jvmlog/gc.log</span>
</span></span><span class=line><span class=cl><span class=na>-XX</span><span class=o>:</span><span class=s>+HeapDumpOnOutOfMemoryError</span>
</span></span><span class=line><span class=cl><span class=na>-XX</span><span class=o>:</span><span class=s>HeapDumpPath=/Users/fengzheng/jvmlog</span>
</span></span></code></pre></div><p>以上可以说是配置 JVM 日志以及 dump 现场最基本的配置了。这里只介绍关于日志的参数，其他的参数可以读一下 <a href=https://mp.weixin.qq.com/s/thnH0qXK67jVmxkAaHmaIg>JVM 你不可不知的参数</a></p><p>加了以上配置的 JVM 就像是一台装有<strong>黑匣子</strong>的飞机。</p><h2 id=一个重要概念>一个重要概念</h2><p>并发(Concurrent)和并行(Parallel)在 JVM 垃圾收集过程中的定义有很多同学搞不清楚。所以没次读到这两个概念的时候都一头雾水。
<strong>并发(Concurrent)</strong>：指垃圾收集线程和用户线程可以同时进行。也就是说 JVM 在进行垃圾收集的时候，用户还是可以正常的使用应用系统提供的服务。(当然了，并没有一种完全并发的垃圾收集器，只是说在垃圾收集的大部分阶段是并发的)
<strong>并行(Parallel)</strong>：指垃圾收集器是多线程工作的，比方说有4个线程同时进行垃圾收集的工作，但是在收集的过程中，用户线程是被挂起的。也就是在进行并行收集的时候，用户无法正常使用应用系统提供的服务。</p><h2 id=分析背景>分析背景</h2><p>本篇的全部内容都基于 JDK 8 Hotspot JVM，分别从 ParallelGC 、CMS、G1 三种常用的垃圾收集器来分析。可以通过下图查看三种垃圾收集器的对应关系，分别对应图中标示的 1、2、3。
<img src=https://hexo.moonkite.cn/blog/273364-20191212212258754-1726998539.png alt></p><p>为了方便日志分析，我设置了一下简单的 JVM 作为基础参数，其中年轻代 10M，老年代 10M，堆大小 20M。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-properties data-lang=properties><span class=line><span class=cl><span class=err>-Xms20M</span>
</span></span><span class=line><span class=cl><span class=err>-Xmx20M</span>
</span></span><span class=line><span class=cl><span class=err>-Xmn10M</span>
</span></span><span class=line><span class=cl><span class=na>-XX</span><span class=o>:</span><span class=s>SurvivorRatio=8</span>
</span></span><span class=line><span class=cl><span class=na>-XX</span><span class=o>:</span><span class=s>MetaspaceSize=6M</span>
</span></span><span class=line><span class=cl><span class=na>-XX</span><span class=o>:</span><span class=s>MaxMetaspaceSize=6M</span>
</span></span><span class=line><span class=cl><span class=na>-XX</span><span class=o>:</span><span class=s>+HeapDumpOnOutOfMemoryError</span>
</span></span><span class=line><span class=cl><span class=na>-XX</span><span class=o>:</span><span class=s>HeapDumpPath=/Users/fengzheng/jvmlog</span>
</span></span></code></pre></div><h2 id=简单日志格式>简单日志格式</h2><p>通过参数 <code>-verbose:gc 或者 -XX:+PrintGC</code> 可以让 JVM 开启简单日志格式，对于这几种垃圾收集期，简单日志的格式都是一致的。简单日志内容很少，只有GC类型(标示是 Minor GC 还是 Full GC)、GC 原因、堆收集前和收集后大小、堆的总大小以及收集耗时。</p><p>下面是简单日志配置下的几条收集日志，包括正常的空间分配失败引起的收集、System.gc() 触发的垃圾收集、以及执行 jmap -histo:live pid 命令执行的垃圾收集。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># Minor GC 新生代 GC</span>
</span></span><span class=line><span class=cl><span class=o>[</span>GC <span class=o>(</span>Allocation Failure<span class=o>)</span>  7164K-&gt;704K<span class=o>(</span>19456K<span class=o>)</span>, 0.0017002 secs<span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># System.gc() 触发 Full GC</span>
</span></span><span class=line><span class=cl><span class=o>[</span>GC <span class=o>(</span>System.gc<span class=o>())</span>  4157K-&gt;648K<span class=o>(</span>19456K<span class=o>)</span>, 0.0019522 secs<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=o>[</span>Full GC <span class=o>(</span>System.gc<span class=o>())</span>  648K-&gt;609K<span class=o>(</span>19456K<span class=o>)</span>, 0.0099904 secs<span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># jmap -histo:live 触发 Full GC</span>
</span></span><span class=line><span class=cl><span class=o>[</span>GC <span class=o>(</span>Heap Inspection Initiated GC<span class=o>)</span>  938K-&gt;737K<span class=o>(</span>19456K<span class=o>)</span>, 0.0009119 secs<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=o>[</span>Full GC <span class=o>(</span>Heap Inspection Initiated GC<span class=o>)</span>  737K-&gt;573K<span class=o>(</span>19456K<span class=o>)</span>, 0.0070892 secs<span class=o>]</span>
</span></span></code></pre></div><p>下图说明了一条简单格式的垃圾收集日志各个字段的含义。
<img src=https://hexo.moonkite.cn/blog/273364-20191212212320587-605912087.png alt></p><p>在实际的生产环境中，只用简单格式的 JVM 日志意义不大，得到的有用信息不多，也就是知道垃圾收集次数、收集耗时以及堆的使用量，对于排查分析问题的帮助不是很大，所以，一般都会配置更加详细的日志格式。</p><h2 id=详细日志格式>详细日志格式</h2><p>使用 <code>-XX:+PrintGCDetails</code>和<code>-XX:+PrintGCDateStamps</code> 这两个参数可以打印详细的垃圾收集日志和垃圾收集的时间戳。当然了，除了这两个之外，还有一些更具体的参数，比如收集前后打印堆使用信息的 <code>-XX:+PrintHeapAtGC</code>参数等等。</p><p>当然了，参数配置的越多，打印的信息越是详细，对于排查问题越有帮助，就是内容就会变得很多，肉眼看起来会比较抓狂。</p><h3 id=parallel-scavenge-收集器>Parallel Scavenge 收集器</h3><p>在 JDK 8 中，如果不指定垃圾收集器，默认是使用参数 <code>-XX:+UseParallelGC</code> 的，也就是新生代使用 Parallel Scavenge，老年代配合使用的是 <strong>Serial Old</strong>。</p><p><strong>Parallel Scavenge</strong>是一款并行的、高吞吐量的垃圾收集器，采用复制算法。适用于追求高效率的、对即时响应要求不高的系统。</p><p>要了解清楚 GC 日志各部分的含义，就要了解 JVM 内存模型以及垃圾收集器对于内存的规划和管理情况，老样子，还是通过图来看一下比较清楚。JDK 8 支持的除 G1 外的垃圾收集器，都适用此图，包括下面要介绍的 CMS。
<img src=https://hexo.moonkite.cn/blog/273364-20191212212340209-2108070951.png alt></p><p>垃圾收集的部分即是上图中的「<strong>方法区</strong>」和 「<strong>堆</strong>」两部分。收集日志也基本上是描述这两部分的大小和变化情况。</p><p>在上面的背景介绍中给出了本次测试所用的参数。年轻代 10M ，老年代 10M，Metaspace 区 6M。下图是堆空间内存分布图，年轻代分为 Eden区和 S0、S1 两个区，<em>SurvivorRatio</em>为8，这也是默认值，表示新生代 Eden 占年轻代总大小的 80%，也就是 10*80%=8M，而 S0、S1 各占10%，也就是 1M。
<img src=https://hexo.moonkite.cn/blog/273364-20191212212353993-1445494804.png alt></p><p>好了，基于上面的基础认识。开始分析垃圾收集日志，以下是两条日志，第一条是一次 Minor GC，第二条是 Full GC。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-properties data-lang=properties><span class=line><span class=cl><span class=na>2019-12-03T16</span><span class=o>:</span><span class=s>20:47.980-0800: [GC (System.gc()) [PSYoungGen: 4068K-&gt;656K(9216K)] 4076K-&gt;672K(19456K), 0.0016106 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span>
</span></span><span class=line><span class=cl><span class=na>2019-12-03T16</span><span class=o>:</span><span class=s>20:47.982-0800: [Full GC (System.gc()) </span>
</span></span><span class=line><span class=cl>			<span class=na>[PSYoungGen</span><span class=o>:</span> <span class=s>656K-&gt;0K(9216K)],</span>
</span></span><span class=line><span class=cl>    	<span class=na>[ParOldGen</span><span class=o>:</span> <span class=s>16K-&gt;570K(10240K)] 672K-&gt;570K(19456K), </span>
</span></span><span class=line><span class=cl>    	<span class=na>[Metaspace</span><span class=o>:</span> <span class=s>3910K-&gt;3910K(1056768K)],</span>
</span></span><span class=line><span class=cl> <span class=na>0.0110117</span> <span class=s>secs] </span>
</span></span><span class=line><span class=cl> <span class=na>[Times</span><span class=o>:</span> <span class=s>user=0.02 sys=0.00, real=0.01 secs] </span>
</span></span></code></pre></div><p>为了更清楚的说明各个部分的含义，我居然又画了一张图（<em>PS:画个图真是不容易</em>），看一下各部分代表的含义。
<img src=https://hexo.moonkite.cn/blog/273364-20191212212412043-315466180.png alt></p><p>上图标注的是一条 Full GC 日志，Full GC 同时收集了年轻代、老年代以及 metaspace 区。Full GC 日志包含了 Minor GC 的内容，那我们就直接分析 Full GC 了。</p><p><strong>时间戳</strong>：日志以时间戳作为开端，表示此次垃圾收集发生的时间，由 <code>-XX:+PrintGCDateStamps</code> 参数决定是否开启。</p><p><strong>收集内容主体</strong>：</p><p>沿着日志顺序往后看，<code>Full GC (System.gc())</code>，收集类型(是 Full GC 还是 Minor GC) ，括号里跟着发生此次垃圾收集的原因。</p><p>再后面是年轻代、老年代、Metaspace 区详细的收集情况。</p><p><code>[PSYoungGen: 656K->0K(9216K)]</code>，翻译为 「年轻代：年轻代收集前内存使用量->年轻代垃圾收集后内存使用量（年轻代可用内存总大小）」，垃圾收集前年轻代已使用 656K，垃圾收集后已使用 0K，说明被回收了 656K，总可用大小为 9216K(9M)。诶，不对呀？怎么是 9M 呢，年轻代不是分了 10 M 吗。因为可用内存和总内存不能划等号，S0 和 S1 只能有一块被算进可用内存，所以可用内存为 Eden + S0/S1=9M。</p><p><code>[ParOldGen: 16K->570K(10240K)] 672K->570K(19456K)</code>，翻译为 「[老年代：老年代收集前内存使用量->老年代垃圾收集后内存使用量（老年代可用内存总大小）] 堆空间（包括年轻代和老年代）垃圾收集前内存使用量->堆空间垃圾收集后内存使用量（堆空间总可用大小）」。</p><p>垃圾收集前老年使用 16K，收集后呢，竟然变大了，确定没有看错吗。是的，没有。这是因为年轻代的对象有一些进入了老年代导致的。老年代 16K 变成了 570K，说明有 554K 是年轻代晋升而来的。而内存总大小由 672K 减少到了 570K，说明有102K的内存真正的被清理了。</p><p><code>[Metaspace: 3910K->3910K(1056768K)]</code>翻译为元空间回收前大小为 3910K，回收后大小为3910K，总可用大小为 1056768K。我们不是设置的 6M 吗，怎么这么大，没起作用吗。实际上这个值是 **CompressedClassSpaceSize +(2*InitialBootClassLoaderMetaspaceSize) **的大小，我们只设置了 MaxMetaspaceSize ，并没有设置这两个参数。使用如下命令可以看到这两个值的默认大小</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>jinfo -flag CompressedClassSpaceSize <span class=m>75867</span>
</span></span><span class=line><span class=cl>-XX:CompressedClassSpaceSize<span class=o>=</span><span class=m>1073741824</span>
</span></span><span class=line><span class=cl>jinfo -flag InitialBootClassLoaderMetaspaceSize <span class=m>75867</span>
</span></span><span class=line><span class=cl>-XX:InitialBootClassLoaderMetaspaceSize<span class=o>=</span><span class=m>4194304</span>
</span></span></code></pre></div><p>单位是 byte，CompressedClassSpaceSize 的值是 1048576K(其实就是1G，默认值)，InitialBootClassLoaderMetaspaceSize的值是 4M，用上面的公式计算，正好是 1056768K(1032M)</p><p><strong>耗时统计</strong></p><p><code>[Times: user=0.02 sys=0.00, real=0.01 secs]</code></p><p>user=0.02 表示执行用户态代码的耗时，这里也就是 GC 线程消耗的 CPU 时间。如果是多线程收集器，这个值会高于 real 时间。</p><p>sys=0.00 表示执行内核态代码的耗时。</p><p>real=0.01 表示应用停顿时长，多线程垃圾收集情况下，此数值应该接近(user + sys) / GCThreads（收集线程数），即单核上的平均停顿时间。</p><p>###CMS 收集器</p><p>CMS 是一款老年代垃圾收集器，年轻代使用 ParNew 与之配合使用。它是一款并发、低停顿的垃圾收集器。适用于要求低延迟、即时响应的应用系统。</p><p>CMS 规划的内存模型和上面 Parallel Scavenge 的是一致的，可以参考上面的内存分布图。</p><p><strong>CMS</strong> 采用<strong>标记-清除</strong>算法，算法过程比较复杂，分为一下几个步骤：</p><ul><li><p>初始标记（CMS initial mark），会导致 stop the world；</p></li><li><p>并发标记（CMS concurrent mark），与用户线程同时运行；</p></li><li><p>预清理（CMS-concurrent-preclean），与用户线程同时运行；</p></li><li><p>可被终止的预清理（CMS-concurrent-abortable-preclean） 与用户线程同时运行；</p></li><li><p>重新标记（CMS remark），会导致 stop the world；</p></li><li><p>并发清除（CMS concurrent sweep），与用户线程同时运行；</p></li><li><p>并发重置状态等待下次CMS的触发(CMS-concurrent-reset)，与用户线程同时运行；</p></li></ul><p>只有初始标记和重新标记这两个步骤会导致 STW，但是这两个步骤耗时很短，其他步骤可以与用户线程同时运行，所以用户几乎感觉不到 JVM 停顿。</p><p>使用参数 <code>-XX:+UseConcMarkSweepGC</code>可启用 CMS 垃圾收集器。更详细的参数如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-properties data-lang=properties><span class=line><span class=cl><span class=na>-XX</span><span class=o>:</span><span class=s>+UseConcMarkSweepGC</span>
</span></span><span class=line><span class=cl><span class=na>-XX</span><span class=o>:</span><span class=s>CMSInitiatingOccupancyFraction=70</span>
</span></span><span class=line><span class=cl><span class=na>-XX</span><span class=o>:</span><span class=s>+ExplicitGCInvokesConcurrentAndUnloadsClasses</span>
</span></span><span class=line><span class=cl><span class=na>-XX</span><span class=o>:</span><span class=s>+CMSClassUnloadingEnabled</span>
</span></span><span class=line><span class=cl><span class=na>-XX</span><span class=o>:</span><span class=s>+ParallelRefProcEnabled</span>
</span></span><span class=line><span class=cl><span class=c1># 在重新标记之前对年轻代做一次minor GC</span>
</span></span><span class=line><span class=cl><span class=na>-XX</span><span class=o>:</span><span class=s>+CMSScavengeBeforeRemark</span>
</span></span></code></pre></div><p>使用了<code>-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses</code>或<code>-XX:+ExplicitGCInvokesConcurrent</code>参数，在进行 Full GC 的时候，比如执行 System.gc() 操作，会触发 CMS GC，以此来提高 GC 效率。</p><p>以下是启用 CMS 后摘的一段 GC 日志，由于内容过长，下面我就直接在日志上做注释了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-properties data-lang=properties><span class=line><span class=cl><span class=c1># System.gc() 触发一次 Full GC</span>
</span></span><span class=line><span class=cl><span class=c1># -XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses 参数</span>
</span></span><span class=line><span class=cl><span class=c1># 导致Full GC 以 CMS GC 方式执行</span>
</span></span><span class=line><span class=cl><span class=c1># 先由 ParNew 收集器回收年轻代</span>
</span></span><span class=line><span class=cl><span class=na>2019-12-03T16</span><span class=o>:</span><span class=s>43:03.179-0800: [GC (System.gc()) 2019-12-03T16:43:03.179-0800: [ParNew: 3988K-&gt;267K(9216K), 0.0091869 secs] 3988K-&gt;919K(19456K), 0.0092257 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] </span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 初始标记阶段，标记那些直接被 GC root 引用或者被年轻代存活对象所引用的所有对象</span>
</span></span><span class=line><span class=cl><span class=c1># 老年代当前使用 651K</span>
</span></span><span class=line><span class=cl><span class=c1># 老年代可用大小 10240K=10M</span>
</span></span><span class=line><span class=cl><span class=c1># 当前堆内存使用量 919K</span>
</span></span><span class=line><span class=cl><span class=c1># 当前堆可用内存 19456K=19M</span>
</span></span><span class=line><span class=cl><span class=c1># “1 CMS-initial-mark” 这里的 1 表示老生代</span>
</span></span><span class=line><span class=cl><span class=na>2019-12-03T16</span><span class=o>:</span><span class=s>43:03.189-0800: [GC (CMS Initial Mark) [1 CMS-initial-mark: 651K(10240K)] 919K(19456K), 0.0002156 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 并发标记开始</span>
</span></span><span class=line><span class=cl><span class=c1># 标记所有存活的对象，它会根据上个阶段找到的 GC Roots 遍历查找</span>
</span></span><span class=line><span class=cl><span class=na>2019-12-03T16</span><span class=o>:</span><span class=s>43:03.189-0800: [CMS-concurrent-mark-start]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 并发标记阶段耗时统计</span>
</span></span><span class=line><span class=cl><span class=na>2019-12-03T16</span><span class=o>:</span><span class=s>43:03.190-0800: [CMS-concurrent-mark: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 并发预清理阶段开始</span>
</span></span><span class=line><span class=cl><span class=c1># 在上述并发标记过程中，一些对象的引用可能会发生变化，JVM 会将包含这个对象的区域（Card）标记为 Dirty</span>
</span></span><span class=line><span class=cl><span class=c1># 在此阶段，能够从 Dirty 对象到达的对象也会被标记，这个标记做完之后，dirty card 标记就会被清除了</span>
</span></span><span class=line><span class=cl><span class=na>2019-12-03T16</span><span class=o>:</span><span class=s>43:03.190-0800: [CMS-concurrent-preclean-start]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 并发预清理耗时统计</span>
</span></span><span class=line><span class=cl><span class=na>2019-12-03T16</span><span class=o>:</span><span class=s>43:03.190-0800: [CMS-concurrent-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 重新标记阶段，目的是完成老年代中所有存活对象的标记</span>
</span></span><span class=line><span class=cl><span class=c1># 上一阶段是并发执行的，在执行过程中对象的引用关系还会发生变化，所以再次标记</span>
</span></span><span class=line><span class=cl><span class=c1># 因为配置了 -XX:+CMSScavengeBeforeRemark 参数，所以会在标记发生一次 Minor GC</span>
</span></span><span class=line><span class=cl><span class=c1># 进行一次Minor GC,完成后年轻代可用空间 267K，年轻代总大小9216K</span>
</span></span><span class=line><span class=cl><span class=na>2019-12-03T16</span><span class=o>:</span><span class=s>43:03.190-0800: [GC (CMS Final Remark) [YG occupancy: 267 K (9216 K)]</span>
</span></span><span class=line><span class=cl><span class=c1># 更详细的年轻代收集情况</span>
</span></span><span class=line><span class=cl><span class=na>2019-12-03T16</span><span class=o>:</span><span class=s>43:03.190-0800: [GC (CMS Final Remark) 2019-12-03T16:43:03.190-0800: [ParNew: 267K-&gt;103K(9216K), 0.0021800 secs] 919K-&gt;755K(19456K), 0.0022127 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span>
</span></span><span class=line><span class=cl><span class=c1># 在程序暂停时重新进行扫描(Rescan),以完成存活对象的标记</span>
</span></span><span class=line><span class=cl><span class=na>2019-12-03T16</span><span class=o>:</span><span class=s>43:03.192-0800: [Rescan (parallel) , 0.0002866 secs]</span>
</span></span><span class=line><span class=cl><span class=c1># 第一子阶段：处理弱引用</span>
</span></span><span class=line><span class=cl><span class=na>2019-12-03T16</span><span class=o>:</span><span class=s>43:03.193-0800: [weak refs processing, 0.0015605 secs]</span>
</span></span><span class=line><span class=cl><span class=c1># 第二子阶段：卸载不适用的类</span>
</span></span><span class=line><span class=cl><span class=na>2019-12-03T16</span><span class=o>:</span><span class=s>43:03.194-0800: [class unloading, 0.0010847 secs]</span>
</span></span><span class=line><span class=cl><span class=c1># 第三子阶段:清理持有class级别 metadata 的符号表(symbol tables),以及内部化字符串对应的 string tables</span>
</span></span><span class=line><span class=cl><span class=c1># 完成后老年代使用量为651K(老年代总大小10240K=10M)</span>
</span></span><span class=line><span class=cl><span class=c1># 整个堆使用量 755K(总堆大小19456K=19M)</span>
</span></span><span class=line><span class=cl><span class=na>2019-12-03T16</span><span class=o>:</span><span class=s>43:03.195-0800: [scrub symbol table, 0.0015690 secs]</span>
</span></span><span class=line><span class=cl><span class=na>2019-12-03T16</span><span class=o>:</span><span class=s>43:03.197-0800: [scrub string table, 0.0003786 secs][1 CMS-remark: 651K(10240K)] 755K(19456K), 0.0075058 secs] [Times: user=0.01 sys=0.01, real=0.00 secs]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#开始并发清理 清除未被标记、不再使用的对象以释放内存空间</span>
</span></span><span class=line><span class=cl><span class=na>2019-12-03T16</span><span class=o>:</span><span class=s>43:03.198-0800: [CMS-concurrent-sweep-start]</span>
</span></span><span class=line><span class=cl><span class=c1>#并发清理阶段耗时</span>
</span></span><span class=line><span class=cl><span class=na>2019-12-03T16</span><span class=o>:</span><span class=s>43:03.198-0800: [CMS-concurrent-sweep: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 开始并发重置，重置CMS算法相关的内部数据, 为下一次GC循环做准备</span>
</span></span><span class=line><span class=cl><span class=na>2019-12-03T16</span><span class=o>:</span><span class=s>43:03.198-0800: [CMS-concurrent-reset-start]</span>
</span></span><span class=line><span class=cl><span class=c1># 重置耗时</span>
</span></span><span class=line><span class=cl><span class=na>2019-12-03T16</span><span class=o>:</span><span class=s>43:03.199-0800: [CMS-concurrent-reset: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 下面是执行 jmap -histo:live 命令触发的 Full GC</span>
</span></span><span class=line><span class=cl><span class=c1># GC 类型是 Full GC</span>
</span></span><span class=line><span class=cl><span class=c1># 触发原因是 Heap Inspection Initiated GC</span>
</span></span><span class=line><span class=cl><span class=c1># CMS收集老年代：从清理前的650K变为清理后的617K，总的老年代10M,耗时0.0048490秒</span>
</span></span><span class=line><span class=cl><span class=c1># 总堆使用大小由 1245K变为617K，总堆19M</span>
</span></span><span class=line><span class=cl><span class=c1># metaspace: 3912K变为3912K，</span>
</span></span><span class=line><span class=cl><span class=c1># metaspace 总大小显示为  CompressedClassSpaceSize +(2*InitialBootClassLoaderMetaspaceSize)</span>
</span></span><span class=line><span class=cl><span class=na>2019-12-03T16</span><span class=o>:</span><span class=s>43:20.115-0800: [Full GC (Heap Inspection Initiated GC) 2019-12-03T16:43:20.115-0800: [CMS: 650K-&gt;617K(10240K), 0.0048490 secs] 1245K-&gt;617K(19456K), [Metaspace: 3912K-&gt;3912K(1056768K)], 0.0049050 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span>
</span></span></code></pre></div><p>以上就是对 CMS 垃圾收集器产生日志的分析，因为过程复杂，所以产生的日志内容也比较多。</p><h3 id=g1-收集器>G1 收集器</h3><p>G1 收集器是在 JDK 7 版本中就已经正式推出，并且作为 JDK 9 默认的垃圾收集器。</p><p><strong>Parallel Scavenge</strong>：我追求高吞吐量，现在社会什么最重要，效率呀，有没有。</p><p><strong>CMS</strong>：效率固然重要，极致的用户体验才是王道啊，不能让用户等啊，不能等啊，低停顿、即时响应是我毕生追求。</p><p><strong>G1（一脸不屑）</strong>：有句话不只当讲不当讲，首先声明没有恶意，我想说，在座的各位都是垃圾。上面两位说的，我全都有，是的，全都有。 (ps：结果被打)</p><p>以上纯属开个玩笑，只是为了说明 G1 在满足了低停顿的同时也保证了高吞吐量，适用于多核处理器、大内存容量的服务端系统。</p><p><strong>G1</strong> 是 CMS 的替代版本，具有如下特点：</p><ul><li>横跨年轻代和老年代，不需要其他收集器配合；</li><li>并发收集器，可以与用户线程并发执行；</li><li>会压缩内存碎片；</li><li>可预测的停顿时间与高吞吐量；</li></ul><p>与其他的垃圾收集器不同，G1 对堆内存做了不一样的规划，虽然还是使用分代策略，分为老年代、年轻代，年轻代又分为 Eden、Survivior 区，但是只是逻辑划分，物理上并不连续。它是将堆内存分为一系列大小在1M-32M 不等的 Region 区，通过下方的图可以直观的看出效果。
<img src=https://img2018.cnblogs.com/blog/273364/201912/273364-20191212212449597-1923977357.png alt></p><p>G1 垃圾收集包括年轻代收集和老年代收集两部分。
年轻代比较简单，收集器如果检测到存活区对象存活时间达到阈值，就会将这些存活对象转移到新的 Survivor 区或老年代，此过程会导致 stop the world。
老年代的收集就比较复杂了，包括如下几个阶段：</p><ul><li>初始标记阶段(Initial Marking Phase)，会导致 stop the wrold;</li><li>根区域扫描（Root Region Scan），与应用程序并发执行；</li><li>根区域扫描（Root Region Scan），与应用程序并发执行；</li><li>并发标记（Concurrent Marking），与应用程序并发执行；</li><li>最终标记（Remark），会导致 stop the wrold;</li><li>复制/清除（Copying/Cleanup），会导致 stop the wrold;</li></ul><p>开启 G1 收集器的参数如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-properties data-lang=properties><span class=line><span class=cl><span class=na>-XX</span><span class=o>:</span><span class=s>+UseG1GC</span>
</span></span><span class=line><span class=cl><span class=na>-XX</span><span class=o>:</span><span class=s>MaxGCPauseMillis=100</span>
</span></span></code></pre></div><p>使用 G1 收集器时，一般不设置年轻代的大小。</p><p>以下是一次 G1 收集的日志，简单的分析直接写到下面的日志内了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 进行了一次年轻代 GC,耗时0.0008029S</span>
</span></span><span class=line><span class=cl><span class=o>[</span>GC pause <span class=o>(</span>G1 Humongous Allocation<span class=o>)</span> <span class=o>(</span>young<span class=o>)</span>, 0.0008029 secs<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=c1># 4个GC线程并行执行</span>
</span></span><span class=line><span class=cl>   <span class=o>[</span>Parallel Time: 0.5 ms, GC Workers: 4<span class=o>]</span>
</span></span><span class=line><span class=cl>   <span class=c1># GC 线程耗时统计，反应收集的稳定性和效率</span>
</span></span><span class=line><span class=cl>      <span class=o>[</span>GC Worker Start <span class=o>(</span>ms<span class=o>)</span>: Min: 90438.1, Avg: 90438.2, Max: 90438.4, Diff: 0.3<span class=o>]</span>
</span></span><span class=line><span class=cl>      <span class=c1># 扫描堆外内存耗时统计</span>
</span></span><span class=line><span class=cl>      <span class=o>[</span>Ext Root Scanning <span class=o>(</span>ms<span class=o>)</span>: Min: 0.0, Avg: 0.2, Max: 0.2, Diff: 0.2, Sum: 0.6<span class=o>]</span>
</span></span><span class=line><span class=cl>      <span class=c1># 更新和扫描RSets 耗时统计</span>
</span></span><span class=line><span class=cl>      <span class=o>[</span>Update RS <span class=o>(</span>ms<span class=o>)</span>: Min: 0.0, Avg: 0.1, Max: 0.2, Diff: 0.2, Sum: 0.2<span class=o>]</span>
</span></span><span class=line><span class=cl>         <span class=o>[</span>Processed Buffers: Min: 0, Avg: 0.2, Max: 1, Diff: 1, Sum: 1<span class=o>]</span>
</span></span><span class=line><span class=cl>      <span class=o>[</span>Scan RS <span class=o>(</span>ms<span class=o>)</span>: Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0<span class=o>]</span>
</span></span><span class=line><span class=cl>      <span class=c1>#扫描堆中的 root 对象耗时统计</span>
</span></span><span class=line><span class=cl>      <span class=o>[</span>Code Root Scanning <span class=o>(</span>ms<span class=o>)</span>: Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0<span class=o>]</span>
</span></span><span class=line><span class=cl>      <span class=c1># 拷贝存活对象耗时统计</span>
</span></span><span class=line><span class=cl>      <span class=o>[</span>Object Copy <span class=o>(</span>ms<span class=o>)</span>: Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1<span class=o>]</span>
</span></span><span class=line><span class=cl>      <span class=c1># GC 线程确保自身安全停止耗时统计</span>
</span></span><span class=line><span class=cl>      <span class=o>[</span>Termination <span class=o>(</span>ms<span class=o>)</span>: Min: 0.0, Avg: 0.1, Max: 0.2, Diff: 0.2, Sum: 0.5<span class=o>]</span>
</span></span><span class=line><span class=cl>         <span class=o>[</span>Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 4<span class=o>]</span>
</span></span><span class=line><span class=cl>      <span class=o>[</span>GC Worker Other <span class=o>(</span>ms<span class=o>)</span>: Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0<span class=o>]</span>
</span></span><span class=line><span class=cl>      <span class=c1># GC的worker 线程的工作时间总计</span>
</span></span><span class=line><span class=cl>      <span class=o>[</span>GC Worker Total <span class=o>(</span>ms<span class=o>)</span>: Min: 0.1, Avg: 0.4, Max: 0.5, Diff: 0.3, Sum: 1.5<span class=o>]</span>
</span></span><span class=line><span class=cl>      <span class=c1># GC的worker 线程完成作业的时间统计</span>
</span></span><span class=line><span class=cl>      <span class=o>[</span>GC Worker End <span class=o>(</span>ms<span class=o>)</span>: Min: 90438.6, Avg: 90438.6, Max: 90438.6, Diff: 0.0<span class=o>]</span>
</span></span><span class=line><span class=cl>   <span class=c1># 修复GC期间code root指针改变的耗时</span>
</span></span><span class=line><span class=cl>   <span class=o>[</span>Code Root Fixup: 0.0 ms<span class=o>]</span>
</span></span><span class=line><span class=cl>   <span class=c1># 清除code root耗时</span>
</span></span><span class=line><span class=cl>   <span class=o>[</span>Code Root Purge: 0.0 ms<span class=o>]</span>
</span></span><span class=line><span class=cl>   <span class=c1># 清除card tables 中的dirty card的耗时</span>
</span></span><span class=line><span class=cl>   <span class=o>[</span>Clear CT: 0.0 ms<span class=o>]</span>
</span></span><span class=line><span class=cl>   <span class=c1># 其他方面比如选择CSet、处理已用对象、引用入ReferenceQueues、释放CSet中的region等的耗时</span>
</span></span><span class=line><span class=cl>   <span class=o>[</span>Other: 0.3 ms<span class=o>]</span>
</span></span><span class=line><span class=cl>      <span class=o>[</span>Choose CSet: 0.0 ms<span class=o>]</span>
</span></span><span class=line><span class=cl>      <span class=o>[</span>Ref Proc: 0.1 ms<span class=o>]</span>
</span></span><span class=line><span class=cl>      <span class=o>[</span>Ref Enq: 0.0 ms<span class=o>]</span>
</span></span><span class=line><span class=cl>      <span class=o>[</span>Redirty Cards: 0.0 ms<span class=o>]</span>
</span></span><span class=line><span class=cl>      <span class=o>[</span>Humongous Register: 0.0 ms<span class=o>]</span>
</span></span><span class=line><span class=cl>      <span class=o>[</span>Humongous Reclaim: 0.0 ms<span class=o>]</span>
</span></span><span class=line><span class=cl>      <span class=o>[</span>Free CSet: 0.0 ms<span class=o>]</span>
</span></span><span class=line><span class=cl>   <span class=c1># 收集前 Eden区使用量 1024K(总容量9216K),收集后容量0B(总容量9216K)</span>
</span></span><span class=line><span class=cl>   <span class=c1># Survivors 区收集前后的大小</span>
</span></span><span class=line><span class=cl>   <span class=c1># 堆空间收集前使用量13.4M(总量20M),收集后650.2K</span>
</span></span><span class=line><span class=cl>   <span class=o>[</span>Eden: 1024.0K<span class=o>(</span>9216.0K<span class=o>)</span>-&gt;0.0B<span class=o>(</span>9216.0K<span class=o>)</span> Survivors: 1024.0K-&gt;1024.0K Heap: 13.4M<span class=o>(</span>20.0M<span class=o>)</span>-&gt;650.2K<span class=o>(</span>20.0M<span class=o>)]</span>
</span></span><span class=line><span class=cl> <span class=o>[</span>Times: <span class=nv>user</span><span class=o>=</span>0.00 <span class=nv>sys</span><span class=o>=</span>0.00, <span class=nv>real</span><span class=o>=</span>0.00 secs<span class=o>]</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 初始标记阶段，耗时0.0031800s</span>
</span></span><span class=line><span class=cl>2019-12-03T16:48:25.456-0800: <span class=o>[</span>GC pause <span class=o>(</span>G1 Humongous Allocation<span class=o>)</span> <span class=o>(</span>young<span class=o>)</span> <span class=o>(</span>initial-mark<span class=o>)</span>, 0.0031800 secs<span class=o>][</span>Parallel Time: 2.5 ms, GC Workers: 4<span class=o>]</span>
</span></span><span class=line><span class=cl>      <span class=o>[</span>GC Worker Start <span class=o>(</span>ms<span class=o>)</span>: Min: 4115.2, Avg: 4115.4, Max: 4115.8, Diff: 0.6<span class=o>]</span>
</span></span><span class=line><span class=cl>      ...
</span></span><span class=line><span class=cl>   <span class=o>[</span>Eden: 3072.0K<span class=o>(</span>10.0M<span class=o>)</span>-&gt;0.0B<span class=o>(</span>9216.0K<span class=o>)</span> Survivors: 0.0B-&gt;1024.0K Heap: 9216.0K<span class=o>(</span>20.0M<span class=o>)</span>-&gt;744.0K<span class=o>(</span>20.0M<span class=o>)]</span>
</span></span><span class=line><span class=cl> <span class=o>[</span>Times: <span class=nv>user</span><span class=o>=</span>0.01 <span class=nv>sys</span><span class=o>=</span>0.00, <span class=nv>real</span><span class=o>=</span>0.00 secs<span class=o>]</span> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># Root区扫描 </span>
</span></span><span class=line><span class=cl>2019-12-03T16:48:25.460-0800: <span class=o>[</span>GC concurrent-root-region-scan-start<span class=o>]</span>
</span></span><span class=line><span class=cl>2019-12-03T16:48:25.462-0800: <span class=o>[</span>GC concurrent-root-region-scan-end, 0.0024198 secs<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=c1># 并发标记</span>
</span></span><span class=line><span class=cl>2019-12-03T16:48:25.462-0800: <span class=o>[</span>GC concurrent-mark-start<span class=o>]</span>
</span></span><span class=line><span class=cl>2019-12-03T16:48:25.462-0800: <span class=o>[</span>GC concurrent-mark-end, 0.0001306 secs<span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 再次标记</span>
</span></span><span class=line><span class=cl>2019-12-03T16:48:25.462-0800: <span class=o>[</span>GC remark 2019-12-03T16:48:25.462-0800: <span class=o>[</span>Finalize Marking, 0.0015922 secs<span class=o>]</span> 2019-12-03T16:48:25.464-0800: <span class=o>[</span>GC ref-proc, 0.0004899 secs<span class=o>]</span> 2019-12-03T16:48:25.465-0800: <span class=o>[</span>Unloading, 0.0016093 secs<span class=o>]</span>, 0.0040544 secs<span class=o>]</span>
</span></span><span class=line><span class=cl> <span class=o>[</span>Times: <span class=nv>user</span><span class=o>=</span>0.01 <span class=nv>sys</span><span class=o>=</span>0.00, <span class=nv>real</span><span class=o>=</span>0.00 secs<span class=o>]</span> 
</span></span><span class=line><span class=cl><span class=c1># 清理工作 </span>
</span></span><span class=line><span class=cl>2019-12-03T16:48:25.467-0800: <span class=o>[</span>GC cleanup 4000K-&gt;4000K<span class=o>(</span>20M<span class=o>)</span>, 0.0003710 secs<span class=o>]</span>
</span></span><span class=line><span class=cl> <span class=o>[</span>Times: <span class=nv>user</span><span class=o>=</span>0.00 <span class=nv>sys</span><span class=o>=</span>0.00, <span class=nv>real</span><span class=o>=</span>0.00 secs<span class=o>]</span> 
</span></span></code></pre></div><p>##其他工具</p><p>大多数时候靠肉眼分析日志是很困难的，借助一些分析工具是必不可少的。</p><p>在线日志分析网站：https://gceasy.io/
在线 JVM 参数生成：https://opts.console.perfma.com/result/generate/JlKEV</p></article><h4>相关文章</h4><dl class=row><dd class=col-md-9><a href=/category/java/JDK17/>新项目为什么决定用 JDK 17了</a></dd><dd class=col-md-9><a href=/category/java/Graalvm/>过两年 JVM 可能就要被GraalVM替代了</a></dd><dd class=col-md-9><a href=/category/java/JVM-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E9%A2%84%E9%98%B2/>JVM 内存溢出的原因及预防</a></dd><dd class=col-md-9><a href=/category/java/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E8%87%AA%E5%B7%B1%E7%9A%84-JDK/>手把手教你编译属于自己的 JDK</a></dd><dd class=col-md-9><a href=/category/java/Java-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%97/>Java 字符串常量池漫游指南（图文并茂）</a></dd></dl><div class=author-card><div class=underline></div><div class=author-box><div class=qr-author-image><a href=/><img src=/images/person.jpg alt=风筝></a></div><div class=author-content><p class=author-title>作者</p><p class=author-name>风筝</p><p class=author-desc>古时的风筝，一个平庸的程序员，主语言 Java，第二语言 Python，其实学 Python 的时间比 Java 还要早。喜欢写博客，写博客的过程能加深自己对一个知识点的理解，同时还可以分享给他人。喜欢做一些小东西，所以也会一些前端的东西，React、JavaScript、CSS 都会一些，做一些小工具还够用。</p></div></div></div><script src=https://utteranc.es/client.js repo=huzhicheng/blog-comment issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></main><div class="footer gradient-2"><div class="container footer-container"><div class=row><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>网站地图</div><ul class=list-unstyled><li><a href=https://www.moonkite.cn/tags/>标签</a></li><li><a href=https://www.moonkite.cn/categories/>分类</a></li><li><a rel=alternate type=application/rss+xml href=https://www.moonkite.cn/index.xml><i class="fas fa-rss-square"></i> RSS订阅</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>社群</div><ul class=list-unstyled><li><a href=https://github.com/huzhicheng rel=noopener target=_blank>GitHub</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>友链</div><ul class=list-unstyled><li><a href=https://github.com/huzhicheng rel=noopener target=_blank>关于我</a></li></ul></div><div class="col-xs-12 col-sm-3 col-md-3 col-lg-3"><p class="pull-right text-right"><small><em>Proudly powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo</a></em></small><br><small><em>Theme - <a href=https://github.com/shaform/hugo-theme-den rel=noopener target=_blank>Den</a></em></small><br><small>&copy;
风筝
2023</small></p></div></div><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?e417ddf834c7bb7411207e1fa09815aa",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-C714TFXRD4"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-C714TFXRD4")</script><div class=busuanzi-footer><span id=busuanzi_container_site_pv>本站总访问量<span id=busuanzi_value_site_pv></span>次</span>
<span id=busuanzi_container_site_uv>本站访客数<span id=busuanzi_value_site_uv></span>人次</span></div></div></div><script src=https://code.jquery.com/jquery-3.3.1.slim.min.js integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap_4.1.3_js_bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script>
<script>$(document).ready(function(){$("#load_disqus").length&&$(window).scroll(function(){if($("#load_disqus").length){var e=$("#load_disqus").offset().top,t=$(window).scrollTop(),n=t+$(window).height();t<e&&e<n&&load_disqus()}})})</script></body></html>