<!doctype html><html lang=zh-cn itemscope itemtype=http://schema.org/WebPage><head><meta name=generator content="Hugo 0.119.0"><meta charset=utf-8><title>Java 开发， volatile 你必须了解一下 · 古时的风筝</title><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=description content="上一篇文章说了 CAS 原理，其中说到了 Atomic* 类，他们实现原子操作的机制就依靠了 volatile 的内存可见性特性。如果还不了解 CAS 和 Atomic*，建议看一下我们说的 CAS"><meta name=360-site-verification content="e75339f1cfcde17f66f71aaf8b6983e9"><meta name=keywords content="Hugo,theme,编程,java,ChatGPT,程序员,开发"><link rel=canonical href=https://www.moonkite.cn/category/java/Java-%E5%BC%80%E5%8F%91-volatile-%E4%BD%A0%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B/><link rel=icon href=https://www.moonkite.cn/images/photo.png><link rel=stylesheet href=https://cdn.staticfile.org/twitter-bootstrap/4.1.3/css/bootstrap.min.css><link rel=stylesheet href=https://www.moonkite.cn/css/den.css><link href=https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/lxgwwenkaiscreen.min.css rel=stylesheet><meta property="og:title" content="Java 开发， volatile 你必须了解一下"><meta property="og:description" content="上一篇文章说了 CAS 原理，其中说到了 Atomic* 类，他们实现原子操作的机制就依靠了 volatile 的内存可见性特性。如果还不了解 CAS 和 Atomic*，建议看一下我们说的 CAS"><meta property="og:type" content="article"><meta property="og:url" content="https://www.moonkite.cn/category/java/Java-%E5%BC%80%E5%8F%91-volatile-%E4%BD%A0%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B/"><meta property="article:section" content="category"><meta property="article:published_time" content="2018-05-02T08:56:23+08:00"><meta property="article:modified_time" content="2018-05-02T08:56:23+08:00"><meta itemprop=name content="Java 开发， volatile 你必须了解一下"><meta itemprop=description content="上一篇文章说了 CAS 原理，其中说到了 Atomic* 类，他们实现原子操作的机制就依靠了 volatile 的内存可见性特性。如果还不了解 CAS 和 Atomic*，建议看一下我们说的 CAS"><meta itemprop=datePublished content="2018-05-02T08:56:23+08:00"><meta itemprop=dateModified content="2018-05-02T08:56:23+08:00"><meta itemprop=wordCount content="3004"><meta itemprop=keywords content="Java,JDK,Java锁,Java多线程,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java 开发， volatile 你必须了解一下"><meta name=twitter:description content="上一篇文章说了 CAS 原理，其中说到了 Atomic* 类，他们实现原子操作的机制就依靠了 volatile 的内存可见性特性。如果还不了解 CAS 和 Atomic*，建议看一下我们说的 CAS"></head><body><div class=header-container style=background:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2)),url(https://hexo.moonkite.cn/blog/background.png);background-position:top;background-size:cover><div class=container><nav class="header-nav navbar navbar-expand-md navbar-dark light-dark"><div class="header-logo navbar-brand"><a class=float-left href=https://www.moonkite.cn/></a></div><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarNav aria-controls=navbarNav aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="nav-menu collapse navbar-collapse" id=navbarNav><ul class=navbar-nav><li class=nav-item><a href=https://www.moonkite.cn/ class=nav-link><i class="fas fad fa-h-square"></i>主页</a></li><li class=nav-item><a href=https://www.moonkite.cn/category/notes class=nav-link><i class='fas fa-yin-yang'></i>生活随笔</a></li><li class=nav-item><a href=javascript:void(0) class=nav-link><i class='fas fa-laptop-code'></i>技术文章</a><div class=sub-dropdown-menu><a class=sub-nav-link href=https://www.moonkite.cn/category/java><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 48 48"><path fill="#f44336" d="M23.65 24.898c-.998-1.609-1.722-2.943-2.725-5.455C19.229 15.2 31.24 11.366 26.37 3.999c2.111 5.089-7.577 8.235-8.477 12.473-.823 3.898 5.752 8.426 5.757 8.426z"/><path fill="#f44336" d="M23.878 17.27c-.192 2.516 2.229 3.857 2.299 5.695.056 1.496-1.447 2.743-1.447 2.743s2.728-.536 3.579-2.818c.945-2.534-1.834-4.269-1.548-6.298.267-1.938 6.031-5.543 6.031-5.543S24.311 11.611 23.878 17.27z"/><g><path fill="#1565c0" d="M32.084 25.055c1.754-.394 3.233.723 3.233 2.01.0 2.901-4.021 5.643-4.021 5.643s6.225-.742 6.225-5.505c0-3.15-3.057-3.937-5.437-2.148zm-2.955 2.34s1.941-1.383 2.458-1.902c-4.763 1.011-15.638 1.147-15.638.269.0-.809 3.507-1.638 3.507-1.638s-7.773-.112-7.773 2.181C11.683 28.695 21.858 28.866 29.129 27.395z"/><path fill="#1565c0" d="M27.935 29.571c-4.509 1.499-12.814 1.02-10.354-.993-1.198.0-2.974.963-2.974 1.889.0 1.857 8.982 3.291 15.63.572l-2.302-1.468z"/><path fill="#1565c0" d="M18.686 32.739c-1.636.0-2.695 1.054-2.695 1.822.0 2.391 9.76 2.632 13.627.205l-2.458-1.632C24.271 34.404 17.014 34.579 18.686 32.739z"/><path fill="#1565c0" d="M36.281 36.632c0-.936-1.055-1.377-1.433-1.588 2.228 5.373-22.317 4.956-22.317 1.784.0-.721 1.807-1.427 3.477-1.093l-1.42-.839C11.26 34.374 9 35.837 9 37.017 9 42.52 36.281 42.255 36.281 36.632z"/><path fill="#1565c0" d="M39 38.604c-4.146 4.095-14.659 5.587-25.231 3.057C24.341 46.164 38.95 43.628 39 38.604z"/></g></svg>&nbsp;可爱的 Java</a>
<a class=sub-nav-link href=https://www.moonkite.cn/category/SpringCloud><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 48 48"><path fill="#8bc34a" d="M43.982 23.635c.069-4.261-.891-9.328-2.891-15.273L39.523 3.7l-2.13 4.433c-.114.237-.244.469-.38.698C33.514 5.827 28.974 4 24 4 12.954 4 4 12.954 4 24s8.954 20 20 20 20-8.954 20-20C44 23.877 43.984 23.758 43.982 23.635z"/><path fill="#fff" d="M39.385 32.558C36.262 36.86 30.734 37.091 25.531 37H18.75h-1.938c4.428-1.593 7.063-1.972 9.754-3.4 5.068-2.665 10.078-8.496 11.121-14.562-1.93 5.836-7.779 10.85-13.109 12.889-3.652 1.393-10.248 2.745-10.248 2.745l-.267-.145C9.573 32.268 9.437 22.214 17.6 18.968c3.574-1.423 6.993-.641 10.854-1.593 4.122-1.012 8.89-4.208 10.83-8.375C41.456 15.667 44.07 26.106 39.385 32.558zM15.668 38.445C15.386 38.795 14.955 39 14.505 39c-.823.0-1.495-.677-1.495-1.5s.677-1.5 1.495-1.5c.341.0.677.118.941.336C16.086 36.855 16.186 37.805 15.668 38.445z"/></svg>&nbsp; Spring Cloud 系列</a>
<a class=sub-nav-link href=https://www.moonkite.cn/category/other><img width=20 height=20 src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAADWElEQVR4nO2X30tTYRjH9xd4X2Dsol1EEtJdEFiSF10pldlVaVHEjiFFkKQVQeV0kfSTHdfW1pzKlpZtzXJuzp2pmzPFTdmUTdLJlEAvNKyB8MYzPG/visHZ2jxrnQc+8PCc85zz/e592XkfkUgIIYT4v2OoTVrtVFDTjILaYmgK8YqC2oproalzKZlwKqga3sXTSeFuZts9ykWcNOXnbITcTj67IRQcG1rlE5/dECK3GXcjxC8ADwqMuxGfBMeGVklNaRmZ83z0L3+ZR3ywMBfInJHQqGl07esKAmYjK6hnJoph64Ar/KsOOXmNK6HOTszKtD9uJitGQGSRcQFDiqh1RHAd8nSMWMQSDJgRjLAhrIgxta3lDvaiRlMpxvKvbi3BCNfI+xVRehdRIT2DIUWdejeH65BzMWKd1KO6jqOYLrEE46fp7Bm5bgki0Q0bhhS1t3UM1yHnYuS1XY5Oy0swD8USjPNmQ2aNfO6WO0KjphHgbrc9XNjsirGwdeAY7Vpl65CT15LRYb4VltLHYyzKAwcxgw3Xwr5BQ9D9ll53dz9d+msjfNLfWoO6GstR7/0zCXXBCJMPKxLMl3kkmC9GQsTf706znK3vyKLdhtznL2ISPm5TaqQdro8DeTJxm4EHKDZRGQfy308HtdvAcJY1I3BsII8RpAgwwB41IE9mBAwgR0EcyMlrRcTxB45DgpFUV+RbSIMxuq4kXRFyFl+3VuTeiqBtQYCDqUxqhOyJPCsTjDDCitB5urW8zS2oTSzBxNS7MB3tpeiC4kicO8azCQLJnkB9Me750Xs44b4CmQcjc4SzZwSGHXL42Xy0B6NTHMIDUp36RIJAsmeS2od7vuuKE+4TEUMbDHGZMLLBNrlUV/3u9sYRwH7vkq/nZFmUJaotwfRoK5bk6qoooNRUh9kegOyZkpUtsT3zuvKE+6qev4myKF899nkNTeMTJuWsu6spTBjZ4GzESUv7+R6qmCQ4aeoTZyPDLy4XMTS1xrdo5k/WmDbpflEq4XpJ7XbS1O0+bYvnve7JLNCnkXkZWmrYCfo0Mi9+r7bFA1pAkyjd0Ov1EZVKhQDI034Q3++1mM39H8xmBECeEZV8vNdmtRptAwMojtVqzIjKHH6vEEIIIcrt+AnU4LBcH67z1wAAAABJRU5ErkJggg=="> &nbsp; 杂七杂八</a></div></li><li class=nav-item><a href=https://www.moonkite.cn/category/network class=nav-link><i class="fas fa-network-wired"></i>轻解计算机网络</a></li><li class=nav-item><a href=https://www.moonkite.cn/category/product class=nav-link><i class="fas fab fa-medapps"></i>我的产品</a></li></ul></div></nav></div><div class="container header-wrapper"><div class=row><div class=col-lg-12><div class=header-content><h1 class=header-title>Java 开发， volatile 你必须了解一下</h1><p class=header-date>作者：
风筝 /
2018-05-02<div class=header-underline></div><div class=clearfix></div><p class="float-right header-tags"><i class="fas fa-tags" aria-hidden=true></i>
<a href=https://www.moonkite.cn/tag/Java/>Java</a>,
<a href=https://www.moonkite.cn/tag/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/>Java多线程</a>,
<a href=https://www.moonkite.cn/tag/Java%E9%94%81/>Java锁</a>,
<a href=https://www.moonkite.cn/tag/JDK/>JDK</a></p></div></div></div></div></div><main><div class="container content"><article><p>上一篇文章说了 CAS 原理，其中说到了 Atomic* 类，他们实现原子操作的机制就依靠了 volatile 的内存可见性特性。如果还不了解 CAS 和 Atomic*，建议看一下<a href=https://mp.weixin.qq.com/s/VeHq-LFPTYbtO6DsHKwngw>我们说的 CAS 自旋锁是什么</a></p><h2 id=并发的三个特性><strong>并发的三个特性</strong></h2><p>首先说我们如果要使用 volatile 了，那肯定是在多线程并发的环境下。我们常说的并发场景下有三个重要特性：原子性、可见性、有序性。只有在满足了这三个特性，才能保证并发程序正确执行，否则就会出现各种各样的问题。</p><p><strong>原子性</strong>，上篇文章说到的 CAS 和 Atomic* 类，可以保证简单操作的原子性，对于一些负责的操作，可以使用synchronized 或各种锁来实现。</p><p><strong>可见性</strong>，指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p><p><strong>有序性</strong>，程序执行的顺序按照代码的先后顺序执行，禁止进行指令重排序。看似理所当然的事情，其实并不是这样，指令重排序是JVM为了优化指令，提高程序运行效率，在不影响单线程程序执行结果的前提下，尽可能地提高并行度。但是在多线程环境下，有些代码的顺序改变，有可能引发逻辑上的不正确。</p><p>而 volatile 做实现了两个特性，可见性和有序性。所以说在多线程环境中，需要保证这两个特性的功能，可以使用 volatile 关键字。</p><h2 id=volatile-是如何保证可见性的><strong>volatile 是如何保证可见性的</strong></h2><p>说到可见性，就要了解一下计算机的处理器和主存了。因为多线程，不管有多少个线程，最后还是要在计算机处理器中进行的，现在的计算机基本都是多核的，甚至有的机器是多处理器的。我们看一下多处理器的结构图：</p><p><img src=https://hexo.moonkite.cn/blog/273364-20180522075706168-1989219158.png alt></p><p>这是两个处理器，四核的 CPU。一个处理器对应一个物理插槽，多处理器间通过QPI总线相连。一个处理器包含多个核，一个处理器间的多核共享L3 Cache。一个核包含寄存器、L1 Cache、L2 Cache。</p><p>在程序执行的过程中，一定要涉及到数据的读和写。而我们都知道，虽然内存的访问速度已经很快了，但是比起CPU执行指令的速度来，还是差的很远的，因此，在内核中，增加了L1、L2、L3 三级缓存，这样一来，当程序运行的时候，先将所需要的数据从主存复制一份到所在核的缓存中，运算完成后，再写入主存中。下图是 CPU 访问数据的示意图，由寄存器到高速缓存再到主存甚至硬盘的速度是越来越慢的。
<img src=https://hexo.moonkite.cn/blog/273364-20180522075720876-1123269801.png alt></p><p>了解了 CPU 结构之后，我们来看一下程序执行的具体过程，拿一个简单的自增操作举例。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>i</span><span class=o>=</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=o>;</span>
</span></span></code></pre></div><p>执行这条语句的时候，在某个核上运行的某线程将 i 的值拷贝一个副本到此核所在的缓存中，当运算执行完成后，再回写到主存中去。如果是多线程环境下，每一个线程都会在所运行的核上的高速缓存区有一个对应的工作内存，也就是每一个线程都有自己的私有工作缓存区，用来存放运算需要的副本数据。那么，我们再来看这个 i+1 的问题，假设 i 的初始值为0，有两个线程同时执行这条语句，每个线程执行都需要三个步骤：</p><p>1、从主存读取 i 值到线程工作内存，也就是对应的内核高速缓存区；</p><p>2、计算 i+1 的值；</p><p>3、将结果值写回主存中；</p><p>建设两个线程各执行 10,000 次后，我们预期的值应该是 20,000 才对，可惜很遗憾，i 的值总是小于 20,000 的 。导致这个问题的其中一个原因就是缓存一致性问题，对于这个例子来说，一旦某个线程的缓存副本做了修改，其他线程的缓存副本应该立即失效才对。</p><p>而使用了 volatile 关键字后，会有如下效果：</p><p>1、每次对变量的修改，都会引起处理器缓存（工作内存）写回到主存；</p><p>2、一个工作内存回写到主存会导致其他线程的处理器缓存（工作内存）无效。</p><p>因为 volatile 保证内存可见性，其实是用到了 CPU 保证缓存一致性的 MESI 协议。MESI 协议内容较多，这里就不做说明，请各位同学自己去查询一下吧。总之用了 volatile 关键字，当某线程对 volatile 变量的修改会立即回写到主存中，并且导致其他线程的缓存行失效，强制其他线程再使用变量时，需要从主存中读取。</p><p>那么我们把上面的 i 变量用 volatile 修饰后，再次执行，每个线程执行 10,000 次。很遗憾，还是小于 20,000 的。这是为什么呢？</p><p>volatile 利用 CPU 的 MESI 协议确实保证了可见性。但是，注意了，volatile 并没有保证操作的原子性，因为这个自增操作是分三步的，假设线程 1 从主存中读取了 i 值，假设是 10 ，并且此时发生了阻塞，但是还没有对i进行修改，此时线程 2 也从主存中读取了 i 值，这时这两个线程读取的 i 值是一样的，都是 10 ，然后线程 2 对 i 进行了加 1 操作，并立即写回主存中。此时，根据 MESI 协议，线程 1 的工作内存对应的缓存行会被置为无效状态，没错。但是，请注意，线程 1 早已经将 i 值从主存中拷贝过了，现在只要执行加 1 操作和写回主存的操作了。而这两个线程都是在 10 的基础上加 1 ，然后又写回主存中，所以最后主存的值只是 11 ，而不是预期的 12 。</p><p>所以说，使用 volatile 可以保证内存可见性，但无法保证原子性，如果还需要原子性，可以参考，之前的这篇文章。</p><h2 id=volatile-是如何保证有序性的><strong>volatile 是如何保证有序性的</strong></h2><p>Java 内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从 happens-before 原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p><p>如下是 happens-before 的8条原则，摘自 《深入理解Java虚拟机》。</p><ul><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li><li>锁定规则：一个 unLock 操作先行发生于后面对同一个锁的 lock 操作；</li><li>volatile 变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</li><li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</li><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</li><li>对象终结规则：一个对象的初始化完成先行发生于他的 finalize() 方法的开始；</li></ul><p>这里主要说一下 volatile 关键字的规则，举一个著名的单例模式中的双重检查的例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Singleton</span><span class=o>{</span>  
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>volatile</span> <span class=kd>static</span> <span class=n>Singleton</span> <span class=n>instance</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>  
</span></span><span class=line><span class=cl>       
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=nf>Singleton</span><span class=o>()</span> <span class=o>{</span>  
</span></span><span class=line><span class=cl>           
</span></span><span class=line><span class=cl>    <span class=o>}</span>  
</span></span><span class=line><span class=cl>       
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=n>Singleton</span> <span class=nf>getInstance</span><span class=o>()</span> <span class=o>{</span>  
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=o>(</span><span class=n>instance</span><span class=o>==</span><span class=kc>null</span><span class=o>)</span> <span class=o>{</span>                <span class=c1>//  step 1
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=kd>synchronized</span> <span class=o>(</span><span class=n>Singleton</span><span class=o>.</span><span class=na>class</span><span class=o>)</span> <span class=o>{</span>  
</span></span><span class=line><span class=cl>                <span class=k>if</span><span class=o>(</span><span class=n>instance</span><span class=o>==</span><span class=kc>null</span><span class=o>)</span>          <span class=c1>//  step 2
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=n>instance</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Singleton</span><span class=o>();</span>  <span class=c1>//step 3
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=o>}</span>  
</span></span><span class=line><span class=cl>        <span class=o>}</span>  
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>instance</span><span class=o>;</span>  
</span></span><span class=line><span class=cl>    <span class=o>}</span>  
</span></span><span class=line><span class=cl><span class=o>}</span> 
</span></span></code></pre></div><p>如果 instance 不用 volatile 修饰，可能产生什么结果呢，假设有两个线程在调用 getInstance() 方法，线程 1 执行步骤 step1 ，发现 instance 为 null ，然后同步锁住 Singleton 类，接着再次判断 instance 是否为 null ，发现仍然是 null，然后执行 step 3 ，开始实例化 Singleton 。而在实例化的过程中，线程 2 走到 step 1，有可能发现 instance 不为空，但是此时 instance 有可能还没有完全初始化。</p><p>什么意思呢，对象在初始化的时候分三个步骤，用下面的伪代码表示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>memory</span> <span class=o>=</span> <span class=n>allocate</span><span class=o>();</span>  <span class=c1>//1. 分配对象的内存空间 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ctorInstance</span><span class=o>(</span><span class=n>memory</span><span class=o>);</span> <span class=c1>//2. 初始化对象
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>instance</span> <span class=o>=</span> <span class=n>memory</span><span class=o>;</span>    <span class=c1>//3. 设置 instance 指向对象的内存空间
</span></span></span></code></pre></div><p>因为步骤 2 和步骤 3 需要依赖步骤 1，而步骤 2 和 步骤 3 并没有依赖关系，所以这两条语句有可能会发生指令重排，也就是或有可能步骤 3 在步骤 2 的之前执行。在这种情况下，步骤 3 执行了，但是步骤 2 还没有执行，也就是说 instance 实例还没有初始化完毕，正好，在此刻，线程 2 判断 instance 不为 null，所以就直接返回了 instance 实例，但是，这个时候 instance 其实是一个不完全的对象，所以，在使用的时候就会出现问题。</p><p>而使用 volatile 关键字，也就是使用了 “对一个 volatile修饰的变量的写，happens-before于任意后续对该变量的读” 这一原则，对应到上面的初始化过程，步骤2 和 3 都是对 instance 的写，所以一定发生于后面对 instance 的读，也就是不会出现返回不完全初始化的 instance 这种可能。</p><p>JVM 底层是通过一个叫做“内存屏障”的东西来完成。内存屏障，也叫做内存栅栏，是一组处理器指令，用于实现对内存操作的顺序限制。</p></article><div class=toc><h2>文章目录</h2><nav id=TableOfContents><ul><li><a href=#并发的三个特性><strong>并发的三个特性</strong></a></li><li><a href=#volatile-是如何保证可见性的><strong>volatile 是如何保证可见性的</strong></a></li><li><a href=#volatile-是如何保证有序性的><strong>volatile 是如何保证有序性的</strong></a></li></ul></nav></div><script>window.addEventListener("scroll",function(){var e=document.querySelector(".toc"),t=window.pageYOffset||document.documentElement.scrollTop,n=window.innerWidth||document.documentElement.clientWidth;t<360?e.style.top=380-t+"px":e.style.top="20px"})</script><h4>相关文章</h4><dl class=row><dd class=col-md-9><a href=/category/java/%E7%B1%BB%E9%94%81%E5%92%8C%E5%AF%B9%E8%B1%A1%E9%94%81%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/>类锁和对象锁到底有什么区别</a></dd><dd class=col-md-9><a href=/category/java/Java-%E8%B0%83%E5%BC%8F%E7%83%AD%E9%83%A8%E7%BD%B2JVM-%E8%83%8C%E5%90%8E%E7%9A%84%E6%94%AF%E6%8C%81%E8%80%85-Java-Agent/>Java 调式、热部署、JVM 背后的支持者 Java Agent</a></dd><dd class=col-md-9><a href=/category/java/Synchronized/>synchronized 到底该不该用？</a></dd><dd class=col-md-9><a href=/category/java/RPC-%E6%A6%82%E8%A7%88/>RPC框架的核心是什么？</a></dd><dd class=col-md-9><a href=/category/SpringCloud/0-Srping-Cloud-%E5%BC%80%E7%AF%87/>0. Spring Cloud 是什么</a></dd></dl><div class=author-card><div class=underline></div><div class=author-box><div class=qr-author-image><a href=/><img src=/images/person.jpg alt=风筝></a></div><div class=author-content><p class=author-title>作者</p><p class=author-name>风筝</p><p class=author-desc>古时的风筝，一个平庸的程序员，主语言 Java，第二语言 Python，其实学 Python 的时间比 Java 还要早。喜欢写博客，写博客的过程能加深自己对一个知识点的理解，同时还可以分享给他人。喜欢做一些小东西，所以也会一些前端的东西，React、JavaScript、CSS 都会一些，做一些小工具还够用。</p></div></div></div><script src=https://utteranc.es/client.js repo=huzhicheng/blog-comment issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></main><div class="footer gradient-2"><div class="container footer-container"><div class=row><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>网站地图</div><ul class=list-unstyled><li><a href=https://www.moonkite.cn/tags/>标签</a></li><li><a href=https://www.moonkite.cn/categories/>分类</a></li><li><a rel=alternate type=application/rss+xml href=https://www.moonkite.cn/index.xml><i class="fas fa-rss-square"></i> RSS订阅</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>社群</div><ul class=list-unstyled><li><a href=https://github.com/huzhicheng rel=noopener target=_blank>GitHub</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>友链</div><ul class=list-unstyled><li><a href=https://github.com/huzhicheng rel=noopener target=_blank>关于我</a></li></ul></div><div class="col-xs-12 col-sm-3 col-md-3 col-lg-3"><p class="pull-right text-right"><small><em>Proudly powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo</a></em></small><br><small><em>Theme - <a href=https://github.com/shaform/hugo-theme-den rel=noopener target=_blank>Den</a></em></small><br><small>&copy;
风筝
2023</small></p></div></div><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?e417ddf834c7bb7411207e1fa09815aa",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-C714TFXRD4"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-C714TFXRD4")</script></div></div><script src=https://cdn.staticfile.org/jquery/3.3.1/jquery.slim.min.js integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script>
<script src=https://cdn.staticfile.org/popper.js/1.14.3/umd/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=https://cdn.staticfile.org/twitter-bootstrap/4.1.3/js/bootstrap.js></script>
<script>$(document).ready(function(){$("#load_disqus").length&&$(window).scroll(function(){if($("#load_disqus").length){var e=$("#load_disqus").offset().top,t=$(window).scrollTop(),n=t+$(window).height();t<e&&e<n&&load_disqus()}})})</script></body></html>